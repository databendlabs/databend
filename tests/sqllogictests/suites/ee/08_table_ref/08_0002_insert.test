## Copyright 2023 Databend Cloud
##
## Licensed under the Elastic License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##     https://www.elastic.co/licensing/elastic-license
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

statement ok
set enable_experimental_table_ref=1;

statement ok
DROP DATABASE IF EXISTS test_table_ref_insert

statement ok
CREATE DATABASE test_table_ref_insert

statement ok
USE test_table_ref_insert

statement ok
set data_retention_time_in_days = 0;

## Prepare base table and references
statement ok
CREATE OR REPLACE TABLE t1(a INT, b STRING)

statement ok
INSERT INTO t1 VALUES (1, 'main1'), (2, 'main2')

statement ok
ALTER TABLE t1 CREATE BRANCH dev

## Insert into branch and validate isolation from main table
statement ok
INSERT INTO t1/dev VALUES (10, 'dev_only')

## Insert into main table, branch stays untouched
statement ok
INSERT INTO t1 VALUES (100, 'main_only')

query IT
SELECT * FROM t1 ORDER BY a
----
1 main1
2 main2
100 main_only

query IT
SELECT * FROM t1/dev ORDER BY a
----
1 main1
2 main2
10 dev_only

## Insert into branch from a SELECT source
statement ok
INSERT INTO t1/dev SELECT a + 1000, CONCAT(b, '_branch_copy') FROM t1 WHERE a >= 2

query IT
SELECT * FROM t1/dev ORDER BY a
----
1 main1
2 main2
10 dev_only
1002 main2_branch_copy
1100 main_only_branch_copy

## Tag references remain read-only for DML
statement ok
ALTER TABLE t1 CREATE TAG release_tag

query IT
SELECT * FROM t1/release_tag ORDER BY a
----
1 main1
2 main2
100 main_only

statement error 3905
INSERT INTO t1/release_tag VALUES (999, 'should_fail')

query IT
SELECT * FROM t1/release_tag ORDER BY a
----
1 main1
2 main2
100 main_only

statement ok
CREATE TABLE t2(a INT, b STRING);

statement ok
INSERT INTO t2 SELECT * FROM t1/dev WHERE a > 1000;

query IT
SELECT * FROM t2 ORDER BY a
----
1002 main2_branch_copy
1100 main_only_branch_copy

statement ok
drop stage if exists test_table_ref_insert;

## INSERT INTO branch FROM stage is not supported yet
statement ok
create stage test_table_ref_insert;

statement ok
copy into @test_table_ref_insert from (select 99, 'from_stage') file_format=(type=csv);

statement error 1002
INSERT INTO t1/dev FROM @test_table_ref_insert file_format=(type='csv')

query I
SELECT count() FROM fuse_snapshot('test_table_ref_insert','t1/dev');
----
3

query I
SELECT MIN(CASE WHEN snapshot_location LIKE '%/_ref/%' THEN 1 ELSE 0 END)
FROM fuse_snapshot('test_table_ref_insert','t1/dev');
----
1

query I
SELECT count() FROM fuse_snapshot('test_table_ref_insert','t1');
----
2

query I
SELECT MAX(CASE WHEN snapshot_location LIKE '%/_ref/%' THEN 1 ELSE 0 END)
FROM fuse_snapshot('test_table_ref_insert','t1');
----
0

statement ok
DROP DATABASE test_table_ref_insert
