## Copyright 2023 Databend Cloud
##
## Licensed under the Elastic License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##     https://www.elastic.co/licensing/elastic-license
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

## Test: Row Access Policy should not incorrectly hit query result cache
## when different sessions have different variable values.

statement ok
set global enable_experimental_row_access_policy = 1;

statement ok
set enable_planner_cache = 0;

statement ok
drop table if exists rap_cache_test;

statement ok
drop row access policy if exists rap_cache_policy;

## Create a row access policy that uses GETVARIABLE
statement ok
CREATE ROW ACCESS POLICY rap_cache_policy AS (app_name_col STRING) RETURNS BOOLEAN ->
  app_name_col = GETVARIABLE('app_name');

statement ok
create table rap_cache_test(id int, app_name string, data string);

statement ok
insert into rap_cache_test values
  (1, 'app_a', 'data for app a - row 1'),
  (2, 'app_a', 'data for app a - row 2'),
  (3, 'app_b', 'data for app b - row 1'),
  (4, 'app_b', 'data for app b - row 2'),
  (5, 'app_b', 'data for app b - row 3');

statement ok
alter table rap_cache_test add row access policy rap_cache_policy on (app_name);

## Enable query result cache
statement ok
SET enable_query_result_cache = 1;

statement ok
SET query_result_cache_min_execute_secs = 0;

## ========================================
## Step 1: SET var=a, SELECT, EXPLAIN SELECT (should hit cache)
## ========================================

statement ok
SET VARIABLE app_name = 'app_a';

## Execute query - writes to cache
query ITT
SELECT * FROM rap_cache_test ORDER BY id;
----
1 app_a data for app a - row 1
2 app_a data for app a - row 2

## EXPLAIN should show cache hit (same variable value)
query T
EXPLAIN SELECT * FROM rap_cache_test ORDER BY id;
----
ReadQueryResultCache
├── SQL: SELECT * FROM rap_cache_test ORDER BY id
├── Number of rows: 2
└── Result size: 119

## ========================================
## Step 2: SET var=b, EXPLAIN SELECT (should NOT hit cache)
## ========================================

statement ok
SET VARIABLE app_name = 'app_b';

## EXPLAIN should NOT show ReadQueryResultCache because variable changed
## It should show a normal query plan instead
query T
EXPLAIN SELECT * FROM rap_cache_test ORDER BY id;
----
Sort(Single)
├── output columns: [rap_cache_test.id (#0), rap_cache_test.app_name (#1), rap_cache_test.data (#2)]
├── sort keys: [id ASC NULLS LAST]
├── estimated rows: 2.50
└── SecureFilter
    ├── output columns: [rap_cache_test.id (#0), rap_cache_test.app_name (#1), rap_cache_test.data (#2)]
    ├── secure filters: [SECURE: is_true(rap_cache_test.app_name (#1) = 'app_b')]
    ├── estimated rows: 2.50
    └── TableScan
        ├── table: default.default.rap_cache_test
        ├── scan id: 0
        ├── output columns: [id (#0), app_name (#1), data (#2)]
        ├── read rows: 5
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1 cost: 1 ms>, blocks: <range pruning: 1 to 1 cost: 1 ms>]
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 5.00

## ========================================
## Step 3: SELECT, EXPLAIN SELECT (should hit cache now)
## ========================================

## Execute query with var=b - writes to its own cache
query ITT
SELECT * FROM rap_cache_test ORDER BY id;
----
3 app_b data for app b - row 1
4 app_b data for app b - row 2
5 app_b data for app b - row 3

## EXPLAIN should show cache hit now (cache populated for var=b)
## Note: Number of rows: 3 (different from app_a's 2 rows)
query T
EXPLAIN SELECT * FROM rap_cache_test ORDER BY id;
----
ReadQueryResultCache
├── SQL: SELECT * FROM rap_cache_test ORDER BY id
├── Number of rows: 3
└── Result size: 177

## ========================================
## Step 4: Switch back to var=a, verify it still has its own cache
## ========================================

statement ok
SET VARIABLE app_name = 'app_a';

## Should hit cache for var=a (cached earlier)
query T
EXPLAIN SELECT * FROM rap_cache_test ORDER BY id;
----
ReadQueryResultCache
├── SQL: SELECT * FROM rap_cache_test ORDER BY id
├── Number of rows: 2
└── Result size: 119

## Verify data is correct for app_a
query ITT
SELECT * FROM rap_cache_test ORDER BY id;
----
1 app_a data for app a - row 1
2 app_a data for app a - row 2

## ========================================
## Cleanup
## ========================================

statement ok
SET enable_query_result_cache = 0;

statement ok
drop table rap_cache_test;

statement ok
drop row access policy rap_cache_policy;
