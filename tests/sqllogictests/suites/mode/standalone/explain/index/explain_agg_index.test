statement ok
set enable_auto_materialize_cte = 0;

statement ok
DROP DATABASE IF EXISTS test_index_db

statement ok
CREATE DATABASE test_index_db

statement ok
USE test_index_db

statement ok
DROP TABLE IF EXISTS t1

statement ok
CREATE TABLE t1(a int not null,b int not null) Engine = Fuse

statement ok
DROP AGGREGATING INDEX IF EXISTS idx1

statement ok
CREATE AGGREGATING INDEX idx1 AS SELECT b, SUM(a) FROM t1 WHERE b > 3 GROUP BY b

query T
EXPLAIN SELECT SUM(a), b FROM t1 WHERE b > 3 GROUP BY b
----
AggregateFinal
├── output columns: [SUM(a) (#2), t1.b (#1)]
├── group by: [b]
├── aggregate functions: [sum(a)]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: [b]
    ├── aggregate functions: [sum(a)]
    ├── estimated rows: 1.00
    └── Filter
        ├── output columns: [t1.a (#0), t1.b (#1)]
        ├── filters: [t1.b (#1) > 3]
        ├── estimated rows: 0.00
        └── TableScan
            ├── table: default.test_index_db.t1
            ├── scan id: 0
            ├── output columns: [a (#0), b (#1)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [t1.b (#1) > 3], limit: NONE]
            ├── aggregating index: [SELECT b, SUM(a) FROM test_index_db.t1 WHERE b > 3 GROUP BY b]
            ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1)]]
            └── estimated rows: 0.00

query T
EXPLAIN SELECT b FROM t1 WHERE b > 3 GROUP BY b
----
AggregateFinal
├── output columns: [t1.b (#1)]
├── group by: [b]
├── aggregate functions: []
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: [b]
    ├── aggregate functions: []
    ├── estimated rows: 1.00
    └── Filter
        ├── output columns: [t1.b (#1)]
        ├── filters: [t1.b (#1) > 3]
        ├── estimated rows: 0.00
        └── TableScan
            ├── table: default.test_index_db.t1
            ├── scan id: 0
            ├── output columns: [b (#1)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [t1.b (#1) > 3], limit: NONE]
            ├── aggregating index: [SELECT b, SUM(a) FROM test_index_db.t1 WHERE b > 3 GROUP BY b]
            ├── rewritten query: [selection: [index_col_0 (#0)]]
            └── estimated rows: 0.00

query T
EXPLAIN SELECT SUM(a) + 1 FROM t1 WHERE b > 3 GROUP BY b
----
EvalScalar
├── output columns: [sum(a) + 1 (#3)]
├── expressions: [SUM(a) (#2) + 1]
├── estimated rows: 1.00
└── AggregateFinal
    ├── output columns: [SUM(a) (#2), t1.b (#1)]
    ├── group by: [b]
    ├── aggregate functions: [sum(a)]
    ├── estimated rows: 1.00
    └── AggregatePartial
        ├── group by: [b]
        ├── aggregate functions: [sum(a)]
        ├── estimated rows: 1.00
        └── Filter
            ├── output columns: [t1.a (#0), t1.b (#1)]
            ├── filters: [t1.b (#1) > 3]
            ├── estimated rows: 0.00
            └── TableScan
                ├── table: default.test_index_db.t1
                ├── scan id: 0
                ├── output columns: [a (#0), b (#1)]
                ├── read rows: 0
                ├── read size: 0
                ├── partitions total: 0
                ├── partitions scanned: 0
                ├── push downs: [filters: [t1.b (#1) > 3], limit: NONE]
                ├── aggregating index: [SELECT b, SUM(a) FROM test_index_db.t1 WHERE b > 3 GROUP BY b]
                ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1)]]
                └── estimated rows: 0.00

query T
EXPLAIN SELECT SUM(a) + 1 FROM t1 WHERE b > 5 GROUP BY b
----
EvalScalar
├── output columns: [sum(a) + 1 (#3)]
├── expressions: [SUM(a) (#2) + 1]
├── estimated rows: 1.00
└── AggregateFinal
    ├── output columns: [SUM(a) (#2), t1.b (#1)]
    ├── group by: [b]
    ├── aggregate functions: [sum(a)]
    ├── estimated rows: 1.00
    └── AggregatePartial
        ├── group by: [b]
        ├── aggregate functions: [sum(a)]
        ├── estimated rows: 1.00
        └── Filter
            ├── output columns: [t1.a (#0), t1.b (#1)]
            ├── filters: [t1.b (#1) > 5]
            ├── estimated rows: 0.00
            └── TableScan
                ├── table: default.test_index_db.t1
                ├── scan id: 0
                ├── output columns: [a (#0), b (#1)]
                ├── read rows: 0
                ├── read size: 0
                ├── partitions total: 0
                ├── partitions scanned: 0
                ├── push downs: [filters: [t1.b (#1) > 5], limit: NONE]
                ├── aggregating index: [SELECT b, SUM(a) FROM test_index_db.t1 WHERE b > 3 GROUP BY b]
                ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1)], filter: index_col_0 (#0) > 5]
                └── estimated rows: 0.00

query T
EXPLAIN SELECT t1.b, SUM(a) FROM t1 GROUP BY t1.b HAVING SUM(a)=(SELECT SUM(a) FROM t1 t WHERE t1.b=t.b and t.b > 3)
----
HashJoin
├── output columns: [SUM(a) (#2), t1.b (#1)]
├── join type: INNER
├── build keys: [scalar_subquery_5 (#5), b (#4)]
├── probe keys: [SUM(a) (#2), b (#1)]
├── keys is null equal: [false, false]
├── filters: []
├── build join filters:
│   └── filter id:0, build key:b (#4), probe targets:[b (#1)@scan0], filter type:bloom,inlist,min_max
├── estimated rows: 1.00
├── AggregateFinal(Build)
│   ├── output columns: [SUM(a) (#5), t.b (#4)]
│   ├── group by: [b]
│   ├── aggregate functions: [sum(a)]
│   ├── estimated rows: 1.00
│   └── AggregatePartial
│       ├── group by: [b]
│       ├── aggregate functions: [sum(a)]
│       ├── estimated rows: 1.00
│       └── Filter
│           ├── output columns: [t.a (#3), t.b (#4)]
│           ├── filters: [outer.b (#4) > 3]
│           ├── estimated rows: 0.00
│           └── TableScan
│               ├── table: default.test_index_db.t1
│               ├── scan id: 1
│               ├── output columns: [a (#3), b (#4)]
│               ├── read rows: 0
│               ├── read size: 0
│               ├── partitions total: 0
│               ├── partitions scanned: 0
│               ├── push downs: [filters: [t1.b (#4) > 3], limit: NONE]
│               ├── aggregating index: [SELECT b, SUM(a) FROM test_index_db.t1 WHERE b > 3 GROUP BY b]
│               ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1)]]
│               └── estimated rows: 0.00
└── AggregateFinal(Probe)
    ├── output columns: [SUM(a) (#2), t1.b (#1)]
    ├── group by: [b]
    ├── aggregate functions: [sum(a)]
    ├── estimated rows: 1.00
    └── AggregatePartial
        ├── group by: [b]
        ├── aggregate functions: [sum(a)]
        ├── estimated rows: 1.00
        └── TableScan
            ├── table: default.test_index_db.t1
            ├── scan id: 0
            ├── output columns: [a (#0), b (#1)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [], limit: NONE]
            ├── apply join filters: [#0]
            └── estimated rows: 0.00

# Disable aggregating index scan
statement ok
SET enable_aggregating_index_scan = 0

query T
EXPLAIN SELECT SUM(a), b FROM t1 WHERE b > 3 GROUP BY b
----
AggregateFinal
├── output columns: [SUM(a) (#2), t1.b (#1)]
├── group by: [b]
├── aggregate functions: [sum(a)]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: [b]
    ├── aggregate functions: [sum(a)]
    ├── estimated rows: 1.00
    └── Filter
        ├── output columns: [t1.a (#0), t1.b (#1)]
        ├── filters: [t1.b (#1) > 3]
        ├── estimated rows: 0.00
        └── TableScan
            ├── table: default.test_index_db.t1
            ├── scan id: 0
            ├── output columns: [a (#0), b (#1)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [t1.b (#1) > 3], limit: NONE]
            └── estimated rows: 0.00

statement ok
SET enable_aggregating_index_scan = 1

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE AGGREGATING INDEX idx1 AS SELECT avg(a), sum(b) from t1

query T
EXPLAIN SELECT avg(a) from t1
----
EvalScalar
├── output columns: [sum(a) / if(count(a) = 0, 1, count(a)) (#4)]
├── expressions: [sum(a) (#2) / CAST(if(CAST(count(a) (#3) = 0 AS Boolean NULL), 1, count(a) (#3)) AS UInt64 NULL)]
├── estimated rows: 1.00
└── AggregateFinal
    ├── output columns: [sum(a) (#2), count(a) (#3)]
    ├── group by: []
    ├── aggregate functions: [sum(a), count()]
    ├── estimated rows: 1.00
    └── AggregatePartial
        ├── group by: []
        ├── aggregate functions: [sum(a), count()]
        ├── estimated rows: 1.00
        └── TableScan
            ├── table: default.test_index_db.t1
            ├── scan id: 0
            ├── output columns: [a (#0)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [], limit: NONE]
            ├── aggregating index: [SELECT COUNT(), COUNT(a), SUM(a), SUM(b) FROM test_index_db.t1]
            ├── rewritten query: [selection: [index_col_2 (#2), index_col_0 (#0)]]
            └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE TABLE onebrc (station_name VARCHAR NULL, measurement DOUBLE NULL);

statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name

query T
EXPLAIN SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name
----
EvalScalar
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
├── estimated rows: 1.00
└── AggregateFinal
    ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0)]
    ├── group by: [station_name]
    ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
    ├── estimated rows: 1.00
    └── AggregatePartial
        ├── group by: [station_name]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── TableScan
            ├── table: default.test_index_db.onebrc
            ├── scan id: 0
            ├── output columns: [station_name (#0), measurement (#1)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [], limit: NONE]
            ├── aggregating index: [SELECT station_name, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc GROUP BY station_name]
            ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_5 (#5), index_col_2 (#2), index_col_3 (#3)]]
            └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name

query T
EXPLAIN SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0)]
        ├── group by: [station_name]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.test_index_db.onebrc
                ├── scan id: 0
                ├── output columns: [station_name (#0), measurement (#1)]
                ├── read rows: 0
                ├── read size: 0
                ├── partitions total: 0
                ├── partitions scanned: 0
                ├── push downs: [filters: [], limit: NONE]
                ├── aggregating index: [SELECT station_name, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc GROUP BY station_name]
                ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_5 (#5), index_col_2 (#2), index_col_3 (#3)]]
                └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name

query T
EXPLAIN SELECT * FROM (SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name) ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0)]
        ├── group by: [station_name]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.test_index_db.onebrc
                ├── scan id: 0
                ├── output columns: [station_name (#0), measurement (#1)]
                ├── read rows: 0
                ├── read size: 0
                ├── partitions total: 0
                ├── partitions scanned: 0
                ├── push downs: [filters: [], limit: NONE]
                ├── aggregating index: [SELECT station_name, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc GROUP BY station_name]
                ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_5 (#5), index_col_2 (#2), index_col_3 (#3)]]
                └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name

query T
EXPLAIN WITH aggi AS (SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name) SELECT * FROM aggi ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0)]
        ├── group by: [station_name]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.test_index_db.onebrc
                ├── scan id: 0
                ├── output columns: [station_name (#0), measurement (#1)]
                ├── read rows: 0
                ├── read size: 0
                ├── partitions total: 0
                ├── partitions scanned: 0
                ├── push downs: [filters: [], limit: NONE]
                ├── aggregating index: [SELECT station_name, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc GROUP BY station_name]
                ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_5 (#5), index_col_2 (#2), index_col_3 (#3)]]
                └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

# no predicates but query has predicates
statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, measurement, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc GROUP BY station_name, measurement

query T
EXPLAIN WITH aggi AS (SELECT station_name, measurement, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc WHERE station_name='Beijing' AND measurement > 0 AND measurement IN (1, 2) GROUP BY station_name, measurement) SELECT * FROM aggi ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), onebrc.measurement (#1), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), onebrc.measurement (#1), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0), onebrc.measurement (#1)]
        ├── group by: [station_name, measurement]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name, measurement]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── Filter
                ├── output columns: [onebrc.station_name (#0), onebrc.measurement (#1)]
                ├── filters: [is_true(onebrc.measurement (#1) > 0), is_true(onebrc.station_name (#0) = 'Beijing'), onebrc.measurement (#1) = 1 or onebrc.measurement (#1) = 2]
                ├── estimated rows: 0.00
                └── TableScan
                    ├── table: default.test_index_db.onebrc
                    ├── scan id: 0
                    ├── output columns: [station_name (#0), measurement (#1)]
                    ├── read rows: 0
                    ├── read size: 0
                    ├── partitions total: 0
                    ├── partitions scanned: 0
                    ├── push downs: [filters: [onebrc.measurement (#1) > 0 and onebrc.station_name (#0) = 'Beijing' and (onebrc.measurement (#1) = 1 or onebrc.measurement (#1) = 2)], limit: NONE]
                    ├── aggregating index: [SELECT station_name, measurement, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc GROUP BY station_name, measurement]
                    ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1), index_col_5 (#5), index_col_6 (#6), index_col_3 (#3), index_col_4 (#4)], filter: is_true(((index_col_1 (#1) > CAST(0 AS Float64 NULL) AND index_col_0 (#0) = CAST('Beijing' AS String NULL)) AND CAST(index_col_1 (#1) = CAST(1 AS Float64 NULL) or index_col_1 (#1) = CAST(2 AS Float64 NULL) AS Boolean NULL)))]
                    └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

# with equal predicates
statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc WHERE station_name='Beijing' GROUP BY station_name

query T
EXPLAIN WITH aggi AS (SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc WHERE station_name='Beijing' GROUP BY station_name) SELECT * FROM aggi ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0)]
        ├── group by: [station_name]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── Filter
                ├── output columns: [onebrc.station_name (#0), onebrc.measurement (#1)]
                ├── filters: [is_true(onebrc.station_name (#0) = 'Beijing')]
                ├── estimated rows: 0.00
                └── TableScan
                    ├── table: default.test_index_db.onebrc
                    ├── scan id: 0
                    ├── output columns: [station_name (#0), measurement (#1)]
                    ├── read rows: 0
                    ├── read size: 0
                    ├── partitions total: 0
                    ├── partitions scanned: 0
                    ├── push downs: [filters: [is_true(onebrc.station_name (#0) = 'Beijing')], limit: NONE]
                    ├── aggregating index: [SELECT station_name, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc WHERE station_name = 'Beijing' GROUP BY station_name]
                    ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_5 (#5), index_col_2 (#2), index_col_3 (#3)]]
                    └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

# with range predicates
statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, measurement, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc WHERE measurement > 1 and measurement < 5 GROUP BY station_name, measurement

query T
EXPLAIN WITH aggi AS (SELECT station_name, measurement, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc where measurement > 2 and measurement < 5 GROUP BY station_name, measurement) SELECT * FROM aggi ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), onebrc.measurement (#1), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), onebrc.measurement (#1), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0), onebrc.measurement (#1)]
        ├── group by: [station_name, measurement]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name, measurement]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── Filter
                ├── output columns: [onebrc.station_name (#0), onebrc.measurement (#1)]
                ├── filters: [is_true(onebrc.measurement (#1) > 2), is_true(onebrc.measurement (#1) < 5)]
                ├── estimated rows: 0.00
                └── TableScan
                    ├── table: default.test_index_db.onebrc
                    ├── scan id: 0
                    ├── output columns: [station_name (#0), measurement (#1)]
                    ├── read rows: 0
                    ├── read size: 0
                    ├── partitions total: 0
                    ├── partitions scanned: 0
                    ├── push downs: [filters: [onebrc.measurement (#1) > 2 and onebrc.measurement (#1) < 5], limit: NONE]
                    ├── aggregating index: [SELECT station_name, measurement, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc WHERE measurement > 1 AND measurement < 5 GROUP BY station_name, measurement]
                    ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1), index_col_5 (#5), index_col_6 (#6), index_col_3 (#3), index_col_4 (#4)], filter: is_true(index_col_1 (#1) > CAST(2 AS Float64 NULL))]
                    └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

# with other predicates
statement ok
CREATE AGGREGATING INDEX idx1 as SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc WHERE station_name IN ('Paris', 'Beijing') GROUP BY station_name

query T
EXPLAIN WITH aggi AS (SELECT station_name, MIN(measurement) AS min_measurement, AVG(measurement) AS mean_measurement, MAX(measurement) AS max_measurement FROM onebrc WHERE station_name IN ('Paris', 'Beijing') GROUP BY station_name) SELECT * FROM aggi ORDER BY station_name
----
Sort(Single)
├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
├── sort keys: [station_name ASC NULLS LAST]
├── estimated rows: 1.00
└── EvalScalar
    ├── output columns: [MIN(measurement) (#2), MAX(measurement) (#5), onebrc.station_name (#0), mean_measurement (#6)]
    ├── expressions: [sum(measurement) (#3) / CAST(if(CAST(count(measurement) (#4) = 0 AS Boolean NULL), 1, count(measurement) (#4)) AS UInt64 NULL)]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [MIN(measurement) (#2), sum(measurement) (#3), count(measurement) (#4), MAX(measurement) (#5), onebrc.station_name (#0)]
        ├── group by: [station_name]
        ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [station_name]
            ├── aggregate functions: [min(measurement), sum(measurement), count(measurement), max(measurement)]
            ├── estimated rows: 1.00
            └── Filter
                ├── output columns: [onebrc.station_name (#0), onebrc.measurement (#1)]
                ├── filters: [onebrc.station_name (#0) = 'Paris' or onebrc.station_name (#0) = 'Beijing']
                ├── estimated rows: 0.00
                └── TableScan
                    ├── table: default.test_index_db.onebrc
                    ├── scan id: 0
                    ├── output columns: [station_name (#0), measurement (#1)]
                    ├── read rows: 0
                    ├── read size: 0
                    ├── partitions total: 0
                    ├── partitions scanned: 0
                    ├── push downs: [filters: [onebrc.station_name (#0) = 'Paris' or onebrc.station_name (#0) = 'Beijing'], limit: NONE]
                    ├── aggregating index: [SELECT station_name, COUNT(), COUNT(measurement), MAX(measurement), MIN(measurement), SUM(measurement) FROM test_index_db.onebrc WHERE station_name IN('Paris', 'Beijing') GROUP BY station_name]
                    ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_5 (#5), index_col_2 (#2), index_col_3 (#3)]]
                    └── estimated rows: 0.00

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE AGGREGATING INDEX idx1 AS SELECT count(measurement), sum(measurement) from onebrc

query T
EXPLAIN SELECT count(measurement) from onebrc
----
AggregateFinal
├── output columns: [count(measurement) (#2)]
├── group by: []
├── aggregate functions: [count(measurement)]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: []
    ├── aggregate functions: [count(measurement)]
    ├── estimated rows: 1.00
    └── TableScan
        ├── table: default.test_index_db.onebrc
        ├── scan id: 0
        ├── output columns: [measurement (#1)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [], limit: NONE]
        ├── aggregating index: [SELECT COUNT(), COUNT(measurement), SUM(measurement) FROM test_index_db.onebrc]
        ├── rewritten query: [selection: [index_col_1 (#1)]]
        └── estimated rows: 0.00


statement ok
DROP TABLE IF EXISTS onebrc

statement ok
DROP AGGREGATING INDEX idx1

statement ok
CREATE AGGREGATING INDEX idx1 AS SELECT min(a), max(a), count(*), avg(a) FROM t1 GROUP BY b

query T
EXPLAIN SELECT min(a), max(a), count(*) FROM t1 GROUP BY b
----
AggregateFinal
├── output columns: [min(a) (#2), max(a) (#3), COUNT(*) (#4), t1.b (#1)]
├── group by: [b]
├── aggregate functions: [min(a), max(a), count()]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: [b]
    ├── aggregate functions: [min(a), max(a), count()]
    ├── estimated rows: 1.00
    └── TableScan
        ├── table: default.test_index_db.t1
        ├── scan id: 0
        ├── output columns: [a (#0), b (#1)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [], limit: NONE]
        ├── aggregating index: [SELECT COUNT(), COUNT(a), MAX(a), MIN(a), SUM(a), b FROM test_index_db.t1 GROUP BY b]
        ├── rewritten query: [selection: [index_col_0 (#0), index_col_4 (#4), index_col_3 (#3), index_col_1 (#1)]]
        └── estimated rows: 0.00


statement ok
CREATE TABLE t(id int, user_id int, event_name varchar)

statement ok
INSERT INTO t (id, user_id, event_name)
VALUES (1, 1, 'Login'),
       (2, 2, 'Login'),
       (3, 3, 'Login'),
       (4, 1, 'Logout'),
       (5, 2, 'Logout'),
       (6, 4, 'Login'),
       (7, 1, 'Login'),
       (8, 2, 'Login');

statement ok
CREATE ASYNC AGGREGATING INDEX testi AS select event_name, user_id, max(user_id), avg(id) from t group by event_name, user_id

statement ok
REFRESH AGGREGATING INDEX testi

# ensure we rewrite query by agg index
query T
explain select event_name, user_id, max(user_id), avg(id) from t group by event_name, user_id
----
EvalScalar
├── output columns: [max(user_id) (#3), t.event_name (#2), t.user_id (#1), sum(id) / if(count(id) = 0, 1, count(id)) (#6)]
├── expressions: [sum(id) (#4) / CAST(if(CAST(count(id) (#5) = 0 AS Boolean NULL), 1, count(id) (#5)) AS UInt64 NULL)]
├── estimated rows: 8.00
└── AggregateFinal
    ├── output columns: [max(user_id) (#3), sum(id) (#4), count(id) (#5), t.event_name (#2), t.user_id (#1)]
    ├── group by: [event_name, user_id]
    ├── aggregate functions: [max(user_id), sum(id), count(id)]
    ├── estimated rows: 8.00
    └── AggregatePartial
        ├── group by: [event_name, user_id]
        ├── aggregate functions: [max(user_id), sum(id), count(id)]
        ├── estimated rows: 8.00
        └── TableScan
            ├── table: default.test_index_db.t
            ├── scan id: 0
            ├── output columns: [id (#0), user_id (#1), event_name (#2)]
            ├── read rows: 8
            ├── read size: < 1 KiB
            ├── partitions total: 1
            ├── partitions scanned: 1
            ├── pruning stats: [segments: <range pruning: 1 to 1 cost: <slt:ignore>>, blocks: <range pruning: 1 to 1 cost: <slt:ignore>>]
            ├── push downs: [filters: [], limit: NONE]
            ├── aggregating index: [SELECT event_name, user_id, COUNT(), COUNT(id), MAX(user_id), SUM(id) FROM test_index_db.t GROUP BY event_name, user_id]
            ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1), index_col_4 (#4), index_col_5 (#5), index_col_3 (#3)]]
            └── estimated rows: 8.00

query TIIR rowsort
select event_name, user_id, max(user_id), avg(id) from t group by event_name, user_id
----
Login 1 1 4.0
Login 2 2 5.0
Login 3 3 3.0
Login 4 4 6.0
Logout 1 1 4.0
Logout 2 2 5.0

# ensure we rewrite query by agg index
query T
explain select event_name, user_id, max(user_id), avg(id) from t where user_id > 1 group by event_name, user_id
----
EvalScalar
├── output columns: [max(user_id) (#3), t.event_name (#2), t.user_id (#1), sum(id) / if(count(id) = 0, 1, count(id)) (#6)]
├── expressions: [sum(id) (#4) / CAST(if(CAST(count(id) (#5) = 0 AS Boolean NULL), 1, count(id) (#5)) AS UInt64 NULL)]
├── estimated rows: 6.00
└── AggregateFinal
    ├── output columns: [max(user_id) (#3), sum(id) (#4), count(id) (#5), t.event_name (#2), t.user_id (#1)]
    ├── group by: [event_name, user_id]
    ├── aggregate functions: [max(user_id), sum(id), count(id)]
    ├── estimated rows: 6.00
    └── AggregatePartial
        ├── group by: [event_name, user_id]
        ├── aggregate functions: [max(user_id), sum(id), count(id)]
        ├── estimated rows: 6.00
        └── Filter
            ├── output columns: [t.id (#0), t.user_id (#1), t.event_name (#2)]
            ├── filters: [is_true(t.user_id (#1) > 1)]
            ├── estimated rows: 6.00
            └── TableScan
                ├── table: default.test_index_db.t
                ├── scan id: 0
                ├── output columns: [id (#0), user_id (#1), event_name (#2)]
                ├── read rows: 8
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── pruning stats: [segments: <range pruning: 1 to 1 cost: <slt:ignore>>, blocks: <range pruning: 1 to 1 cost: <slt:ignore>>]
                ├── push downs: [filters: [is_true(t.user_id (#1) > 1)], limit: NONE]
                ├── aggregating index: [SELECT event_name, user_id, COUNT(), COUNT(id), MAX(user_id), SUM(id) FROM test_index_db.t GROUP BY event_name, user_id]
                ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1), index_col_4 (#4), index_col_5 (#5), index_col_3 (#3)], filter: is_true(index_col_0 (#0) > CAST(1 AS Int32 NULL))]
                └── estimated rows: 8.00

query TIIR rowsort
select event_name, user_id, max(user_id), avg(id) from t where user_id > 1 group by event_name, user_id
----
Login 2 2 5.0
Login 3 3 3.0
Login 4 4 6.0
Logout 2 2 5.0

# ensure we rewrite query by agg index
query T
explain select event_name, user_id, max(user_id), avg(id) from t where user_id > 1 group by event_name, user_id order by event_name, user_id desc
----
Sort(Single)
├── output columns: [max(user_id) (#3), t.event_name (#2), t.user_id (#1), sum(id) / if(count(id) = 0, 1, count(id)) (#6)]
├── sort keys: [event_name ASC NULLS LAST, user_id DESC NULLS LAST]
├── estimated rows: 6.00
└── EvalScalar
    ├── output columns: [max(user_id) (#3), t.event_name (#2), t.user_id (#1), sum(id) / if(count(id) = 0, 1, count(id)) (#6)]
    ├── expressions: [sum(id) (#4) / CAST(if(CAST(count(id) (#5) = 0 AS Boolean NULL), 1, count(id) (#5)) AS UInt64 NULL)]
    ├── estimated rows: 6.00
    └── AggregateFinal
        ├── output columns: [max(user_id) (#3), sum(id) (#4), count(id) (#5), t.event_name (#2), t.user_id (#1)]
        ├── group by: [event_name, user_id]
        ├── aggregate functions: [max(user_id), sum(id), count(id)]
        ├── estimated rows: 6.00
        └── AggregatePartial
            ├── group by: [event_name, user_id]
            ├── aggregate functions: [max(user_id), sum(id), count(id)]
            ├── estimated rows: 6.00
            └── Filter
                ├── output columns: [t.id (#0), t.user_id (#1), t.event_name (#2)]
                ├── filters: [is_true(t.user_id (#1) > 1)]
                ├── estimated rows: 6.00
                └── TableScan
                    ├── table: default.test_index_db.t
                    ├── scan id: 0
                    ├── output columns: [id (#0), user_id (#1), event_name (#2)]
                    ├── read rows: 8
                    ├── read size: < 1 KiB
                    ├── partitions total: 1
                    ├── partitions scanned: 1
                    ├── pruning stats: [segments: <range pruning: 1 to 1 cost: <slt:ignore>>, blocks: <range pruning: 1 to 1 cost: <slt:ignore>>]
                    ├── push downs: [filters: [is_true(t.user_id (#1) > 1)], limit: NONE]
                    ├── aggregating index: [SELECT event_name, user_id, COUNT(), COUNT(id), MAX(user_id), SUM(id) FROM test_index_db.t GROUP BY event_name, user_id]
                    ├── rewritten query: [selection: [index_col_0 (#0), index_col_1 (#1), index_col_4 (#4), index_col_5 (#5), index_col_3 (#3)], filter: is_true(index_col_0 (#0) > CAST(1 AS Int32 NULL))]
                    └── estimated rows: 8.00

query TIIR
select event_name, user_id, max(user_id), avg(id) from t where user_id > 1 group by event_name, user_id order by event_name, user_id desc
----
Login 4 4 6.0
Login 3 3 3.0
Login 2 2 5.0
Logout 2 2 5.0

statement ok
DROP AGGREGATING INDEX testi

statement ok
DROP TABLE t

# for sync aggregating index

statement ok
DROP AGGREGATING INDEX idx1

statement ok
USE default

statement ok
DROP DATABASE IF EXISTS test_index_db
