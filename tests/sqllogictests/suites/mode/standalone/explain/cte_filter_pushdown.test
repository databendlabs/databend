# Test cases for CTE filter pushdown optimization
# This test verifies that filters can be correctly pushed down into materialized CTEs

statement ok
create table t (a int, b int, c int);

statement ok
insert into t values (1, 10, 100), (1, 20, 200), (2, 30, 300), (2, 40, 400), (3, 50, 500);

# Test 1: Basic CTE filter pushdown without aggregation
# Filter on base columns should be pushed down
query T
explain with cte1 as materialized (
    select a, b from t
)
select * from cte1 where a = 1;
----
Sequence
├── MaterializedCTE: cte1
│   └── Filter
│       ├── output columns: [t.a (#0), t.b (#1)]
│       ├── filters: [is_true(t.a (#0) = 1)]
│       ├── estimated rows: 1.67
│       └── TableScan
│           ├── table: default.default.t
│           ├── output columns: [a (#0), b (#1)]
│           ├── read rows: 5
│           ├── read size: < 1 KiB
│           ├── partitions total: 1
│           ├── partitions scanned: 1
│           ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│           ├── push downs: [filters: [is_true(t.a (#0) = 1)], limit: NONE]
│           └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#3), t.b (#4)]
    ├── filters: [is_true(cte1.a (#3) = 1)]
    ├── estimated rows: 1.67
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#3), b (#4)]
        └── estimated rows: 5.00

# Test 2: CTE with aggregation - filter on GROUP BY column should be pushed down
query T
explain with cte1 as materialized (
    select a, count(*) as cnt, sum(b) as sum_b
    from t 
    group by a
)
select * from cte1 where a = 1;
----
Sequence
├── MaterializedCTE: cte1
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│       ├── group by: [a]
│       ├── aggregate functions: [count(), sum(b)]
│       ├── estimated rows: 1.00
│       └── AggregatePartial
│           ├── group by: [a]
│           ├── aggregate functions: [count(), sum(b)]
│           ├── estimated rows: 1.00
│           └── Filter
│               ├── output columns: [t.a (#0), t.b (#1)]
│               ├── filters: [is_true(t.a (#0) = 1)]
│               ├── estimated rows: 1.67
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0), b (#1)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [is_true(t.a (#0) = 1)], limit: NONE]
│                   └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#5), COUNT(*) (#8), sum(b) (#9)]
    ├── filters: [is_true(cte1.a (#5) = 1)]
    ├── estimated rows: 1.00
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#5), COUNT(*) (#8), sum(b) (#9)]
        └── estimated rows: 3.00

# Test 3: CTE with aggregation - filter on aggregate result should NOT be pushed down
query T
explain with cte1 as materialized (
    select a, count(*) as cnt, sum(b) as sum_b
    from t 
    group by a
)
select * from cte1 where sum_b > 25;
----
Sequence
├── MaterializedCTE: cte1
│   └── Filter
│       ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│       ├── filters: [is_true(sum(b) (#4) > 25)]
│       ├── estimated rows: 0.00
│       └── AggregateFinal
│           ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│           ├── group by: [a]
│           ├── aggregate functions: [count(), sum(b)]
│           ├── estimated rows: 3.00
│           └── AggregatePartial
│               ├── group by: [a]
│               ├── aggregate functions: [count(), sum(b)]
│               ├── estimated rows: 3.00
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0), b (#1)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│                   ├── push downs: [filters: [], limit: NONE]
│                   └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#5), COUNT(*) (#8), sum(b) (#9)]
    ├── filters: [is_true(cte1.sum_b (#9) > 25)]
    ├── estimated rows: 0.00
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#5), COUNT(*) (#8), sum(b) (#9)]
        └── estimated rows: 3.00

# Test 4: Mixed filters - GROUP BY column filter should be pushed down, aggregate filter should remain
query T
explain with cte1 as materialized (
    select a, count(*) as cnt, sum(b) as sum_b
    from t 
    group by a
)
select * from cte1 where a > 1 and sum_b > 25;
----
Sequence
├── MaterializedCTE: cte1
│   └── Filter
│       ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│       ├── filters: [is_true(sum(b) (#4) > 25)]
│       ├── estimated rows: 0.00
│       └── AggregateFinal
│           ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│           ├── group by: [a]
│           ├── aggregate functions: [count(), sum(b)]
│           ├── estimated rows: 2.00
│           └── AggregatePartial
│               ├── group by: [a]
│               ├── aggregate functions: [count(), sum(b)]
│               ├── estimated rows: 2.00
│               └── Filter
│                   ├── output columns: [t.a (#0), t.b (#1)]
│                   ├── filters: [is_true(t.a (#0) > 1)]
│                   ├── estimated rows: 3.33
│                   └── TableScan
│                       ├── table: default.default.t
│                       ├── output columns: [a (#0), b (#1)]
│                       ├── read rows: 5
│                       ├── read size: < 1 KiB
│                       ├── partitions total: 1
│                       ├── partitions scanned: 1
│                       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│                       ├── push downs: [filters: [is_true(t.a (#0) > 1)], limit: NONE]
│                       └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#5), COUNT(*) (#8), sum(b) (#9)]
    ├── filters: [is_true(cte1.a (#5) > 1), is_true(cte1.sum_b (#9) > 25)]
    ├── estimated rows: 0.00
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#5), COUNT(*) (#8), sum(b) (#9)]
        └── estimated rows: 3.00

# Test 5: Multiple CTE references with different filters
# Should create OR condition in CTE definition
query T
explain with cte1 as materialized (
    select a, count(*) as cnt
    from t 
    group by a
)
select * from cte1 as c1 where c1.a = 1
union all
select * from cte1 as c2 where c2.a = 2;
----
Sequence
├── MaterializedCTE: cte1
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#3), t.a (#0)]
│       ├── group by: [a]
│       ├── aggregate functions: [count()]
│       ├── estimated rows: 2.00
│       └── AggregatePartial
│           ├── group by: [a]
│           ├── aggregate functions: [count()]
│           ├── estimated rows: 2.00
│           └── Filter
│               ├── output columns: [t.a (#0)]
│               ├── filters: [is_true((t.a (#0) = 1 OR t.a (#0) = 2))]
│               ├── estimated rows: 2.78
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [is_true((t.a (#0) = 1 OR t.a (#0) = 2))], limit: NONE]
│                   └── estimated rows: 5.00
└── UnionAll
    ├── output columns: [a (#12), cnt (#13)]
    ├── estimated rows: 2.00
    ├── Filter
    │   ├── output columns: [t.a (#4), COUNT(*) (#7)]
    │   ├── filters: [is_true(c1.a (#4) = 1)]
    │   ├── estimated rows: 1.00
    │   └── MaterializeCTERef
    │       ├── cte_name: cte1
    │       ├── cte_schema: [a (#4), COUNT(*) (#7)]
    │       └── estimated rows: 3.00
    └── Filter
        ├── output columns: [t.a (#8), COUNT(*) (#11)]
        ├── filters: [is_true(c2.a (#8) = 2)]
        ├── estimated rows: 1.00
        └── MaterializeCTERef
            ├── cte_name: cte1
            ├── cte_schema: [a (#8), COUNT(*) (#11)]
            └── estimated rows: 3.00

# Test 6: Multiple CTE references with three different filters
# Should create complex OR condition in CTE definition
query T
explain with cte1 as materialized (
    select a, count(*) as cnt
    from t 
    group by a
)
select * from cte1 where a = 1
union all
select * from cte1 where a = 2
union all  
select * from cte1 where a = 3;
----
Sequence
├── MaterializedCTE: cte1
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#3), t.a (#0)]
│       ├── group by: [a]
│       ├── aggregate functions: [count()]
│       ├── estimated rows: 3.00
│       └── AggregatePartial
│           ├── group by: [a]
│           ├── aggregate functions: [count()]
│           ├── estimated rows: 3.00
│           └── Filter
│               ├── output columns: [t.a (#0)]
│               ├── filters: [is_true(((t.a (#0) = 1 OR t.a (#0) = 2) OR t.a (#0) = 3))]
│               ├── estimated rows: 3.52
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [is_true(((t.a (#0) = 1 OR t.a (#0) = 2) OR t.a (#0) = 3))], limit: NONE]
│                   └── estimated rows: 5.00
└── UnionAll
    ├── output columns: [a (#18), cnt (#19)]
    ├── estimated rows: 3.00
    ├── UnionAll
    │   ├── output columns: [a (#12), cnt (#13)]
    │   ├── estimated rows: 2.00
    │   ├── Filter
    │   │   ├── output columns: [t.a (#4), COUNT(*) (#7)]
    │   │   ├── filters: [is_true(cte1.a (#4) = 1)]
    │   │   ├── estimated rows: 1.00
    │   │   └── MaterializeCTERef
    │   │       ├── cte_name: cte1
    │   │       ├── cte_schema: [a (#4), COUNT(*) (#7)]
    │   │       └── estimated rows: 3.00
    │   └── Filter
    │       ├── output columns: [t.a (#8), COUNT(*) (#11)]
    │       ├── filters: [is_true(cte1.a (#8) = 2)]
    │       ├── estimated rows: 1.00
    │       └── MaterializeCTERef
    │           ├── cte_name: cte1
    │           ├── cte_schema: [a (#8), COUNT(*) (#11)]
    │           └── estimated rows: 3.00
    └── Filter
        ├── output columns: [t.a (#14), COUNT(*) (#17)]
        ├── filters: [is_true(cte1.a (#14) = 3)]
        ├── estimated rows: 1.00
        └── MaterializeCTERef
            ├── cte_name: cte1
            ├── cte_schema: [a (#14), COUNT(*) (#17)]
            └── estimated rows: 3.00

# Test 8: CTE with existing filter condition and additional pushdown filter
query T
explain with cte1 as materialized (
    select a, b from t where a > 0
)
select * from cte1 where a = 1 and b < 50;
----
Sequence
├── MaterializedCTE: cte1
│   └── Filter
│       ├── output columns: [t.a (#0), t.b (#1)]
│       ├── filters: [is_true(t.a (#0) > 0), is_true(t.a (#0) = 1), is_true(t.b (#1) < 50)]
│       ├── estimated rows: 1.67
│       └── TableScan
│           ├── table: default.default.t
│           ├── output columns: [a (#0), b (#1)]
│           ├── read rows: 5
│           ├── read size: < 1 KiB
│           ├── partitions total: 1
│           ├── partitions scanned: 1
│           ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│           ├── push downs: [filters: [and_filters(and_filters(t.a (#0) > 0, t.a (#0) = 1), t.b (#1) < 50)], limit: NONE]
│           └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#3), t.b (#4)]
    ├── filters: [is_true(cte1.a (#3) = 1), is_true(cte1.b (#4) < 50)]
    ├── estimated rows: 1.67
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#3), b (#4)]
        └── estimated rows: 5.00

# Test 9: CTE with aggregation and HAVING clause
query T
explain with cte1 as materialized (
    select a, count(*) as cnt, sum(b) as sum_b
    from t 
    group by a
    having count(*) > 0
)
select * from cte1 where a > 1;
----
Sequence
├── MaterializedCTE: cte1
│   └── Filter
│       ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│       ├── filters: [COUNT(*) (#3) > 0]
│       ├── estimated rows: 0.00
│       └── AggregateFinal
│           ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│           ├── group by: [a]
│           ├── aggregate functions: [count(), sum(b)]
│           ├── estimated rows: 2.00
│           └── AggregatePartial
│               ├── group by: [a]
│               ├── aggregate functions: [count(), sum(b)]
│               ├── estimated rows: 2.00
│               └── Filter
│                   ├── output columns: [t.a (#0), t.b (#1)]
│                   ├── filters: [is_true(t.a (#0) > 1)]
│                   ├── estimated rows: 3.33
│                   └── TableScan
│                       ├── table: default.default.t
│                       ├── output columns: [a (#0), b (#1)]
│                       ├── read rows: 5
│                       ├── read size: < 1 KiB
│                       ├── partitions total: 1
│                       ├── partitions scanned: 1
│                       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│                       ├── push downs: [filters: [is_true(t.a (#0) > 1)], limit: NONE]
│                       └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#5), COUNT(*) (#8), sum(b) (#9)]
    ├── filters: [is_true(cte1.a (#5) > 1)]
    ├── estimated rows: 0.00
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#5), COUNT(*) (#8), sum(b) (#9)]
        └── estimated rows: 0.00

# Test 10: Complex aggregation with multiple GROUP BY columns
query T
explain with cte1 as materialized (
    select a, b, count(*) as cnt
    from t 
    group by a, b
)
select * from cte1 where a = 1 and b > 15;
----
Sequence
├── MaterializedCTE: cte1
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#3), t.a (#0), t.b (#1)]
│       ├── group by: [a, b]
│       ├── aggregate functions: [count()]
│       ├── estimated rows: 1.67
│       └── AggregatePartial
│           ├── group by: [a, b]
│           ├── aggregate functions: [count()]
│           ├── estimated rows: 1.67
│           └── Filter
│               ├── output columns: [t.a (#0), t.b (#1)]
│               ├── filters: [is_true(t.a (#0) = 1), is_true(t.b (#1) > 15)]
│               ├── estimated rows: 1.67
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0), b (#1)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [and_filters(t.a (#0) = 1, t.b (#1) > 15)], limit: NONE]
│                   └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#4), t.b (#5), COUNT(*) (#7)]
    ├── filters: [is_true(cte1.a (#4) = 1), is_true(cte1.b (#5) > 15)]
    ├── estimated rows: 1.67
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#4), b (#5), COUNT(*) (#7)]
        └── estimated rows: 5.00

# Test 11: Test case that demonstrates nested Filter issue
# This should show merged filters, not nested Filter nodes
query T
explain with cte1 as materialized (
    select a, count(*) as cnt, sum(b) as sum_b
    from t 
    group by a
)
select * from cte1 
where a = 1           -- Should be pushed down to before GROUP BY
and sum_b > 25;       -- Should remain after aggregation
----
Sequence
├── MaterializedCTE: cte1
│   └── Filter
│       ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│       ├── filters: [is_true(sum(b) (#4) > 25)]
│       ├── estimated rows: 0.00
│       └── AggregateFinal
│           ├── output columns: [COUNT(*) (#3), sum(b) (#4), t.a (#0)]
│           ├── group by: [a]
│           ├── aggregate functions: [count(), sum(b)]
│           ├── estimated rows: 1.00
│           └── AggregatePartial
│               ├── group by: [a]
│               ├── aggregate functions: [count(), sum(b)]
│               ├── estimated rows: 1.00
│               └── Filter
│                   ├── output columns: [t.a (#0), t.b (#1)]
│                   ├── filters: [is_true(t.a (#0) = 1)]
│                   ├── estimated rows: 1.67
│                   └── TableScan
│                       ├── table: default.default.t
│                       ├── output columns: [a (#0), b (#1)]
│                       ├── read rows: 5
│                       ├── read size: < 1 KiB
│                       ├── partitions total: 1
│                       ├── partitions scanned: 1
│                       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                       ├── push downs: [filters: [is_true(t.a (#0) = 1)], limit: NONE]
│                       └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#5), COUNT(*) (#8), sum(b) (#9)]
    ├── filters: [is_true(cte1.a (#5) = 1), is_true(cte1.sum_b (#9) > 25)]
    ├── estimated rows: 0.00
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#5), COUNT(*) (#8), sum(b) (#9)]
        └── estimated rows: 3.00

# Test 12: Test filter pushdown with IN clause
query T
explain with cte1 as materialized (
    select a, count(*) as cnt
    from t 
    group by a
)
select * from cte1 where a in (1, 2);
----
Sequence
├── MaterializedCTE: cte1
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#3), t.a (#0)]
│       ├── group by: [a]
│       ├── aggregate functions: [count()]
│       ├── estimated rows: 2.00
│       └── AggregatePartial
│           ├── group by: [a]
│           ├── aggregate functions: [count()]
│           ├── estimated rows: 2.00
│           └── Filter
│               ├── output columns: [t.a (#0)]
│               ├── filters: [is_true((t.a (#0) = 1 OR t.a (#0) = 2))]
│               ├── estimated rows: 2.78
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [is_true((t.a (#0) = 1 OR t.a (#0) = 2))], limit: NONE]
│                   └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#4), COUNT(*) (#7)]
    ├── filters: [is_true((cte1.a (#4) = 1 OR cte1.a (#4) = 2))]
    ├── estimated rows: 1.67
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#4), COUNT(*) (#7)]
        └── estimated rows: 3.00

# Test 13: Test filter pushdown with complex conditions
query T
explain with cte1 as materialized (
    select a, b, count(*) as cnt
    from t 
    group by a, b
)
select * from cte1 where (a = 1 or a = 2) and b > 10;
----
Sequence
├── MaterializedCTE: cte1
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#3), t.a (#0), t.b (#1)]
│       ├── group by: [a, b]
│       ├── aggregate functions: [count()]
│       ├── estimated rows: 2.78
│       └── AggregatePartial
│           ├── group by: [a, b]
│           ├── aggregate functions: [count()]
│           ├── estimated rows: 2.78
│           └── Filter
│               ├── output columns: [t.a (#0), t.b (#1)]
│               ├── filters: [is_true(t.b (#1) > 10), is_true((t.a (#0) = 1 OR t.a (#0) = 2))]
│               ├── estimated rows: 2.78
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0), b (#1)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [and_filters(t.b (#1) > 10, (t.a (#0) = 1 OR t.a (#0) = 2))], limit: NONE]
│                   └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#4), t.b (#5), COUNT(*) (#7)]
    ├── filters: [is_true(cte1.b (#5) > 10), is_true((cte1.a (#4) = 1 OR cte1.a (#4) = 2))]
    ├── estimated rows: 2.78
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#4), b (#5), COUNT(*) (#7)]
        └── estimated rows: 5.00

# Test 15: Test filter pushdown with subquery
query T
explain select * from (
    with cte1 as materialized (
        select a, count(*) as cnt from t group by a
    )
    select * from cte1 where a > 1
) where cnt > 0;
----
Filter
├── output columns: [t.a (#4), COUNT(*) (#7)]
├── filters: [cte1.cnt (#7) > 0]
├── estimated rows: 0.00
└── Sequence
    ├── MaterializedCTE: cte1
    │   └── AggregateFinal
    │       ├── output columns: [COUNT(*) (#3), t.a (#0)]
    │       ├── group by: [a]
    │       ├── aggregate functions: [count()]
    │       ├── estimated rows: 2.00
    │       └── AggregatePartial
    │           ├── group by: [a]
    │           ├── aggregate functions: [count()]
    │           ├── estimated rows: 2.00
    │           └── Filter
    │               ├── output columns: [t.a (#0)]
    │               ├── filters: [is_true(t.a (#0) > 1)]
    │               ├── estimated rows: 3.33
    │               └── TableScan
    │                   ├── table: default.default.t
    │                   ├── output columns: [a (#0)]
    │                   ├── read rows: 5
    │                   ├── read size: < 1 KiB
    │                   ├── partitions total: 1
    │                   ├── partitions scanned: 1
    │                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │                   ├── push downs: [filters: [is_true(t.a (#0) > 1)], limit: NONE]
    │                   └── estimated rows: 5.00
    └── Filter
        ├── output columns: [t.a (#4), COUNT(*) (#7)]
        ├── filters: [is_true(cte1.a (#4) > 1)]
        ├── estimated rows: 2.00
        └── MaterializeCTERef
            ├── cte_name: cte1
            ├── cte_schema: [a (#4), COUNT(*) (#7)]
            └── estimated rows: 3.00

# Test 17: CTE with window function
query T
explain with cte1 as materialized (
    select a, b, row_number() over (partition by a order by b) as rn
    from t
)
select * from cte1 where a = 1;
----
Sequence
├── MaterializedCTE: cte1
│   └── Window
│       ├── output columns: [t.a (#0), t.b (#1), row_number() OVER (PARTITION BY a ORDER BY b) (#3)]
│       ├── aggregate function: [row_number]
│       ├── partition by: [a]
│       ├── order by: [b]
│       ├── frame: [Range: Preceding(None) ~ CurrentRow]
│       └── WindowPartition
│           ├── output columns: [t.a (#0), t.b (#1)]
│           ├── hash keys: [a]
│           ├── estimated rows: 1.67
│           └── Filter
│               ├── output columns: [t.a (#0), t.b (#1)]
│               ├── filters: [is_true(t.a (#0) = 1)]
│               ├── estimated rows: 1.67
│               └── TableScan
│                   ├── table: default.default.t
│                   ├── output columns: [a (#0), b (#1)]
│                   ├── read rows: 5
│                   ├── read size: < 1 KiB
│                   ├── partitions total: 1
│                   ├── partitions scanned: 1
│                   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
│                   ├── push downs: [filters: [is_true(t.a (#0) = 1)], limit: NONE]
│                   └── estimated rows: 5.00
└── Filter
    ├── output columns: [t.a (#4), t.b (#5), row_number() OVER (PARTITION BY a ORDER BY b) (#7)]
    ├── filters: [is_true(cte1.a (#4) = 1)]
    ├── estimated rows: 1.67
    └── MaterializeCTERef
        ├── cte_name: cte1
        ├── cte_schema: [a (#4), b (#5), row_number() OVER (PARTITION BY a ORDER BY b) (#7)]
        └── estimated rows: 5.00

statement ok
drop table t;
