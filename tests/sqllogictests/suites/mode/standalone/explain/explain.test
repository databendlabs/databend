statement ok
drop table if exists t1 all

statement ok
drop table if exists t2 all

statement ok
settings (ddl_column_type_nullable=0) create OR REPLACE table t1 as select number as a, number as b from numbers(1)

statement ok
settings (ddl_column_type_nullable=0) create OR REPLACE table t2 as select number as a, number as b from numbers(5)

statement error 1005
explain explain select t1.a from t1 where a > 0

statement error 1005
explain explain analyze select t1.a from t1 where a > 0

statement error 1005
explain analyze explain select t1.a from t1 where a > 0

statement error 1005
explain analyze explain analyze select t1.a from t1 where a > 0

query T
explain select t1.a from t1 where a > 0
----
Filter
├── output columns: [t1.a (#0)]
├── filters: [t1.a (#0) > 0]
├── estimated rows: 0.00
└── TableScan
    ├── table: default.default.t1
    ├── output columns: [a (#0)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 1
    ├── partitions scanned: 0
    ├── pruning stats: [segments: <range pruning: 1 to 0>]
    ├── push downs: [filters: [t1.a (#0) > 0], limit: NONE]
    └── estimated rows: 1.00

query T
explain select * from t1, t2 where (t1.a = t2.a and t1.a > 3) or (t1.a = t2.a and t2.a > 5 and t1.a > 1)
----
Filter
├── output columns: [t2.a (#2), t2.b (#3), t1.b (#1), t1.a (#0)]
├── filters: [(t1.a (#0) > 3 OR (t2.a (#2) > 5 AND t1.a (#0) > 1))]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [t2.a (#2), t2.b (#3), t1.b (#1), t1.a (#0)]
    ├── join type: INNER
    ├── build keys: [t1.a (#0)]
    ├── probe keys: [t2.a (#2)]
    ├── keys is null equal: [false]
    ├── filters: []
    ├── build join filters:
    │   └── filter id:0, build key:t1.a (#0), probe key:t2.a (#2), filter type:bloom,inlist,min_max
    ├── estimated rows: 0.00
    ├── Filter(Build)
    │   ├── output columns: [t1.a (#0), t1.b (#1)]
    │   ├── filters: [(t1.a (#0) > 3 OR t1.a (#0) > 1)]
    │   ├── estimated rows: 0.00
    │   └── TableScan
    │       ├── table: default.default.t1
    │       ├── output columns: [a (#0), b (#1)]
    │       ├── read rows: 0
    │       ├── read size: 0
    │       ├── partitions total: 1
    │       ├── partitions scanned: 0
    │       ├── pruning stats: [segments: <range pruning: 1 to 0>]
    │       ├── push downs: [filters: [(t1.a (#0) > 3 OR t1.a (#0) > 1)], limit: NONE]
    │       └── estimated rows: 1.00
    └── Filter(Probe)
        ├── output columns: [t2.a (#2), t2.b (#3)]
        ├── filters: [(t2.a (#2) > 3 OR t2.a (#2) > 1)]
        ├── estimated rows: 3.40
        └── TableScan
            ├── table: default.default.t2
            ├── output columns: [a (#2), b (#3)]
            ├── read rows: 5
            ├── read size: < 1 KiB
            ├── partitions total: 1
            ├── partitions scanned: 1
            ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
            ├── push downs: [filters: [(t2.a (#2) > 3 OR t2.a (#2) > 1)], limit: NONE]
            ├── apply join filters: [#0]
            └── estimated rows: 5.00

query T
explain select * from t1, t2 where (t1.a = t2.a and t1.a > 3) or (t1.a = t2.a)
----
HashJoin
├── output columns: [t2.a (#2), t2.b (#3), t1.b (#1), t1.a (#0)]
├── join type: INNER
├── build keys: [t1.a (#0)]
├── probe keys: [t2.a (#2)]
├── keys is null equal: [false]
├── filters: []
├── build join filters:
│   └── filter id:0, build key:t1.a (#0), probe key:t2.a (#2), filter type:inlist,min_max
├── estimated rows: 1.00
├── TableScan(Build)
│   ├── table: default.default.t1
│   ├── output columns: [a (#0), b (#1)]
│   ├── read rows: 1
│   ├── read size: < 1 KiB
│   ├── partitions total: 1
│   ├── partitions scanned: 1
│   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   ├── push downs: [filters: [], limit: NONE]
│   └── estimated rows: 1.00
└── TableScan(Probe)
    ├── table: default.default.t2
    ├── output columns: [a (#2), b (#3)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    ├── apply join filters: [#0]
    └── estimated rows: 5.00

query T
explain raw select * from t1, t2 where (t1.a = t2.a and t1.a > 3) or (t1.a = t2.a)
----
EvalScalar
├── scalars: [t1.a (#0) AS (#0), t1.b (#1) AS (#1), t2.a (#2) AS (#2), t2.b (#3) AS (#3)]
└── Filter
    ├── filters: [or(and(eq(t1.a (#0), t2.a (#2)), gt(t1.a (#0), 3)), eq(t1.a (#0), t2.a (#2)))]
    └── Join(Cross)
        ├── build keys: []
        ├── probe keys: []
        ├── other filters: []
        ├── Scan
        │   ├── table: default.t1 (#0)
        │   ├── filters: []
        │   ├── order by: []
        │   └── limit: NONE
        └── Scan
            ├── table: default.t2 (#1)
            ├── filters: []
            ├── order by: []
            └── limit: NONE

query T
explain raw select * from t1 inner join t2 on t1.a = t2.a and t1.b = t2.b and t1.a > 2
----
EvalScalar
├── scalars: [t1.a (#0) AS (#0), t1.b (#1) AS (#1), t2.a (#2) AS (#2), t2.b (#3) AS (#3)]
└── Join(Inner)
    ├── build keys: [t2.a (#2), t2.b (#3)]
    ├── probe keys: [t1.a (#0), t1.b (#1)]
    ├── other filters: []
    ├── Filter
    │   ├── filters: [gt(t1.a (#0), 2)]
    │   └── Scan
    │       ├── table: default.t1 (#0)
    │       ├── filters: []
    │       ├── order by: []
    │       └── limit: NONE
    └── Scan
        ├── table: default.t2 (#1)
        ├── filters: []
        ├── order by: []
        └── limit: NONE

query T
explain syntax select 1, 'ab', [1,2,3], (1, 'a')
----
SELECT 1, 'ab', [1, 2, 3], (1, 'a')

query T
explain syntax select a, sum(b) as sum from t1 where a in (1, 2) and b > 0 and b < 100 group by a order by a
----
SELECT a, sum(b) AS sum FROM t1 WHERE a IN(1, 2) AND b > 0 AND b < 100 GROUP BY a ORDER BY a

query T
explain syntax select * from t1 inner join t2 on t1.a = t2.a and t1.b = t2.b and t1.a > 2
----
SELECT * FROM t1 INNER JOIN t2 ON t1.a = t2.a AND t1.b = t2.b AND t1.a > 2

query T
explain syntax delete from t1 where a > 100 and b > 1 and b < 10
----
DELETE FROM t1 WHERE a > 100 AND b > 1 AND b < 10


query T
explain syntax copy into t1 from 's3://mybucket/data.csv' file_format = ( type = CSV field_delimiter = ',' record_delimiter = '\n' skip_header = 1) size_limit=10
----
COPY INTO t1 FROM 's3://mybucket/data.csv' FILE_FORMAT = (field_delimiter = ',', record_delimiter = '\n', skip_header = 1, type = CSV)  SIZE_LIMIT = 10 PURGE = false FORCE = false DISABLE_VARIANT_CHECK = false ON_ERROR = abort RETURN_FAILED_ONLY = false


query T
explain syntax copy into 's3://mybucket/data.csv' from t1 file_format = ( type = CSV field_delimiter = ',' record_delimiter = '\n' skip_header = 1)
----
COPY INTO 's3://mybucket/data.csv' FROM t1 FILE_FORMAT = (field_delimiter = ',', record_delimiter = '\n', skip_header = 1, type = CSV) SINGLE = false MAX_FILE_SIZE = 0 DETAILED_OUTPUT = false INCLUDE_QUERY_ID = true USE_RAW_PATH = false OVERWRITE = false

query T
explain syntax create OR REPLACE table t3(a int64, b uint64, c float64, d string, e array(int32), f tuple(f1 bool, f2 string)) engine=fuse cluster by (a, b, c) comment='test' compression='LZ4'
----
CREATE OR REPLACE TABLE t3 (a Int64, b UInt64, c Float64, d STRING, e ARRAY(Int32), f TUPLE(f1 BOOLEAN, f2 STRING)) ENGINE = FUSE CLUSTER BY LINEAR(a, b, c) comment = 'test' compression = 'LZ4'

query T
explain syntax create view v as select number % 3 as a from numbers(100) where number > 10
----
CREATE VIEW v AS SELECT number % 3 AS a FROM numbers(100) WHERE number > 10

query T
explain syntax select 1, 'ab', [1,2,3] as a, (1, 'a') as t
----
SELECT 1, 'ab', [1, 2, 3] AS a, (1, 'a') AS t

query T
explain syntax select case when a > 1 then 'x' when a < 10 then 'y' else 'z' end from t1
----
SELECT CASE WHEN a > 1 THEN 'x' WHEN a < 10 THEN 'y' ELSE 'z' END FROM t1

query T
explain syntax select a, sum(b) as sum from t1 where a in (1, 2) and b > 0 and b < 100 group by a order by a limit 3
----
SELECT a, sum(b) AS sum FROM t1 WHERE a IN(1, 2) AND b > 0 AND b < 100 GROUP BY a ORDER BY a LIMIT 3

query T
explain syntax select * from t1 inner join t2 on t1.a = t2.a and t1.b = t2.b and t1.a > 2
----
SELECT * FROM t1 INNER JOIN t2 ON t1.a = t2.a AND t1.b = t2.b AND t1.a > 2

query T
explain syntax with cte (a, b) as (select 1, 2 union all select 3, 4) select a, b from cte
----
WITH cte(a, b) AS (SELECT 1, 2 UNION ALL SELECT 3, 4) SELECT a, b FROM cte

query T
explain syntax with cte (a, b) as (values(1,2),(3,4)) select a, b from cte
----
WITH cte(a, b) AS (VALUES(1, 2), (3, 4)) SELECT a, b FROM cte

query T
explain syntax insert into t1 (a, b) values (1, 2),(3, 4)
----
INSERT INTO t1 (a, b) VALUES (1, 2), (3, 4)

query T
explain syntax delete from t1 where a > 100 and b > 1 and b < 10
----
DELETE FROM t1 WHERE a > 100 AND b > 1 AND b < 10


query T
explain syntax copy into t1 from 's3://mybucket/data.csv' file_format = ( type = CSV field_delimiter = ',' record_delimiter = '\n' skip_header = 1) size_limit=10 max_files=10
----
COPY INTO t1 FROM 's3://mybucket/data.csv' FILE_FORMAT = (field_delimiter = ',', record_delimiter = '\n', skip_header = 1, type = CSV)  SIZE_LIMIT = 10 MAX_FILES = 10 PURGE = false FORCE = false DISABLE_VARIANT_CHECK = false ON_ERROR = abort RETURN_FAILED_ONLY = false

query T
explain syntax create database db1 engine=default
----
CREATE DATABASE db1 ENGINE = DEFAULT

query T
explain syntax create OR REPLACE table t3(a int64, b uint64, c float64, d string, e array(int32), f tuple(f1 bool, f2 string)) engine=fuse cluster by (a, b, c) comment='test' compression='LZ4'
----
CREATE OR REPLACE TABLE t3 (a Int64, b UInt64, c Float64, d STRING, e ARRAY(Int32), f TUPLE(f1 BOOLEAN, f2 STRING)) ENGINE = FUSE CLUSTER BY LINEAR(a, b, c) comment = 'test' compression = 'LZ4'

query T
explain syntax create view v as select number % 3 as a from numbers(100) where number > 10
----
CREATE VIEW v AS SELECT number % 3 AS a FROM numbers(100) WHERE number > 10

query T
explain syntax show create table t1
----
SHOW CREATE TABLE t1

query T
explain syntax create user 'test' identified with sha256_password by 'new_password'
----
CREATE USER 'test'@'%' IDENTIFIED WITH sha256_password BY 'new_password'

query T
explain syntax select unknown_table.a + 1 from unknown_table1
----
SELECT unknown_table.a + 1 FROM unknown_table1

query T
explain syntax SELECT * FROM monthly_sales PIVOT(SUM(amount) FOR MONTH IN ('JAN', 'FEB', 'MAR', 'APR')) ORDER BY EMPID
----
SELECT * FROM monthly_sales PIVOT(SUM(amount) FOR MONTH IN ('JAN', 'FEB', 'MAR', 'APR')) ORDER BY EMPID

query T
explain syntax SELECT * FROM monthly_sales_1 UNPIVOT(sales FOR month IN (jan, feb, mar, april)) ORDER BY empid
----
SELECT * FROM monthly_sales_1 UNPIVOT(sales FOR month IN (jan, feb, mar, april)) ORDER BY empid

query T
explain select a from t1 UNION ALL select a from t2
----
UnionAll
├── output columns: [a (#4)]
├── estimated rows: 6.00
├── TableScan
│   ├── table: default.default.t1
│   ├── output columns: [a (#0)]
│   ├── read rows: 1
│   ├── read size: < 1 KiB
│   ├── partitions total: 1
│   ├── partitions scanned: 1
│   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   ├── push downs: [filters: [], limit: NONE]
│   └── estimated rows: 1.00
└── TableScan
    ├── table: default.default.t2
    ├── output columns: [a (#2)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 5.00

query T
explain select * from t1,t2 where (t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4)
----
Filter
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── filters: [((t1.a (#0) > 1 AND t2.a (#2) > 2) OR (t1.b (#1) < 3 AND t2.b (#3) < 4))]
├── estimated rows: 3.52
└── HashJoin
    ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
    ├── join type: CROSS
    ├── build keys: []
    ├── probe keys: []
    ├── keys is null equal: []
    ├── filters: []
    ├── build join filters:
    ├── estimated rows: 4.40
    ├── Filter(Build)
    │   ├── output columns: [t1.a (#0), t1.b (#1)]
    │   ├── filters: [(t1.a (#0) > 1 OR t1.b (#1) < 3)]
    │   ├── estimated rows: 1.00
    │   └── TableScan
    │       ├── table: default.default.t1
    │       ├── output columns: [a (#0), b (#1)]
    │       ├── read rows: 1
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │       ├── push downs: [filters: [(t1.a (#0) > 1 OR t1.b (#1) < 3)], limit: NONE]
    │       └── estimated rows: 1.00
    └── Filter(Probe)
        ├── output columns: [t2.a (#2), t2.b (#3)]
        ├── filters: [(t2.a (#2) > 2 OR t2.b (#3) < 4)]
        ├── estimated rows: 4.40
        └── TableScan
            ├── table: default.default.t2
            ├── output columns: [a (#2), b (#3)]
            ├── read rows: 5
            ├── read size: < 1 KiB
            ├── partitions total: 1
            ├── partitions scanned: 1
            ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
            ├── push downs: [filters: [(t2.a (#2) > 2 OR t2.b (#3) < 4)], limit: NONE]
            └── estimated rows: 5.00

query T
explain select * from t1,t2 where (t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4) or t1.a = 2
----
Filter
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── filters: [(((t1.a (#0) > 1 AND t2.a (#2) > 2) OR (t1.b (#1) < 3 AND t2.b (#3) < 4)) OR t1.a (#0) = 2)]
├── estimated rows: 4.00
└── HashJoin
    ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
    ├── join type: CROSS
    ├── build keys: []
    ├── probe keys: []
    ├── keys is null equal: []
    ├── filters: []
    ├── build join filters:
    ├── estimated rows: 5.00
    ├── Filter(Build)
    │   ├── output columns: [t1.a (#0), t1.b (#1)]
    │   ├── filters: [((t1.a (#0) > 1 OR t1.b (#1) < 3) OR t1.a (#0) = 2)]
    │   ├── estimated rows: 1.00
    │   └── TableScan
    │       ├── table: default.default.t1
    │       ├── output columns: [a (#0), b (#1)]
    │       ├── read rows: 1
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
    │       ├── push downs: [filters: [((t1.a (#0) > 1 OR t1.b (#1) < 3) OR t1.a (#0) = 2)], limit: NONE]
    │       └── estimated rows: 1.00
    └── TableScan(Probe)
        ├── table: default.default.t2
        ├── output columns: [a (#2), b (#3)]
        ├── read rows: 5
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 5.00

statement ok
drop table if exists t3

statement ok
settings (ddl_column_type_nullable=0) create OR REPLACE table t3 as select number as a, number as b from numbers(10)

query T
explain select * from t1,t2, t3 where (t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4) or t3.a = 2
----
HashJoin
├── output columns: [t3.a (#4), t3.b (#5), t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── join type: INNER
├── build keys: []
├── probe keys: []
├── keys is null equal: []
├── filters: [(((t1.a (#0) > 1 AND t2.a (#2) > 2) OR (t1.b (#1) < 3 AND t2.b (#3) < 4)) OR t3.a (#4) = 2)]
├── build join filters:
├── estimated rows: 50.00
├── HashJoin(Build)
│   ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
│   ├── join type: CROSS
│   ├── build keys: []
│   ├── probe keys: []
│   ├── keys is null equal: []
│   ├── filters: []
│   ├── build join filters:
│   ├── estimated rows: 5.00
│   ├── TableScan(Build)
│   │   ├── table: default.default.t1
│   │   ├── output columns: [a (#0), b (#1)]
│   │   ├── read rows: 1
│   │   ├── read size: < 1 KiB
│   │   ├── partitions total: 1
│   │   ├── partitions scanned: 1
│   │   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   │   ├── push downs: [filters: [], limit: NONE]
│   │   └── estimated rows: 1.00
│   └── TableScan(Probe)
│       ├── table: default.default.t2
│       ├── output columns: [a (#2), b (#3)]
│       ├── read rows: 5
│       ├── read size: < 1 KiB
│       ├── partitions total: 1
│       ├── partitions scanned: 1
│       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       ├── push downs: [filters: [], limit: NONE]
│       └── estimated rows: 5.00
└── TableScan(Probe)
    ├── table: default.default.t3
    ├── output columns: [a (#4), b (#5)]
    ├── read rows: 10
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 10.00

query T
explain select * from t1,t2, t3 where ((t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4)) and t3.a > 1
----
HashJoin
├── output columns: [t3.a (#4), t3.b (#5), t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── join type: CROSS
├── build keys: []
├── probe keys: []
├── keys is null equal: []
├── filters: []
├── build join filters:
├── estimated rows: 28.16
├── Filter(Build)
│   ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
│   ├── filters: [((t1.a (#0) > 1 AND t2.a (#2) > 2) OR (t1.b (#1) < 3 AND t2.b (#3) < 4))]
│   ├── estimated rows: 3.52
│   └── HashJoin
│       ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
│       ├── join type: CROSS
│       ├── build keys: []
│       ├── probe keys: []
│       ├── keys is null equal: []
│       ├── filters: []
│       ├── build join filters:
│       ├── estimated rows: 4.40
│       ├── Filter(Build)
│       │   ├── output columns: [t1.a (#0), t1.b (#1)]
│       │   ├── filters: [(t1.a (#0) > 1 OR t1.b (#1) < 3)]
│       │   ├── estimated rows: 1.00
│       │   └── TableScan
│       │       ├── table: default.default.t1
│       │       ├── output columns: [a (#0), b (#1)]
│       │       ├── read rows: 1
│       │       ├── read size: < 1 KiB
│       │       ├── partitions total: 1
│       │       ├── partitions scanned: 1
│       │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       │       ├── push downs: [filters: [(t1.a (#0) > 1 OR t1.b (#1) < 3)], limit: NONE]
│       │       └── estimated rows: 1.00
│       └── Filter(Probe)
│           ├── output columns: [t2.a (#2), t2.b (#3)]
│           ├── filters: [(t2.a (#2) > 2 OR t2.b (#3) < 4)]
│           ├── estimated rows: 4.40
│           └── TableScan
│               ├── table: default.default.t2
│               ├── output columns: [a (#2), b (#3)]
│               ├── read rows: 5
│               ├── read size: < 1 KiB
│               ├── partitions total: 1
│               ├── partitions scanned: 1
│               ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│               ├── push downs: [filters: [(t2.a (#2) > 2 OR t2.b (#3) < 4)], limit: NONE]
│               └── estimated rows: 5.00
└── Filter(Probe)
    ├── output columns: [t3.a (#4), t3.b (#5)]
    ├── filters: [t3.a (#4) > 1]
    ├── estimated rows: 8.00
    └── TableScan
        ├── table: default.default.t3
        ├── output columns: [a (#4), b (#5)]
        ├── read rows: 10
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [t3.a (#4) > 1], limit: NONE]
        └── estimated rows: 10.00

query T
explain select * from t1,t2 where ((t1.a > 1 or t1.b < 2) and t2.a > 2) or (t1.b < 3 and t2.b < 4) order by 1 desc limit 3
----
Limit
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── limit: 3
├── offset: 0
├── estimated rows: 3.00
└── Sort
    ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
    ├── sort keys: [a DESC NULLS LAST]
    ├── estimated rows: 3.85
    └── Filter
        ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
        ├── filters: [(((t1.a (#0) > 1 OR t1.b (#1) < 2) AND t2.a (#2) > 2) OR (t1.b (#1) < 3 AND t2.b (#3) < 4))]
        ├── estimated rows: 3.85
        └── HashJoin
            ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
            ├── join type: CROSS
            ├── build keys: []
            ├── probe keys: []
            ├── keys is null equal: []
            ├── filters: []
            ├── build join filters:
            ├── estimated rows: 4.40
            ├── Filter(Build)
            │   ├── output columns: [t1.a (#0), t1.b (#1)]
            │   ├── filters: [((t1.a (#0) > 1 OR t1.b (#1) < 2) OR t1.b (#1) < 3)]
            │   ├── estimated rows: 1.00
            │   └── TableScan
            │       ├── table: default.default.t1
            │       ├── output columns: [a (#0), b (#1)]
            │       ├── read rows: 1
            │       ├── read size: < 1 KiB
            │       ├── partitions total: 1
            │       ├── partitions scanned: 1
            │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
            │       ├── push downs: [filters: [((t1.a (#0) > 1 OR t1.b (#1) < 2) OR t1.b (#1) < 3)], limit: NONE]
            │       └── estimated rows: 1.00
            └── Filter(Probe)
                ├── output columns: [t2.a (#2), t2.b (#3)]
                ├── filters: [(t2.a (#2) > 2 OR t2.b (#3) < 4)]
                ├── estimated rows: 4.40
                └── TableScan
                    ├── table: default.default.t2
                    ├── output columns: [a (#2), b (#3)]
                    ├── read rows: 5
                    ├── read size: < 1 KiB
                    ├── partitions total: 1
                    ├── partitions scanned: 1
                    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
                    ├── push downs: [filters: [(t2.a (#2) > 2 OR t2.b (#3) < 4)], limit: NONE]
                    └── estimated rows: 5.00

query
explain select * from t1,t2 where (t1.a > 1 or t1.b < 2) and (t1.a > 1 or t1.b < 2)
----
HashJoin
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── join type: CROSS
├── build keys: []
├── probe keys: []
├── keys is null equal: []
├── filters: []
├── build join filters:
├── estimated rows: 5.00
├── Filter(Build)
│   ├── output columns: [t1.a (#0), t1.b (#1)]
│   ├── filters: [(t1.a (#0) > 1 OR t1.b (#1) < 2)]
│   ├── estimated rows: 1.00
│   └── TableScan
│       ├── table: default.default.t1
│       ├── output columns: [a (#0), b (#1)]
│       ├── read rows: 1
│       ├── read size: < 1 KiB
│       ├── partitions total: 1
│       ├── partitions scanned: 1
│       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       ├── push downs: [filters: [(t1.a (#0) > 1 OR t1.b (#1) < 2)], limit: NONE]
│       └── estimated rows: 1.00
└── TableScan(Probe)
    ├── table: default.default.t2
    ├── output columns: [a (#2), b (#3)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 5.00

query
explain select count(distinct a) from t1;
----
AggregateFinal
├── output columns: [count(_1) (#2)]
├── group by: []
├── aggregate functions: [count()]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: []
    ├── aggregate functions: [count()]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [t1.a (#0)]
        ├── group by: [a]
        ├── aggregate functions: []
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [a]
            ├── aggregate functions: []
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.default.t1
                ├── output columns: [a (#0)]
                ├── read rows: 1
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
                ├── push downs: [filters: [], limit: NONE]
                └── estimated rows: 1.00

query
explain select count_distinct(a) from t1;
----
AggregateFinal
├── output columns: [count(_1) (#2)]
├── group by: []
├── aggregate functions: [count()]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: []
    ├── aggregate functions: [count()]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [t1.a (#0)]
        ├── group by: [a]
        ├── aggregate functions: []
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [a]
            ├── aggregate functions: []
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.default.t1
                ├── output columns: [a (#0)]
                ├── read rows: 1
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
                ├── push downs: [filters: [], limit: NONE]
                └── estimated rows: 1.00

query
explain select * from (values(1, 'a'),(2, 'b')) t(c1,c2)
----
ConstantTableScan
├── output columns: [c1 (#0), c2 (#1)]
├── column 0: [1, 2]
└── column 1: ['a', 'b']

statement ok
drop table t1

statement ok
drop table t2

query
explain syntax select * from read_parquet('p1', 'p2', 'p3');
----
SELECT * FROM read_parquet('p1', 'p2', 'p3')

query
explain syntax select * from read_parquet(prune_page=>true, refresh_meta_cache=>true);
----
SELECT * FROM read_parquet(prune_page=>TRUE,refresh_meta_cache=>TRUE)

query
explain syntax select * from read_parquet('p1', 'p2', 'p3', prune_page=>true, refresh_meta_cache=>true);
----
SELECT * FROM read_parquet('p1', 'p2', 'p3',prune_page=>TRUE,refresh_meta_cache=>TRUE)

query
explain syntax select * from read_parquet('p1', 'p2', 'p3', prune_page=>true, refresh_meta_cache=>true);
----
SELECT * FROM read_parquet('p1', 'p2', 'p3',prune_page=>TRUE,refresh_meta_cache=>TRUE)

statement ok
drop table if exists t4

statement ok
create OR REPLACE table t4(a int, b string);

query
explain select * from t4 where a = 1 and try_cast(get(try_parse_json(b),'bb') as varchar) = 'xx';
----
Filter
├── output columns: [t4.a (#0), t4.b (#1)]
├── filters: [is_true(t4.a (#0) = 1), is_true(TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')]
├── estimated rows: 0.00
└── TableScan
    ├── table: default.default.t4
    ├── output columns: [a (#0), b (#1)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 0
    ├── partitions scanned: 0
    ├── push downs: [filters: [and_filters(t4.a (#0) = 1, TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')], limit: NONE]
    └── estimated rows: 0.00

statement ok
drop view if exists v4

statement ok
create view v4 as select a as a, try_cast(get(try_parse_json(b), 'bb') as varchar) as b from t4;

query
explain select * from v4 where b = 'xx';
----
EvalScalar
├── output columns: [t4.a (#0), b (#2)]
├── expressions: [TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL)]
├── estimated rows: 0.00
└── Filter
    ├── output columns: [t4.a (#0), t4.b (#1)]
    ├── filters: [is_true(TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')]
    ├── estimated rows: 0.00
    └── TableScan
        ├── table: default.default.t4
        ├── output columns: [a (#0), b (#1)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [is_true(TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')], limit: NONE]
        └── estimated rows: 0.00

query T
explain select * from v4 where a > 100;
----
EvalScalar
├── output columns: [t4.a (#0), b (#2)]
├── expressions: [TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL)]
├── estimated rows: 0.00
└── Filter
    ├── output columns: [t4.a (#0), t4.b (#1)]
    ├── filters: [is_true(t4.a (#0) > 100)]
    ├── estimated rows: 0.00
    └── TableScan
        ├── table: default.default.t4
        ├── output columns: [a (#0), b (#1)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [is_true(t4.a (#0) > 100)], limit: NONE]
        └── estimated rows: 0.00

statement ok
drop table if exists a

statement ok
drop table if exists b

statement ok
create OR REPLACE table a(id int, c1 INT NULL)

statement ok
create OR REPLACE table b(id int, c1 INT NULL)

statement ok
insert into a values(1, 1683648000)

statement ok
insert into b values(1, 1683648000)

statement ok
insert into b values(2, 1683648000)

# left join to inner join
query T
explain select * from a left join b on a.id = b.id where a.c1 between 1683648000 and 1683734400 and b.c1 between 1683648000 and 1683734400 limit 1;
----
Limit
├── output columns: [b.id (#2), b.c1 (#3), a.c1 (#1), a.id (#0)]
├── limit: 1
├── offset: 0
├── estimated rows: 1.00
└── HashJoin
    ├── output columns: [b.id (#2), b.c1 (#3), a.c1 (#1), a.id (#0)]
    ├── join type: INNER
    ├── build keys: [a.id (#0)]
    ├── probe keys: [b.id (#2)]
    ├── keys is null equal: [false]
    ├── filters: []
    ├── build join filters:
    │   └── filter id:0, build key:a.id (#0), probe key:b.id (#2), filter type:inlist,min_max
    ├── estimated rows: 1.00
    ├── Filter(Build)
    │   ├── output columns: [a.id (#0), a.c1 (#1)]
    │   ├── filters: [is_true(a.c1 (#1) >= 1683648000), is_true(a.c1 (#1) <= 1683734400)]
    │   ├── estimated rows: 1.00
    │   └── TableScan
    │       ├── table: default.default.a
    │       ├── output columns: [id (#0), c1 (#1)]
    │       ├── read rows: 1
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │       ├── push downs: [filters: [and_filters(a.c1 (#1) >= 1683648000, a.c1 (#1) <= 1683734400)], limit: NONE]
    │       └── estimated rows: 1.00
    └── Filter(Probe)
        ├── output columns: [b.id (#2), b.c1 (#3)]
        ├── filters: [is_true(b.c1 (#3) >= 1683648000), is_true(b.c1 (#3) <= 1683734400)]
        ├── estimated rows: 2.00
        └── TableScan
            ├── table: default.default.b
            ├── output columns: [id (#2), c1 (#3)]
            ├── read rows: 2
            ├── read size: < 1 KiB
            ├── partitions total: 2
            ├── partitions scanned: 2
            ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2>]
            ├── push downs: [filters: [and_filters(b.c1 (#3) >= 1683648000, b.c1 (#3) <= 1683734400)], limit: NONE]
            ├── apply join filters: [#0]
            └── estimated rows: 2.00

statement ok
drop table a;

statement ok
drop table b;

# https://github.com/datafuselabs/databend/pull/12026
query T
explain select number, pt, register_at from (select a.number, pt,register_at from ( select number,  to_yyyymmdd(to_timestamp(number))   as pt
from numbers(10) where number > 5
) a join ( select number , to_yyyymmdd(to_timestamp(number)) as  register_at from numbers(10) where number > 5
) b on  a.number=b.number order by a.number) where pt = register_at;
----
Sort
├── output columns: [numbers.number (#0), pt (#1), register_at (#3)]
├── sort keys: [number ASC NULLS LAST]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [numbers.number (#0), pt (#1), register_at (#3)]
    ├── join type: INNER
    ├── build keys: [b.register_at (#3), numbers.number (#2)]
    ├── probe keys: [a.pt (#1), a.number (#0)]
    ├── keys is null equal: [false, false]
    ├── filters: []
    ├── build join filters:
    │   └── filter id:0, build key:numbers.number (#2), probe key:a.number (#0), filter type:inlist,min_max
    ├── estimated rows: 0.00
    ├── EvalScalar(Build)
    │   ├── output columns: [numbers.number (#2), register_at (#3)]
    │   ├── expressions: [to_yyyymmdd(CAST(numbers.number (#2) AS Timestamp))]
    │   ├── estimated rows: 0.00
    │   └── Filter
    │       ├── output columns: [numbers.number (#2)]
    │       ├── filters: [numbers.number (#2) > 5]
    │       ├── estimated rows: 0.00
    │       └── TableScan
    │           ├── table: default.system.numbers
    │           ├── output columns: [number (#2)]
    │           ├── read rows: 10
    │           ├── read size: < 1 KiB
    │           ├── partitions total: 1
    │           ├── partitions scanned: 1
    │           ├── push downs: [filters: [numbers.number (#2) > 5], limit: NONE]
    │           └── estimated rows: 10.00
    └── EvalScalar(Probe)
        ├── output columns: [numbers.number (#0), pt (#1)]
        ├── expressions: [to_yyyymmdd(CAST(numbers.number (#0) AS Timestamp))]
        ├── estimated rows: 0.00
        └── Filter
            ├── output columns: [numbers.number (#0)]
            ├── filters: [numbers.number (#0) > 5]
            ├── estimated rows: 0.00
            └── TableScan
                ├── table: default.system.numbers
                ├── output columns: [number (#0)]
                ├── read rows: 10
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── push downs: [filters: [numbers.number (#0) > 5], limit: NONE]
                ├── apply join filters: [#0]
                └── estimated rows: 10.00

statement ok
create OR REPLACE table a(id int, c1 INT NULL)

statement ok
create OR REPLACE table b(id int, c1 INT NULL)

statement ok
insert into a values (1, 2), (2, 4), (3, 6)

statement ok
insert into b values (1, 5), (4, 8)

# LEFT SINGLE JOIN
query T
explain select * from a where a.id = (select id from b where a.id = b.id);
----
HashJoin
├── output columns: [a.id (#0), a.c1 (#1)]
├── join type: INNER
├── build keys: [scalar_subquery_2 (#2), id (#2)]
├── probe keys: [a.id (#0), a.id (#0)]
├── keys is null equal: [false, false]
├── filters: []
├── build join filters:
│   ├── filter id:0, build key:scalar_subquery_2 (#2), probe key:a.id (#0), filter type:inlist,min_max
│   └── filter id:1, build key:id (#2), probe key:a.id (#0), filter type:inlist,min_max
├── estimated rows: 0.40
├── Filter(Build)
│   ├── output columns: [b.id (#2)]
│   ├── filters: [is_true(b.id (#2) = b.id (#2))]
│   ├── estimated rows: 0.40
│   └── TableScan
│       ├── table: default.default.b
│       ├── output columns: [id (#2)]
│       ├── read rows: 2
│       ├── read size: < 1 KiB
│       ├── partitions total: 1
│       ├── partitions scanned: 1
│       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       ├── push downs: [filters: [is_true(b.id (#2) = b.id (#2))], limit: NONE]
│       └── estimated rows: 2.00
└── TableScan(Probe)
    ├── table: default.default.a
    ├── output columns: [id (#0), c1 (#1)]
    ├── read rows: 3
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    ├── apply join filters: [#0, #1]
    └── estimated rows: 3.00

statement ok
drop table a;

statement ok
drop table b;

statement ok
create OR REPLACE table t1(a int, b int);

statement ok
insert into t1 values(1, 2), (2, 3), (3, 4);

query T
explain select * from t1 where a in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300);
----
HashJoin
├── output columns: [t1.a (#0), t1.b (#1)]
├── join type: INNER
├── build keys: [t1.a (#0)]
├── probe keys: [CAST(CAST(subquery_2 (#2) AS UInt16 NULL) AS Int32 NULL)]
├── keys is null equal: [false]
├── filters: []
├── build join filters:
├── estimated rows: 3.00
├── TableScan(Build)
│   ├── table: default.default.t1
│   ├── output columns: [a (#0), b (#1)]
│   ├── read rows: 3
│   ├── read size: < 1 KiB
│   ├── partitions total: 1
│   ├── partitions scanned: 1
│   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   ├── push downs: [filters: [], limit: NONE]
│   └── estimated rows: 3.00
└── AggregateFinal(Probe)
    ├── output columns: [col0 (#2)]
    ├── group by: [col0]
    ├── aggregate functions: []
    ├── estimated rows: 1297.00
    └── AggregatePartial
        ├── group by: [col0]
        ├── aggregate functions: []
        ├── estimated rows: 1297.00
        └── ConstantTableScan
            ├── output columns: [col0 (#2)]
            └── column 0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300]

query T
explain select * from t1 where a not in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300);
----
Filter
├── output columns: [t1.a (#0), t1.b (#1)]
├── filters: [is_true(NOT 3 (#3))]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [t1.a (#0), t1.b (#1), marker (#3)]
    ├── join type: LEFT MARK
    ├── build keys: [t1.a (#0)]
    ├── probe keys: [CAST(CAST(subquery_2 (#2) AS UInt16 NULL) AS Int32 NULL)]
    ├── keys is null equal: [true]
    ├── filters: []
    ├── build join filters:
    ├── estimated rows: 3.00
    ├── TableScan(Build)
    │   ├── table: default.default.t1
    │   ├── output columns: [a (#0), b (#1)]
    │   ├── read rows: 3
    │   ├── read size: < 1 KiB
    │   ├── partitions total: 1
    │   ├── partitions scanned: 1
    │   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │   ├── push downs: [filters: [], limit: NONE]
    │   └── estimated rows: 3.00
    └── AggregateFinal(Probe)
        ├── output columns: [col0 (#2)]
        ├── group by: [col0]
        ├── aggregate functions: []
        ├── estimated rows: 1297.00
        └── AggregatePartial
            ├── group by: [col0]
            ├── aggregate functions: []
            ├── estimated rows: 1297.00
            └── ConstantTableScan
                ├── output columns: [col0 (#2)]
                └── column 0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300]

statement ok
drop table t1;

statement ok
drop table if exists t1;

statement ok
drop table if exists t2;

statement ok
CREATE OR REPLACE TABLE t1(i int, j int);

statement ok
CREATE OR REPLACE TABLE t2(k int, l int);

statement ok
INSERT INTO t1 VALUES (1, 2), (2, 3), (3, 4);

statement ok
INSERT INTO t2 VALUES (1, 10), (2, 20);

query T
EXPLAIN SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE AND t1.i = t2.k AND FALSE order by i, j;
----
Sort
├── output columns: [t1.i (#0), t1.j (#1), t2.k (#2), t2.l (#3)]
├── sort keys: [i ASC NULLS LAST, j ASC NULLS LAST]
├── estimated rows: 3.00
└── HashJoin
    ├── output columns: [t1.i (#0), t1.j (#1), t2.k (#2), t2.l (#3)]
    ├── join type: LEFT OUTER
    ├── build keys: [t2.k (#2)]
    ├── probe keys: [t1.i (#0)]
    ├── keys is null equal: [false]
    ├── filters: []
    ├── build join filters:
    ├── estimated rows: 3.00
    ├── EmptyResultScan(Build)
    └── TableScan(Probe)
        ├── table: default.default.t1
        ├── output columns: [i (#0), j (#1)]
        ├── read rows: 3
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 3.00

query T
EXPLAIN optimized SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE AND t1.i = t2.k AND FALSE order by i, j;
----
Sort
├── sort keys: [default.t1.i (#0) ASC NULLS LAST, default.t1.j (#1) ASC NULLS LAST]
├── limit: [NONE]
└── Join(Left)
    ├── build keys: [t2.k (#2)]
    ├── probe keys: [t1.i (#0)]
    ├── other filters: []
    ├── Scan
    │   ├── table: default.t1 (#0)
    │   ├── filters: []
    │   ├── order by: []
    │   └── limit: NONE
    └── EmptyResultScan


statement ok
drop table if exists t3;

statement ok
CREATE OR REPLACE TABLE t3(a int, b map(string, string) null, c map(string, variant) null);

statement ok
INSERT INTO t3 VALUES (1, {'k1':'a', 'k2':'b'}, {'k1':'"a"', 'k2':'100'}), (2, null, null), (3, {'k3':'z'}, {'k3':'"z"'});

statement ok
INSERT INTO t3 VALUES (4, {'k1':'a', 'k2':'m'}, {'k1':'"a"', 'k2':'"m"'}), (5, null, null), (6, {'k3':'z'}, {'k3':'"v"'});

query T
EXPLAIN SELECT * FROM t3 WHERE b['k2'] = 'm';
----
Filter
├── output columns: [t3.a (#0), t3.b (#1), t3.c (#2)]
├── filters: [is_true(get(t3.b (#1), 'k2') = 'm')]
├── estimated rows: 1.20
└── TableScan
    ├── table: default.default.t3
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 3
    ├── read size: < 1 KiB
    ├── partitions total: 2
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2, bloom pruning: 2 to 1>]
    ├── push downs: [filters: [is_true(get(t3.b (#1), 'k2') = 'm')], limit: NONE]
    └── estimated rows: 6.00

query T
EXPLAIN SELECT * FROM t3 WHERE c['k3'] = 'v';
----
Filter
├── output columns: [t3.a (#0), t3.b (#1), t3.c (#2)]
├── filters: [is_true(get(t3.c (#2), 'k3') = '"v"')]
├── estimated rows: 1.20
└── TableScan
    ├── table: default.default.t3
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 3
    ├── read size: < 1 KiB
    ├── partitions total: 2
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2, bloom pruning: 2 to 1>]
    ├── push downs: [filters: [is_true(get(t3.c (#2), 'k3') = '"v"')], limit: NONE]
    └── estimated rows: 6.00

query T
EXPLAIN SELECT * FROM t3 WHERE c['k2'] = 100;
----
Filter
├── output columns: [t3.a (#0), t3.b (#1), t3.c (#2)]
├── filters: [is_true(TRY_CAST(get(t3.c (#2), 'k2') AS UInt8 NULL) = 100)]
├── estimated rows: 1.20
└── TableScan
    ├── table: default.default.t3
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 6
    ├── read size: < 1 KiB
    ├── partitions total: 2
    ├── partitions scanned: 2
    ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2>]
    ├── push downs: [filters: [is_true(TRY_CAST(get(t3.c (#2), 'k2') AS UInt8 NULL) = 100)], limit: NONE]
    └── estimated rows: 6.00

statement ok
drop table t1;

statement ok
drop table t2;

statement ok
drop table t3;

statement ok
CREATE OR REPLACE TABLE customers AS SELECT
  number % 100 AS customer_id,
  concat('Customer ', to_string(number % 100)) AS customer_name,
  CASE WHEN (rand() * 10000)::int % 3 = 0 THEN 'Small'
       WHEN (rand() * 10000 % 3)::int = 1 THEN 'Medium'
       ELSE 'Large'
  END AS segment,
  date_add('year', floor(rand() * 100 % 5)::int, '2021-01-01') AS create_timestamp,
  (rand() * 100)::int % 2 = 0 AS active
FROM numbers(100);


statement ok
CREATE OR REPLACE TABLE products AS SELECT
  number % 10 AS product_id,
  concat('Product ', to_string(number % 10)) AS product_name,
  (rand() * 10000 % 2000 * 0.01)::decimal(10, 2) AS price,
  CASE WHEN (rand() * 100)::int % 4 = 0 THEN 'Electronics'
       WHEN (rand() * 100 % 4)::int = 1 THEN 'Clothing'
       WHEN (rand() * 1000 % 4)::int = 2 THEN 'Grocery'
       ELSE 'Furniture'
  END AS category
FROM numbers(10);

statement ok
CREATE OR REPLACE TABLE sales AS SELECT
  number % 500 AS sale_id,
  number % 100 AS product_id,
  number % 100 AS customer_id,
  date_add('day', floor(rand() * 10000 % 365)::int, '2021-01-01') AS sale_date,
  (rand() * 10000 % 20 + 1)::int AS quantity,
  (rand() * 10000 % 2000 * 0.01)::decimal(10, 2) AS net_paid
FROM numbers(500);

query T
explain join SELECT customer_name, segment, (SELECT SUM(net_paid) FROM sales WHERE customer_id IN (SELECT customer_id FROM customers WHERE segment = c.segment AND active = true)) FROM customers c WHERE c.customer_id IN (SELECT customer_id FROM sales WHERE net_paid > 100) LIMIT 10;
----
HashJoin: RIGHT OUTER
├── Build
│   └── HashJoin: LEFT SEMI
│       ├── Build
│       │   └── Scan: default.default.sales (#3) (read rows: 0)
│       └── Probe
│           └── Scan: default.default.customers (#0) (read rows: 100)
└── Probe
    └── HashJoin: LEFT SEMI
        ├── Build
        │   └── Scan: default.default.customers (#2) (read rows: 100)
        └── Probe
            └── HashJoin: CROSS
                ├── Build
                │   └── HashJoin: LEFT SEMI
                │       ├── Build
                │       │   └── Scan: default.default.sales (#3) (read rows: 500)
                │       └── Probe
                │           └── Scan: default.default.customers (#0) (read rows: 100)
                └── Probe
                    └── Scan: default.default.sales (#1) (read rows: 500)


query T
explain join SELECT c.customer_name FROM customers c WHERE NOT EXISTS ( SELECT category FROM products WHERE category NOT IN ( SELECT p.category FROM sales s JOIN products p ON s.product_id = p.product_id WHERE s.customer_id = c.customer_id ) ) ORDER BY c.customer_name;
----
HashJoin: RIGHT MARK
├── Build
│   └── HashJoin: RIGHT MARK
│       ├── Build
│       │   └── HashJoin: INNER
│       │       ├── Build
│       │       │   └── Scan: default.default.products (#3) (read rows: 10)
│       │       └── Probe
│       │           └── Scan: default.default.sales (#2) (read rows: 500)
│       └── Probe
│           └── HashJoin: CROSS
│               ├── Build
│               │   └── Scan: default.default.products (#1) (read rows: 10)
│               └── Probe
│                   └── Scan: default.default.customers (#0) (read rows: 100)
└── Probe
    └── Scan: default.default.customers (#0) (read rows: 100)

statement ok
drop table customers;

statement ok
drop table products;

statement ok
drop table sales;

statement ok
create OR REPLACE table t1 (a int);

statement ok
create OR REPLACE table t2 (b int);

query T
explain select date from (select *, 'year' as date from t1 left join t2 on t1.a = t2.b) where date = '';
----
EvalScalar
├── output columns: [date (#2)]
├── expressions: ['year']
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: []
    ├── join type: LEFT OUTER
    ├── build keys: [t2.b (#1)]
    ├── probe keys: [t1.a (#0)]
    ├── keys is null equal: [false]
    ├── filters: []
    ├── build join filters:
    ├── estimated rows: 0.00
    ├── Filter(Build)
    │   ├── output columns: [t2.b (#1)]
    │   ├── filters: [false]
    │   ├── estimated rows: 0.00
    │   └── TableScan
    │       ├── table: default.default.t2
    │       ├── output columns: [b (#1)]
    │       ├── read rows: 0
    │       ├── read size: 0
    │       ├── partitions total: 0
    │       ├── partitions scanned: 0
    │       ├── push downs: [filters: [false], limit: NONE]
    │       └── estimated rows: 0.00
    └── Filter(Probe)
        ├── output columns: [t1.a (#0)]
        ├── filters: [false]
        ├── estimated rows: 0.00
        └── TableScan
            ├── table: default.default.t1
            ├── output columns: [a (#0)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [false], limit: NONE]
            └── estimated rows: 0.00


statement ok
drop table t1;

statement ok
drop table t2;

statement ok
create OR REPLACE table t1(a int, b int, c varchar(20));

statement ok
create OR REPLACE table t2(a int, b int, c varchar(20));

# scalar subquery and sort plan contains count() agg function.
query T
explain select * from t2 where c > (select c from t1 where t1.a = t2.a group by c order by count(a));
----
HashJoin
├── output columns: [t2.a (#0), t2.b (#1), t2.c (#2)]
├── join type: INNER
├── build keys: [a (#3)]
├── probe keys: [a (#0)]
├── keys is null equal: [false]
├── filters: [t2.c (#2) > scalar_subquery_5 (#5)]
├── build join filters:
│   └── filter id:0, build key:a (#3), probe key:a (#0), filter type:bloom,inlist,min_max
├── estimated rows: 0.00
├── Sort(Build)
│   ├── output columns: [count(a) (#6), t1.c (#5), t1.a (#3)]
│   ├── sort keys: [count(a) ASC NULLS LAST]
│   ├── estimated rows: 0.00
│   └── AggregateFinal
│       ├── output columns: [count(a) (#6), t1.c (#5), t1.a (#3)]
│       ├── group by: [c, a]
│       ├── aggregate functions: [count(a)]
│       ├── estimated rows: 0.00
│       └── AggregatePartial
│           ├── group by: [c, a]
│           ├── aggregate functions: [count(a)]
│           ├── estimated rows: 0.00
│           └── Filter
│               ├── output columns: [t1.a (#3), t1.c (#5)]
│               ├── filters: [is_true(t1.a (#3) = t1.a (#3))]
│               ├── estimated rows: 0.00
│               └── TableScan
│                   ├── table: default.default.t1
│                   ├── output columns: [a (#3), c (#5)]
│                   ├── read rows: 0
│                   ├── read size: 0
│                   ├── partitions total: 0
│                   ├── partitions scanned: 0
│                   ├── push downs: [filters: [is_true(t1.a (#3) = t1.a (#3))], limit: NONE]
│                   └── estimated rows: 0.00
└── TableScan(Probe)
    ├── table: default.default.t2
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 0
    ├── partitions scanned: 0
    ├── push downs: [filters: [], limit: NONE]
    ├── apply join filters: [#0]
    └── estimated rows: 0.00

query T
explain select * from t2 where c > (select c from t1 where t1.a = t2.a group by c order by count(*));
----
HashJoin
├── output columns: [t2.a (#0), t2.b (#1), t2.c (#2)]
├── join type: INNER
├── build keys: [a (#3)]
├── probe keys: [a (#0)]
├── keys is null equal: [false]
├── filters: [t2.c (#2) > scalar_subquery_5 (#5)]
├── build join filters:
│   └── filter id:0, build key:a (#3), probe key:a (#0), filter type:bloom,inlist,min_max
├── estimated rows: 0.00
├── Sort(Build)
│   ├── output columns: [COUNT(*) (#6), t1.c (#5), t1.a (#3)]
│   ├── sort keys: [COUNT(*) ASC NULLS LAST]
│   ├── estimated rows: 0.00
│   └── AggregateFinal
│       ├── output columns: [COUNT(*) (#6), t1.c (#5), t1.a (#3)]
│       ├── group by: [c, a]
│       ├── aggregate functions: [count()]
│       ├── estimated rows: 0.00
│       └── AggregatePartial
│           ├── group by: [c, a]
│           ├── aggregate functions: [count()]
│           ├── estimated rows: 0.00
│           └── Filter
│               ├── output columns: [t1.a (#3), t1.c (#5)]
│               ├── filters: [is_true(outer.a (#3) = outer.a (#3))]
│               ├── estimated rows: 0.00
│               └── TableScan
│                   ├── table: default.default.t1
│                   ├── output columns: [a (#3), c (#5)]
│                   ├── read rows: 0
│                   ├── read size: 0
│                   ├── partitions total: 0
│                   ├── partitions scanned: 0
│                   ├── push downs: [filters: [is_true(t1.a (#3) = t1.a (#3))], limit: NONE]
│                   └── estimated rows: 0.00
└── TableScan(Probe)
    ├── table: default.default.t2
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 0
    ├── partitions scanned: 0
    ├── push downs: [filters: [], limit: NONE]
    ├── apply join filters: [#0]
    └── estimated rows: 0.00

query T
explain insert into t2 select * from t1;
----
InsertPlan (subquery):
├── table: default.default.t2
├── inserted columns: [t2.a (#0),t2.b (#1),t2.c (#2)]
├── overwrite: false
└── Scan
    ├── table: default.t1 (#0)
    ├── filters: []
    ├── order by: []
    └── limit: NONE


statement ok
drop table t1;

statement ok
drop table t2;

query T
explain select * from numbers(0);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 0
├── read size: 0
├── partitions total: 1
├── partitions scanned: 1
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 0.00

query T
explain select * from numbers(10);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10
├── read size: < 1 KiB
├── partitions total: 1
├── partitions scanned: 1
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10.00

query T
explain select * from numbers(10000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000
├── read size: 78.12 KiB
├── partitions total: 1
├── partitions scanned: 1
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000.00

query T
explain select * from numbers(10000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000
├── read size: 76.29 MiB
├── partitions total: 153
├── partitions scanned: 153
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000.00

query T
explain select * from numbers(10000000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000000
├── read size: 74.51 GiB
├── partitions total: 152588
├── partitions scanned: 152588
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000000.00

query T
explain select * from numbers(10000000000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000000000
├── read size: 72.76 TiB
├── partitions total: 152587891
├── partitions scanned: 152587891
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000000000.00

query T
explain select * from numbers(10000000000000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000000000000
├── read size: 71.05 PiB
├── partitions total: 152587890626
├── partitions scanned: 152587890626
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000000000000.00



statement ok
CREATE OR REPLACE TABLE orders_placed (order_id INT, customer_id INT, order_amount FLOAT, order_date DATE);

query T
EXPLAIN syntax
INSERT FIRST
WHEN order_amount > 1000 THEN INTO cat.db1.t1(order_id, update_note) VALUES (order_id, 'PriorityHandling')
WHEN order_amount > 500 THEN INTO cat2.db2.t2 VALUES (order_id, 'ExpressHandling')
WHEN order_amount > 100 THEN
   INTO cat3.db3.t3 VALUES (order_id, 'StandardHandling')
   INTO cat3.db3.t4 VALUES (order_id, 'StandardHandling')
ELSE INTO processing_updates VALUES (order_id, 'ReviewNeeded')
SELECT order_id, order_amount FROM orders_placed;
----
INSERT FIRST WHEN order_amount > 1000 THEN INTO cat.db1.t1 (order_id, update_note) VALUES  (order_id, 'PriorityHandling')  WHEN order_amount > 500 THEN INTO cat2.db2.t2 VALUES  (order_id, 'ExpressHandling')  WHEN order_amount > 100 THEN INTO cat3.db3.t3 VALUES  (order_id, 'StandardHandling') INTO cat3.db3.t4 VALUES  (order_id, 'StandardHandling')  ELSE INTO processing_updates VALUES  (order_id, 'ReviewNeeded')  SELECT order_id, order_amount FROM orders_placed

query T
EXPLAIN syntax
INSERT ALL
   INTO cat.db1.t1 VALUES (order_id, 'PriorityHandling')
   INTO cat3.db3.t3 VALUES (order_id, 'StandardHandling')
   INTO cat3.db3.t4 VALUES (order_id, 'StandardHandling')
SELECT order_id, order_amount FROM orders_placed;
----
INSERT ALL INTO cat.db1.t1 VALUES  (order_id, 'PriorityHandling') INTO cat3.db3.t3 VALUES  (order_id, 'StandardHandling') INTO cat3.db3.t4 VALUES  (order_id, 'StandardHandling') SELECT order_id, order_amount FROM orders_placed

query T
EXPLAIN syntax
INSERT OVERWRITE ALL
   INTO cat.db1.t1 VALUES (order_id, 'PriorityHandling')
   INTO cat3.db3.t3 VALUES (order_id, 'StandardHandling')
   INTO cat3.db3.t4 VALUES (order_id, 'StandardHandling')
SELECT order_id, order_amount FROM orders_placed;
----
INSERT OVERWRITE ALL INTO cat.db1.t1 VALUES  (order_id, 'PriorityHandling') INTO cat3.db3.t3 VALUES  (order_id, 'StandardHandling') INTO cat3.db3.t4 VALUES  (order_id, 'StandardHandling') SELECT order_id, order_amount FROM orders_placed

statement ok
drop table  orders_placed

# Test Tuple Statistics
statement ok
CREATE OR REPLACE TABLE t(a TUPLE(INT, INT));

statement ok
INSERT INTO t VALUES((1, 2)), ((3, 4));

query T
EXPLAIN SELECT * FROM t WHERE a.1 > 0;
----
Filter
├── output columns: [t.a (#0)]
├── filters: [is_true(t.a:"1" (#2) > 0)]
├── estimated rows: 2.00
└── TableScan
    ├── table: default.default.t
    ├── output columns: [a (#0), a:"1" (#2)]
    ├── read rows: 2
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [is_true(t.a:"1" (#2) > 0)], limit: NONE]
    └── estimated rows: 2.00

query T
EXPLAIN SELECT * FROM t WHERE a.1 > 1;
----
Filter
├── output columns: [t.a (#0)]
├── filters: [is_true(t.a:"1" (#2) > 1)]
├── estimated rows: 1.00
└── TableScan
    ├── table: default.default.t
    ├── output columns: [a (#0), a:"1" (#2)]
    ├── read rows: 2
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [is_true(t.a:"1" (#2) > 1)], limit: NONE]
    └── estimated rows: 2.00

query T
EXPLAIN SELECT * FROM t WHERE a.2 > 1;
----
Filter
├── output columns: [t.a (#0)]
├── filters: [is_true(t.a:"2" (#1) > 1)]
├── estimated rows: 2.00
└── TableScan
    ├── table: default.default.t
    ├── output columns: [a (#0), a:"2" (#1)]
    ├── read rows: 2
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [is_true(t.a:"2" (#1) > 1)], limit: NONE]
    └── estimated rows: 2.00

statement ok
DROP TABLE IF EXISTS t;
