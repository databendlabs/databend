statement ok
drop table if exists t1 all

statement ok
drop table if exists t2 all

statement ok
create table t1 as select number as a, number as b from numbers(1)

statement ok
create table t2 as select number as a, number as b from numbers(5)

query T
explain select t1.a from t1 where a > 0
----
Filter
├── output columns: [t1.a (#0)]
├── filters: [t1.a (#0) > 0]
├── estimated rows: 0.20
└── TableScan
    ├── table: default.default.t1
    ├── output columns: [a (#0)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 1
    ├── partitions scanned: 0
    ├── pruning stats: [segments: <range pruning: 1 to 0>]
    ├── push downs: [filters: [t1.a (#0) > 0], limit: NONE]
    └── estimated rows: 1.00

query T
explain select * from t1, t2 where (t1.a = t2.a and t1.a > 3) or (t1.a = t2.a and t2.a > 5 and t1.a > 1)
----
Filter
├── output columns: [t2.a (#2), t2.b (#3), t1.b (#1), t1.a (#0)]
├── filters: [t1.a (#0) > 3 OR t2.a (#2) > 5 AND t1.a (#0) > 1]
├── estimated rows: 0.13
└── HashJoin
    ├── output columns: [t2.a (#2), t2.b (#3), t1.b (#1), t1.a (#0)]
    ├── join type: INNER
    ├── build keys: [t1.a (#0)]
    ├── probe keys: [t2.a (#2)]
    ├── filters: []
    ├── estimated rows: 0.35
    ├── Filter(Build)
    │   ├── output columns: [t1.a (#0), t1.b (#1)]
    │   ├── filters: [t1.a (#0) > 3 OR t1.a (#0) > 1]
    │   ├── estimated rows: 0.36
    │   └── TableScan
    │       ├── table: default.default.t1
    │       ├── output columns: [a (#0), b (#1)]
    │       ├── read rows: 0
    │       ├── read size: 0
    │       ├── partitions total: 1
    │       ├── partitions scanned: 0
    │       ├── pruning stats: [segments: <range pruning: 1 to 0>]
    │       ├── push downs: [filters: [t1.a (#0) > 3 OR t1.a (#0) > 1], limit: NONE]
    │       └── estimated rows: 1.00
    └── Filter(Probe)
        ├── output columns: [t2.a (#2), t2.b (#3)]
        ├── filters: [t2.a (#2) > 3 OR t2.a (#2) > 1]
        ├── estimated rows: 3.89
        └── TableScan
            ├── table: default.default.t2
            ├── output columns: [a (#2), b (#3)]
            ├── read rows: 5
            ├── read size: < 1 KiB
            ├── partitions total: 1
            ├── partitions scanned: 1
            ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
            ├── push downs: [filters: [t2.a (#2) > 3 OR t2.a (#2) > 1], limit: NONE]
            └── estimated rows: 5.00

query T
explain select * from t1, t2 where (t1.a = t2.a and t1.a > 3) or (t1.a = t2.a)
----
HashJoin
├── output columns: [t2.a (#2), t2.b (#3), t1.b (#1), t1.a (#0)]
├── join type: INNER
├── build keys: [t1.a (#0)]
├── probe keys: [t2.a (#2)]
├── filters: []
├── estimated rows: 1.00
├── TableScan(Build)
│   ├── table: default.default.t1
│   ├── output columns: [a (#0), b (#1)]
│   ├── read rows: 1
│   ├── read size: < 1 KiB
│   ├── partitions total: 1
│   ├── partitions scanned: 1
│   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   ├── push downs: [filters: [], limit: NONE]
│   └── estimated rows: 1.00
└── TableScan(Probe)
    ├── table: default.default.t2
    ├── output columns: [a (#2), b (#3)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 5.00

query T
explain raw select * from t1, t2 where (t1.a = t2.a and t1.a > 3) or (t1.a = t2.a)
----
EvalScalar
├── scalars: [t1.a (#0) AS (#0), t1.b (#1) AS (#1), t2.a (#2) AS (#2), t2.b (#3) AS (#3)]
└── Filter
    ├── filters: [or(and(eq(t1.a (#0), t2.a (#2)), gt(t1.a (#0), 3)), eq(t1.a (#0), t2.a (#2)))]
    └── Join(Cross)
        ├── build keys: []
        ├── probe keys: []
        ├── other filters: []
        ├── Scan
        │   ├── table: default.t1
        │   ├── filters: []
        │   ├── order by: []
        │   └── limit: NONE
        └── Scan
            ├── table: default.t2
            ├── filters: []
            ├── order by: []
            └── limit: NONE

query T
explain raw select * from t1 inner join t2 on t1.a = t2.a and t1.b = t2.b and t1.a > 2
----
EvalScalar
├── scalars: [t1.a (#0) AS (#0), t1.b (#1) AS (#1), t2.a (#2) AS (#2), t2.b (#3) AS (#3)]
└── Join(Inner)
    ├── build keys: [t2.a (#2), t2.b (#3)]
    ├── probe keys: [t1.a (#0), t1.b (#1)]
    ├── other filters: []
    ├── Filter
    │   ├── filters: [gt(t1.a (#0), 2)]
    │   └── Scan
    │       ├── table: default.t1
    │       ├── filters: []
    │       ├── order by: []
    │       └── limit: NONE
    └── Scan
        ├── table: default.t2
        ├── filters: []
        ├── order by: []
        └── limit: NONE

query T
explain syntax select 1, 'ab', [1,2,3], (1, 'a')
----
SELECT
    1,
    'ab',
    [1, 2, 3],
    (1, 'a')

query T
explain syntax select a, sum(b) as sum from t1 where a in (1, 2) and b > 0 and b < 100 group by a order by a
----
SELECT
    a,
    sum(b) AS sum
FROM
    t1
WHERE
    (
        (
            a IN (1, 2)
            AND (b > 0)
        )
        AND (b < 100)
    )
GROUP BY a
ORDER BY a

query T
explain syntax select * from t1 inner join t2 on t1.a = t2.a and t1.b = t2.b and t1.a > 2
----
SELECT *
FROM
    t1
    INNER JOIN t2 ON (
        (
            (t1.a = t2.a)
            AND (t1.b = t2.b)
        )
        AND (t1.a > 2)
    )

query T
explain syntax delete from t1 where a > 100 and b > 1 and b < 10
----
DELETE FROM
    t1
WHERE
    (
        (
            (a > 100)
            AND (b > 1)
        )
        AND (b < 10)
    )


query T
explain syntax copy into t1 from 's3://mybucket/data.csv' file_format = ( type = CSV field_delimiter = ',' record_delimiter = '\n' skip_header = 1) size_limit=10
----
COPY
INTO t1
FROM 's3://mybucket/data.csv'
FILE_FORMAT = (
    field_delimiter = ',',
    record_delimiter = '\n',
    skip_header = 1,
    type = CSV
)
SIZE_LIMIT = 10
PURGE = false
DISABLE_VARIANT_CHECK = false


query T
explain syntax copy into 's3://mybucket/data.csv' from t1 file_format = ( type = CSV field_delimiter = ',' record_delimiter = '\n' skip_header = 1)
----
COPY
INTO Uri(UriLocation { protocol: "s3", name: "mybucket", path: "/data.csv", part_prefix: "", connection: Connection { visited_keys: {}, conns: {} } })
FROM t1
FILE_FORMAT = (
    field_delimiter = ',',
    record_delimiter = '\n',
    skip_header = 1,
    type = CSV
)
SINGLE = false

query T
explain syntax create table t3(a int64, b uint64, c float64, d string, e array(int32), f tuple(f1 bool, f2 string)) engine=fuse cluster by (a, b, c) comment='test' compression='LZ4'
----
CREATE TABLE t3 (
    a Int64,
    b UInt64,
    c Float64,
    d STRING,
    e ARRAY(Int32),
    f TUPLE(f1 BOOLEAN, f2 STRING)
) ENGINE = FUSE
CLUSTER BY (
    a,
    b,
    c
)
comment = 'test',
compression = 'LZ4'

query T
explain syntax create view v as select number % 3 as a from numbers(100) where number > 10
----
CREATE VIEW v
AS
    SELECT (number % 3) AS a
    FROM
        numbers(100)
    WHERE
        (number > 10)

query T
explain ast select 1, 'ab', [1,2,3] as a, (1, 'a') as t
----
Query (children 1)
└── QueryBody (children 1)
    └── SelectQuery (children 1)
        └── SelectList (children 4)
            ├── Target (children 1)
            │   └── Literal UInt64(1)
            ├── Target (children 1)
            │   └── Literal String("ab")
            ├── Target (alias a) (children 1)
            │   └── Literal Array (children 3)
            │       ├── Literal UInt64(1)
            │       ├── Literal UInt64(2)
            │       └── Literal UInt64(3)
            └── Target (alias t) (children 1)
                └── Literal Tuple (children 2)
                    ├── Literal UInt64(1)
                    └── Literal String("a")

query T
explain ast select case when a > 1 then 'x' when a < 10 then 'y' else 'z' end from t1
----
Query (children 1)
└── QueryBody (children 1)
    └── SelectQuery (children 2)
        ├── SelectList (children 1)
        │   └── Target (children 1)
        │       └── Function Case (children 3)
        │           ├── Conditions (children 2)
        │           │   ├── Function > (children 2)
        │           │   │   ├── ColumnIdentifier a
        │           │   │   └── Literal UInt64(1)
        │           │   └── Function < (children 2)
        │           │       ├── ColumnIdentifier a
        │           │       └── Literal UInt64(10)
        │           ├── Results (children 2)
        │           │   ├── Literal String("x")
        │           │   └── Literal String("y")
        │           └── ElseResult (children 1)
        │               └── Literal String("z")
        └── TableList (children 1)
            └── TableIdentifier t1

query T
explain ast select a, sum(b) as sum from t1 where a in (1, 2) and b > 0 and b < 100 group by a order by a limit 3
----
Query (children 3)
├── QueryBody (children 1)
│   └── SelectQuery (children 4)
│       ├── SelectList (children 2)
│       │   ├── Target (children 1)
│       │   │   └── ColumnIdentifier a
│       │   └── Target (alias sum) (children 1)
│       │       └── Function sum (children 1)
│       │           └── ColumnIdentifier b
│       ├── TableList (children 1)
│       │   └── TableIdentifier t1
│       ├── Where (children 1)
│       │   └── Function AND (children 2)
│       │       ├── Function AND (children 2)
│       │       │   ├── Function In (children 2)
│       │       │   │   ├── ColumnIdentifier a
│       │       │   │   └── List (children 2)
│       │       │   │       ├── Literal UInt64(1)
│       │       │   │       └── Literal UInt64(2)
│       │       │   └── Function > (children 2)
│       │       │       ├── ColumnIdentifier b
│       │       │       └── Literal UInt64(0)
│       │       └── Function < (children 2)
│       │           ├── ColumnIdentifier b
│       │           └── Literal UInt64(100)
│       └── GroupByList (children 1)
│           └── ColumnIdentifier a
├── OrderByList (children 1)
│   └── OrderByElement (children 1)
│       └── ColumnIdentifier a
└── LimitList (children 1)
    └── Literal UInt64(3)

query T
explain ast select * from t1 inner join t2 on t1.a = t2.a and t1.b = t2.b and t1.a > 2
----
Query (children 1)
└── QueryBody (children 1)
    └── SelectQuery (children 2)
        ├── SelectList (children 1)
        │   └── Target *
        └── TableList (children 1)
            └── TableJoin (children 1)
                └── Join (children 3)
                    ├── TableIdentifier t1
                    ├── TableIdentifier t2
                    └── ConditionOn (children 1)
                        └── Function AND (children 2)
                            ├── Function AND (children 2)
                            │   ├── Function = (children 2)
                            │   │   ├── ColumnIdentifier t1.a
                            │   │   └── ColumnIdentifier t2.a
                            │   └── Function = (children 2)
                            │       ├── ColumnIdentifier t1.b
                            │       └── ColumnIdentifier t2.b
                            └── Function > (children 2)
                                ├── ColumnIdentifier t1.a
                                └── Literal UInt64(2)

query T
explain ast with cte (a, b) as (select 1, 2 union all select 3, 4) select a, b from cte
----
Query (children 2)
├── With (children 1)
│   └── CTE (alias cte(a, b)) (children 1)
│       └── Query (children 1)
│           └── QueryBody (children 1)
│               └── SetOperation Union (children 2)
│                   ├── QueryBody (children 1)
│                   │   └── SelectQuery (children 1)
│                   │       └── SelectList (children 2)
│                   │           ├── Target (children 1)
│                   │           │   └── Literal UInt64(1)
│                   │           └── Target (children 1)
│                   │               └── Literal UInt64(2)
│                   └── QueryBody (children 1)
│                       └── SelectQuery (children 1)
│                           └── SelectList (children 2)
│                               ├── Target (children 1)
│                               │   └── Literal UInt64(3)
│                               └── Target (children 1)
│                                   └── Literal UInt64(4)
└── QueryBody (children 1)
    └── SelectQuery (children 2)
        ├── SelectList (children 2)
        │   ├── Target (children 1)
        │   │   └── ColumnIdentifier a
        │   └── Target (children 1)
        │       └── ColumnIdentifier b
        └── TableList (children 1)
            └── TableIdentifier cte

query T
explain ast with cte (a, b) as (values(1,2),(3,4)) select a, b from cte
----
Query (children 2)
├── With (children 1)
│   └── CTE (alias cte(a, b)) (children 1)
│       └── Query (children 1)
│           └── QueryBody (children 1)
│               └── Values (children 2)
│                   ├── Row 0 (children 2)
│                   │   ├── Literal UInt64(1)
│                   │   └── Literal UInt64(2)
│                   └── Row 1 (children 2)
│                       ├── Literal UInt64(3)
│                       └── Literal UInt64(4)
└── QueryBody (children 1)
    └── SelectQuery (children 2)
        ├── SelectList (children 2)
        │   ├── Target (children 1)
        │   │   └── ColumnIdentifier a
        │   └── Target (children 1)
        │       └── ColumnIdentifier b
        └── TableList (children 1)
            └── TableIdentifier cte

query T
explain ast insert into t1 (a, b) values (1, 2),(3, 4)
----
Insert (children 3)
├── TableIdentifier t1
├── Columns (children 2)
│   ├── Identifier a
│   └── Identifier b
└── Source (children 1)
    └── ValueSource

query T
explain ast delete from t1 where a > 100 and b > 1 and b < 10
----
Delete (children 2)
├── TableIdentifier t1
└── Function AND (children 2)
    ├── Function AND (children 2)
    │   ├── Function > (children 2)
    │   │   ├── ColumnIdentifier a
    │   │   └── Literal UInt64(100)
    │   └── Function > (children 2)
    │       ├── ColumnIdentifier b
    │       └── Literal UInt64(1)
    └── Function < (children 2)
        ├── ColumnIdentifier b
        └── Literal UInt64(10)


query T
explain ast copy into t1 from 's3://mybucket/data.csv' file_format = ( type = CSV field_delimiter = ',' record_delimiter = '\n' skip_header = 1) size_limit=10 max_files=10
----
CopyIntoTable (children 7)
├── TO (children 1)
│   └── TableIdentifier t1
├── FROM (children 1)
│   └── Location 's3://mybucket/data.csv'
├── FileFormats (children 4)
│   ├── FileFormat field_delimiter = String(",")
│   ├── FileFormat record_delimiter = String("\n")
│   ├── FileFormat skip_header = U64(1)
│   └── FileFormat type = Keyword("CSV")
├── SizeLimit 10
├── MaxFiles 10
├── Purge false
└── DisableVariantCheck false

query T
explain ast create database db1 engine=default
----
CreateDatabase (children 2)
├── DatabaseIdentifier db1
└── DatabaseEngine DEFAULT

query T
explain ast create table t3(a int64, b uint64, c float64, d string, e array(int32), f tuple(f1 bool, f2 string)) engine=fuse cluster by (a, b, c) comment='test' compression='LZ4'
----
CreateTable (children 5)
├── TableIdentifier t3
├── ColumnsDefinition (children 6)
│   ├── ColumnDefinition a (children 1)
│   │   └── DataType Int64
│   ├── ColumnDefinition b (children 1)
│   │   └── DataType UInt64
│   ├── ColumnDefinition c (children 1)
│   │   └── DataType Float64
│   ├── ColumnDefinition d (children 1)
│   │   └── DataType STRING
│   ├── ColumnDefinition e (children 1)
│   │   └── DataType ARRAY(Int32)
│   └── ColumnDefinition f (children 1)
│       └── DataType TUPLE(f1 BOOLEAN, f2 STRING)
├── TableEngine FUSE
├── ClusterByList (children 3)
│   ├── ColumnIdentifier a
│   ├── ColumnIdentifier b
│   └── ColumnIdentifier c
└── TableOptions (children 2)
    ├── TableOption comment = "test"
    └── TableOption compression = "LZ4"

query T
explain ast create view v as select number % 3 as a from numbers(100) where number > 10
----
CreateView (children 2)
├── TableIdentifier v
└── Query (children 1)
    └── QueryBody (children 1)
        └── SelectQuery (children 3)
            ├── SelectList (children 1)
            │   └── Target (alias a) (children 1)
            │       └── Function % (children 2)
            │           ├── ColumnIdentifier number
            │           └── Literal UInt64(3)
            ├── TableList (children 1)
            │   └── TableFunction numbers (children 1)
            │       └── Literal UInt64(100)
            └── Where (children 1)
                └── Function > (children 2)
                    ├── ColumnIdentifier number
                    └── Literal UInt64(10)

query T
explain ast show create table t1
----
ShowCreateTable (children 1)
└── TableIdentifier t1

query T
explain ast create user 'test' identified with sha256_password by 'new_password'
----
CreateUser (children 3)
├── User 'test'@'%'
├── AuthType sha256_password
└── Password "new_password"

query T
explain ast select unknown_table.a + 1 from unknown_table1
----
Query (children 1)
└── QueryBody (children 1)
    └── SelectQuery (children 2)
        ├── SelectList (children 1)
        │   └── Target (children 1)
        │       └── Function + (children 2)
        │           ├── ColumnIdentifier unknown_table.a
        │           └── Literal UInt64(1)
        └── TableList (children 1)
            └── TableIdentifier unknown_table1

query T
explain ast SELECT * FROM monthly_sales PIVOT(SUM(amount) FOR MONTH IN ('JAN', 'FEB', 'MAR', 'APR')) ORDER BY EMPID
----
Query (children 2)
├── QueryBody (children 1)
│   └── SelectQuery (children 2)
│       ├── SelectList (children 1)
│       │   └── Target *
│       └── TableList (children 1)
│           └── TableIdentifier monthly_sales PIVOT(SUM(amount) FOR MONTH IN ('JAN', 'FEB', 'MAR', 'APR'))
└── OrderByList (children 1)
    └── OrderByElement (children 1)
         └── ColumnIdentifier EMPID

query T
explain ast SELECT * FROM monthly_sales_1 UNPIVOT(sales FOR month IN (jan, feb, mar, april)) ORDER BY empid
----
Query (children 2)
├── QueryBody (children 1)
│   └── SelectQuery (children 2)
│       ├── SelectList (children 1)
│       │   └── Target *
│       └── TableList (children 1)
│           └── TableIdentifier monthly_sales_1 UNPIVOT(sales FOR month IN (jan, feb, mar, april))
└── OrderByList (children 1)
     └── OrderByElement (children 1)
         └── ColumnIdentifier empid

query T
explain select a from t1 UNION ALL select a from t2
----
UnionAll
├── output columns: [t1.a (#0)]
├── estimated rows: 6.00
├── TableScan
│   ├── table: default.default.t1
│   ├── output columns: [a (#0)]
│   ├── read rows: 1
│   ├── read size: < 1 KiB
│   ├── partitions total: 1
│   ├── partitions scanned: 1
│   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   ├── push downs: [filters: [], limit: NONE]
│   └── estimated rows: 1.00
└── TableScan
    ├── table: default.default.t2
    ├── output columns: [a (#2)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 5.00

query T
explain select * from t1,t2 where (t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4)
----
Filter
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── filters: [t1.a (#0) > 1 AND t2.a (#2) > 2 OR t1.b (#1) < 3 AND t2.b (#3) < 4]
├── estimated rows: 0.54
└── HashJoin
    ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
    ├── join type: CROSS
    ├── build keys: []
    ├── probe keys: []
    ├── filters: []
    ├── estimated rows: 1.50
    ├── Filter(Build)
    │   ├── output columns: [t1.a (#0), t1.b (#1)]
    │   ├── filters: [t1.a (#0) > 1 OR t1.b (#1) < 3]
    │   ├── estimated rows: 0.36
    │   └── TableScan
    │       ├── table: default.default.t1
    │       ├── output columns: [a (#0), b (#1)]
    │       ├── read rows: 1
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │       ├── push downs: [filters: [t1.a (#0) > 1 OR t1.b (#1) < 3], limit: NONE]
    │       └── estimated rows: 1.00
    └── Filter(Probe)
        ├── output columns: [t2.a (#2), t2.b (#3)]
        ├── filters: [t2.a (#2) > 2 OR t2.b (#3) < 4]
        ├── estimated rows: 4.17
        └── TableScan
            ├── table: default.default.t2
            ├── output columns: [a (#2), b (#3)]
            ├── read rows: 5
            ├── read size: < 1 KiB
            ├── partitions total: 1
            ├── partitions scanned: 1
            ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
            ├── push downs: [filters: [t2.a (#2) > 2 OR t2.b (#3) < 4], limit: NONE]
            └── estimated rows: 5.00

query T
explain select * from t1,t2 where (t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4) or t1.a = 2
----
Filter
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── filters: [t1.a (#0) > 1 AND t2.a (#2) > 2 OR t1.b (#1) < 3 AND t2.b (#3) < 4 OR t1.a (#0) = 2]
├── estimated rows: 0.65
└── HashJoin
    ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
    ├── join type: CROSS
    ├── build keys: []
    ├── probe keys: []
    ├── filters: []
    ├── estimated rows: 1.80
    ├── Filter(Build)
    │   ├── output columns: [t1.a (#0), t1.b (#1)]
    │   ├── filters: [t1.a (#0) > 1 OR t1.b (#1) < 3 OR t1.a (#0) = 2]
    │   ├── estimated rows: 0.36
    │   └── TableScan
    │       ├── table: default.default.t1
    │       ├── output columns: [a (#0), b (#1)]
    │       ├── read rows: 1
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1, bloom pruning: 1 to 1>]
    │       ├── push downs: [filters: [t1.a (#0) > 1 OR t1.b (#1) < 3 OR t1.a (#0) = 2], limit: NONE]
    │       └── estimated rows: 1.00
    └── TableScan(Probe)
        ├── table: default.default.t2
        ├── output columns: [a (#2), b (#3)]
        ├── read rows: 5
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 5.00

statement ok
drop table if exists t3

statement ok
create table t3 as select number as a, number as b from numbers(10)

query T
explain select * from t1,t2, t3 where (t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4) or t3.a = 2
----
HashJoin
├── output columns: [t3.a (#4), t3.b (#5), t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── join type: INNER
├── build keys: []
├── probe keys: []
├── filters: [t1.a (#0) > 1 AND t2.a (#2) > 2 OR t1.b (#1) < 3 AND t2.b (#3) < 4 OR t3.a (#4) = 2]
├── estimated rows: 50.00
├── HashJoin(Build)
│   ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
│   ├── join type: CROSS
│   ├── build keys: []
│   ├── probe keys: []
│   ├── filters: []
│   ├── estimated rows: 5.00
│   ├── TableScan(Build)
│   │   ├── table: default.default.t1
│   │   ├── output columns: [a (#0), b (#1)]
│   │   ├── read rows: 1
│   │   ├── read size: < 1 KiB
│   │   ├── partitions total: 1
│   │   ├── partitions scanned: 1
│   │   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   │   ├── push downs: [filters: [], limit: NONE]
│   │   └── estimated rows: 1.00
│   └── TableScan(Probe)
│       ├── table: default.default.t2
│       ├── output columns: [a (#2), b (#3)]
│       ├── read rows: 5
│       ├── read size: < 1 KiB
│       ├── partitions total: 1
│       ├── partitions scanned: 1
│       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       ├── push downs: [filters: [], limit: NONE]
│       └── estimated rows: 5.00
└── TableScan(Probe)
    ├── table: default.default.t3
    ├── output columns: [a (#4), b (#5)]
    ├── read rows: 10
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 10.00

query T
explain select * from t1,t2, t3 where ((t1.a > 1 and t2.a > 2) or (t1.b < 3 and t2.b < 4)) and t3.a > 1
----
HashJoin
├── output columns: [t3.a (#4), t3.b (#5), t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── join type: CROSS
├── build keys: []
├── probe keys: []
├── filters: []
├── estimated rows: 4.42
├── Filter(Build)
│   ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
│   ├── filters: [t1.a (#0) > 1 AND t2.a (#2) > 2 OR t1.b (#1) < 3 AND t2.b (#3) < 4]
│   ├── estimated rows: 0.54
│   └── HashJoin
│       ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
│       ├── join type: CROSS
│       ├── build keys: []
│       ├── probe keys: []
│       ├── filters: []
│       ├── estimated rows: 1.50
│       ├── Filter(Build)
│       │   ├── output columns: [t1.a (#0), t1.b (#1)]
│       │   ├── filters: [t1.a (#0) > 1 OR t1.b (#1) < 3]
│       │   ├── estimated rows: 0.36
│       │   └── TableScan
│       │       ├── table: default.default.t1
│       │       ├── output columns: [a (#0), b (#1)]
│       │       ├── read rows: 1
│       │       ├── read size: < 1 KiB
│       │       ├── partitions total: 1
│       │       ├── partitions scanned: 1
│       │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       │       ├── push downs: [filters: [t1.a (#0) > 1 OR t1.b (#1) < 3], limit: NONE]
│       │       └── estimated rows: 1.00
│       └── Filter(Probe)
│           ├── output columns: [t2.a (#2), t2.b (#3)]
│           ├── filters: [t2.a (#2) > 2 OR t2.b (#3) < 4]
│           ├── estimated rows: 4.17
│           └── TableScan
│               ├── table: default.default.t2
│               ├── output columns: [a (#2), b (#3)]
│               ├── read rows: 5
│               ├── read size: < 1 KiB
│               ├── partitions total: 1
│               ├── partitions scanned: 1
│               ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│               ├── push downs: [filters: [t2.a (#2) > 2 OR t2.b (#3) < 4], limit: NONE]
│               └── estimated rows: 5.00
└── Filter(Probe)
    ├── output columns: [t3.a (#4), t3.b (#5)]
    ├── filters: [t3.a (#4) > 1]
    ├── estimated rows: 8.18
    └── TableScan
        ├── table: default.default.t3
        ├── output columns: [a (#4), b (#5)]
        ├── read rows: 10
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [t3.a (#4) > 1], limit: NONE]
        └── estimated rows: 10.00

query T
explain select * from t1,t2 where ((t1.a > 1 or t1.b < 2) and t2.a > 2) or (t1.b < 3 and t2.b < 4) order by 1 desc limit 3
----
Limit
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── limit: 3
├── offset: 0
├── estimated rows: 0.99
└── Sort
    ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
    ├── sort keys: [a DESC NULLS LAST]
    ├── estimated rows: 0.99
    └── Filter
        ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
        ├── filters: [(t1.a (#0) > 1 OR t1.b (#1) < 2) AND t2.a (#2) > 2 OR t1.b (#1) < 3 AND t2.b (#3) < 4]
        ├── estimated rows: 0.99
        └── HashJoin
            ├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
            ├── join type: CROSS
            ├── build keys: []
            ├── probe keys: []
            ├── filters: []
            ├── estimated rows: 2.03
            ├── Filter(Build)
            │   ├── output columns: [t1.a (#0), t1.b (#1)]
            │   ├── filters: [t1.a (#0) > 1 OR t1.b (#1) < 2 OR t1.b (#1) < 3]
            │   ├── estimated rows: 0.49
            │   └── TableScan
            │       ├── table: default.default.t1
            │       ├── output columns: [a (#0), b (#1)]
            │       ├── read rows: 1
            │       ├── read size: < 1 KiB
            │       ├── partitions total: 1
            │       ├── partitions scanned: 1
            │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
            │       ├── push downs: [filters: [t1.a (#0) > 1 OR t1.b (#1) < 2 OR t1.b (#1) < 3], limit: NONE]
            │       └── estimated rows: 1.00
            └── Filter(Probe)
                ├── output columns: [t2.a (#2), t2.b (#3)]
                ├── filters: [t2.a (#2) > 2 OR t2.b (#3) < 4]
                ├── estimated rows: 4.17
                └── TableScan
                    ├── table: default.default.t2
                    ├── output columns: [a (#2), b (#3)]
                    ├── read rows: 5
                    ├── read size: < 1 KiB
                    ├── partitions total: 1
                    ├── partitions scanned: 1
                    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
                    ├── push downs: [filters: [t2.a (#2) > 2 OR t2.b (#3) < 4], limit: NONE]
                    └── estimated rows: 5.00

query 
explain select * from t1,t2 where (t1.a > 1 or t1.b < 2) and (t1.a > 1 or t1.b < 2)
----
HashJoin
├── output columns: [t2.a (#2), t2.b (#3), t1.a (#0), t1.b (#1)]
├── join type: CROSS
├── build keys: []
├── probe keys: []
├── filters: []
├── estimated rows: 1.80
├── Filter(Build)
│   ├── output columns: [t1.a (#0), t1.b (#1)]
│   ├── filters: [t1.a (#0) > 1 OR t1.b (#1) < 2]
│   ├── estimated rows: 0.36
│   └── TableScan
│       ├── table: default.default.t1
│       ├── output columns: [a (#0), b (#1)]
│       ├── read rows: 1
│       ├── read size: < 1 KiB
│       ├── partitions total: 1
│       ├── partitions scanned: 1
│       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│       ├── push downs: [filters: [t1.a (#0) > 1 OR t1.b (#1) < 2], limit: NONE]
│       └── estimated rows: 1.00
└── TableScan(Probe)
    ├── table: default.default.t2
    ├── output columns: [a (#2), b (#3)]
    ├── read rows: 5
    ├── read size: < 1 KiB
    ├── partitions total: 1
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    ├── push downs: [filters: [], limit: NONE]
    └── estimated rows: 5.00

query 
explain select count(distinct a) from t1;
----
AggregateFinal
├── output columns: [count(_1) (#2)]
├── group by: []
├── aggregate functions: [count()]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: []
    ├── aggregate functions: [count()]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [t1.a (#0)]
        ├── group by: [a]
        ├── aggregate functions: []
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [a]
            ├── aggregate functions: []
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.default.t1
                ├── output columns: [a (#0)]
                ├── read rows: 1
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
                ├── push downs: [filters: [], limit: NONE]
                └── estimated rows: 1.00

query 
explain select count_distinct(a) from t1;
----
AggregateFinal
├── output columns: [count(_1) (#2)]
├── group by: []
├── aggregate functions: [count()]
├── estimated rows: 1.00
└── AggregatePartial
    ├── group by: []
    ├── aggregate functions: [count()]
    ├── estimated rows: 1.00
    └── AggregateFinal
        ├── output columns: [t1.a (#0)]
        ├── group by: [a]
        ├── aggregate functions: []
        ├── estimated rows: 1.00
        └── AggregatePartial
            ├── group by: [a]
            ├── aggregate functions: []
            ├── estimated rows: 1.00
            └── TableScan
                ├── table: default.default.t1
                ├── output columns: [a (#0)]
                ├── read rows: 1
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
                ├── push downs: [filters: [], limit: NONE]
                └── estimated rows: 1.00

query 
explain select * from (values(1, 'a'),(2, 'b')) t(c1,c2)
----
ConstantTableScan
├── output columns: [c1 (#0), c2 (#1)]
├── column 0: [1, 2]
└── column 1: ['a', 'b']

statement ok
drop table t1

statement ok
drop table t2

query 
explain syntax select * from read_parquet('p1', 'p2', 'p3');
----
SELECT *
FROM
    read_parquet('p1', 'p2', 'p3')

query 
explain syntax select * from read_parquet(prune_page=>true, refresh_meta_cache=>true);
----
SELECT *
FROM
    read_parquet(prune_page=>TRUE, refresh_meta_cache=>TRUE)

query 
explain syntax select * from read_parquet('p1', 'p2', 'p3', prune_page=>true, refresh_meta_cache=>true);
----
SELECT *
FROM
    read_parquet('p1', 'p2', 'p3', prune_page=>TRUE, refresh_meta_cache=>TRUE)

query 
explain ast select * from read_parquet('p1', 'p2', 'p3', prune_page=>true, refresh_meta_cache=>true);
----
Query (children 1)
└── QueryBody (children 1)
    └── SelectQuery (children 2)
        ├── SelectList (children 1)
        │   └── Target *
        └── TableList (children 1)
            └── TableFunction read_parquet (children 5)
                ├── Literal String("p1")
                ├── Literal String("p2")
                ├── Literal String("p3")
                ├── prune_page=>Literal Boolean(true)
                └── refresh_meta_cache=>Literal Boolean(true)

statement ok
drop table if exists t4

statement ok
create table t4(a int, b string);

query 
explain select * from t4 where a = 1 and try_cast(get(try_parse_json(b),'bb') as varchar) = 'xx';
----
Filter
├── output columns: [t4.a (#0), t4.b (#1)]
├── filters: [is_true(t4.a (#0) = 1), is_true(TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')]
├── estimated rows: 0.00
└── TableScan
    ├── table: default.default.t4
    ├── output columns: [a (#0), b (#1)]
    ├── read rows: 0
    ├── read size: 0
    ├── partitions total: 0
    ├── partitions scanned: 0
    ├── push downs: [filters: [and_filters(t4.a (#0) = 1, TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')], limit: NONE]
    └── estimated rows: 0.00

statement ok
drop view if exists v4

statement ok
create view v4 as select a as a, try_cast(get(try_parse_json(b), 'bb') as varchar) as b from t4;

query 
explain select * from v4 where b = 'xx';
----
EvalScalar
├── output columns: [t4.a (#0), b (#2)]
├── expressions: [TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL)]
├── estimated rows: 0.00
└── Filter
    ├── output columns: [t4.a (#0), t4.b (#1)]
    ├── filters: [is_true(TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')]
    ├── estimated rows: 0.00
    └── TableScan
        ├── table: default.default.t4
        ├── output columns: [a (#0), b (#1)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [is_true(TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL) = 'xx')], limit: NONE]
        └── estimated rows: 0.00

query T
explain select * from v4 where a > 100;
----
EvalScalar
├── output columns: [t4.a (#0), b (#2)]
├── expressions: [TRY_CAST(get(try_parse_json(t4.b (#1)), 'bb') AS String NULL)]
├── estimated rows: 0.00
└── Filter
    ├── output columns: [t4.a (#0), t4.b (#1)]
    ├── filters: [is_true(t4.a (#0) > 100)]
    ├── estimated rows: 0.00
    └── TableScan
        ├── table: default.default.t4
        ├── output columns: [a (#0), b (#1)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [is_true(t4.a (#0) > 100)], limit: NONE]
        └── estimated rows: 0.00

statement ok
drop table if exists a

statement ok
drop table if exists b

statement ok
create table a(id int, c1 INT NULL)

statement ok
create table b(id int, c1 INT NULL)

statement ok
insert into a values(1, 1683648000)

statement ok
insert into b values(1, 1683648000)

statement ok
insert into b values(2, 1683648000)

# left join to inner join
query T
explain select * from a left join b on a.id = b.id where a.c1 between 1683648000 and 1683734400 and b.c1 between 1683648000 and 1683734400 limit 1;
----
Limit
├── output columns: [b.id (#2), b.c1 (#3), a.c1 (#1), a.id (#0)]
├── limit: 1
├── offset: 0
├── estimated rows: 0.08
└── HashJoin
    ├── output columns: [b.id (#2), b.c1 (#3), a.c1 (#1), a.id (#0)]
    ├── join type: INNER
    ├── build keys: [a.id (#0)]
    ├── probe keys: [b.id (#2)]
    ├── filters: []
    ├── estimated rows: 0.08
    ├── Filter(Build)
    │   ├── output columns: [a.id (#0), a.c1 (#1)]
    │   ├── filters: [is_true(a.c1 (#1) >= 1683648000), is_true(a.c1 (#1) <= 1683734400)]
    │   ├── estimated rows: 0.20
    │   └── TableScan
    │       ├── table: default.default.a
    │       ├── output columns: [id (#0), c1 (#1)]
    │       ├── read rows: 1
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │       ├── push downs: [filters: [and_filters(a.c1 (#1) >= 1683648000, a.c1 (#1) <= 1683734400)], limit: NONE]
    │       └── estimated rows: 1.00
    └── Filter(Probe)
        ├── output columns: [b.id (#2), b.c1 (#3)]
        ├── filters: [is_true(b.c1 (#3) >= 1683648000), is_true(b.c1 (#3) <= 1683734400)]
        ├── estimated rows: 0.40
        └── TableScan
            ├── table: default.default.b
            ├── output columns: [id (#2), c1 (#3)]
            ├── read rows: 2
            ├── read size: < 1 KiB
            ├── partitions total: 2
            ├── partitions scanned: 2
            ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2>]
            ├── push downs: [filters: [and_filters(b.c1 (#3) >= 1683648000, b.c1 (#3) <= 1683734400)], limit: NONE]
            └── estimated rows: 2.00

statement ok
drop table a;

statement ok
drop table b;

# https://github.com/datafuselabs/databend/pull/12026
query T
explain select number, pt, register_at from (select a.number, pt,register_at from ( select number,  to_yyyymmdd(to_timestamp(number))   as pt
from numbers(10) where number > 5
) a join ( select number , to_yyyymmdd(to_timestamp(number)) as  register_at from numbers(10) where number > 5
) b on  a.number=b.number order by a.number) where pt = register_at;
----
Sort
├── output columns: [numbers.number (#0), pt (#1), register_at (#3)]
├── sort keys: [number ASC NULLS LAST]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [numbers.number (#0), pt (#1), register_at (#3)]
    ├── join type: INNER
    ├── build keys: [b.register_at (#3), b.number (#2)]
    ├── probe keys: [a.pt (#1), a.number (#0)]
    ├── filters: []
    ├── estimated rows: 0.00
    ├── EvalScalar(Build)
    │   ├── output columns: [numbers.number (#2), register_at (#3)]
    │   ├── expressions: [to_yyyymmdd(to_timestamp(to_int64(numbers.number (#2))))]
    │   ├── estimated rows: 0.00
    │   └── Filter
    │       ├── output columns: [numbers.number (#2)]
    │       ├── filters: [numbers.number (#2) > 5]
    │       ├── estimated rows: 0.00
    │       └── TableScan
    │           ├── table: default.system.numbers
    │           ├── output columns: [number (#2)]
    │           ├── read rows: 10
    │           ├── read size: < 1 KiB
    │           ├── partitions total: 1
    │           ├── partitions scanned: 1
    │           ├── push downs: [filters: [numbers.number (#2) > 5], limit: NONE]
    │           └── estimated rows: 10.00
    └── EvalScalar(Probe)
        ├── output columns: [numbers.number (#0), pt (#1)]
        ├── expressions: [to_yyyymmdd(to_timestamp(to_int64(numbers.number (#0))))]
        ├── estimated rows: 0.00
        └── Filter
            ├── output columns: [numbers.number (#0)]
            ├── filters: [numbers.number (#0) > 5]
            ├── estimated rows: 0.00
            └── TableScan
                ├── table: default.system.numbers
                ├── output columns: [number (#0)]
                ├── read rows: 10
                ├── read size: < 1 KiB
                ├── partitions total: 1
                ├── partitions scanned: 1
                ├── push downs: [filters: [numbers.number (#0) > 5], limit: NONE]
                └── estimated rows: 10.00


statement ok
drop table if exists a

statement ok
drop table if exists b

statement ok
create table a(id int, c1 INT NULL)

statement ok
create table b(id int, c1 INT NULL)

statement ok
insert into a values (1, 2), (2, 4), (3, 6)

statement ok
insert into b values (1, 5), (4, 8)

# LEFT SINGLE JOIN
query T
explain select * from a where a.id = (select id from b where a.id = b.id);
----
Filter
├── output columns: [a.id (#0), a.c1 (#1)]
├── filters: [is_true(a.id (#0) = scalar_subquery_2 (#2))]
├── estimated rows: 0.08
└── HashJoin
    ├── output columns: [a.id (#0), a.c1 (#1), b.id (#2)]
    ├── join type: INNER
    ├── build keys: [id (#2)]
    ├── probe keys: [id (#0)]
    ├── filters: []
    ├── estimated rows: 0.40
    ├── Filter(Build)
    │   ├── output columns: [b.id (#2)]
    │   ├── filters: [is_true(b.id (#2) = b.id (#2))]
    │   ├── estimated rows: 0.40
    │   └── TableScan
    │       ├── table: default.default.b
    │       ├── output columns: [id (#2)]
    │       ├── read rows: 2
    │       ├── read size: < 1 KiB
    │       ├── partitions total: 1
    │       ├── partitions scanned: 1
    │       ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │       ├── push downs: [filters: [is_true(b.id (#2) = b.id (#2))], limit: NONE]
    │       └── estimated rows: 2.00
    └── TableScan(Probe)
        ├── table: default.default.a
        ├── output columns: [id (#0), c1 (#1)]
        ├── read rows: 3
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 3.00

statement ok
drop table a;

statement ok
drop table b;

statement ok
create table t1(a int, b int);

statement ok
insert into t1 values(1, 2), (2, 3), (3, 4);

query T
explain select * from t1 where a in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300);
----
HashJoin
├── output columns: [t1.a (#0), t1.b (#1)]
├── join type: INNER
├── build keys: [t1.a (#0)]
├── probe keys: [CAST(subquery_2 (#2) AS Int32 NULL)]
├── filters: []
├── estimated rows: 3.00
├── TableScan(Build)
│   ├── table: default.default.t1
│   ├── output columns: [a (#0), b (#1)]
│   ├── read rows: 3
│   ├── read size: < 1 KiB
│   ├── partitions total: 1
│   ├── partitions scanned: 1
│   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
│   ├── push downs: [filters: [], limit: NONE]
│   └── estimated rows: 3.00
└── AggregateFinal(Probe)
    ├── output columns: [col0 (#2)]
    ├── group by: [col0]
    ├── aggregate functions: []
    ├── estimated rows: 1294.00
    └── AggregatePartial
        ├── group by: [col0]
        ├── aggregate functions: []
        ├── estimated rows: 1294.00
        └── ConstantTableScan
            ├── output columns: [col0 (#2)]
            └── column 0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300]

query T
explain select * from t1 where a not in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300);
----
Filter
├── output columns: [t1.a (#0), t1.b (#1)]
├── filters: [is_true(NOT 3 (#3))]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [t1.a (#0), t1.b (#1), marker (#3)]
    ├── join type: LEFT MARK
    ├── build keys: [t1.a (#0)]
    ├── probe keys: [CAST(subquery_2 (#2) AS Int32 NULL)]
    ├── filters: []
    ├── estimated rows: 3.00
    ├── TableScan(Build)
    │   ├── table: default.default.t1
    │   ├── output columns: [a (#0), b (#1)]
    │   ├── read rows: 3
    │   ├── read size: < 1 KiB
    │   ├── partitions total: 1
    │   ├── partitions scanned: 1
    │   ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
    │   ├── push downs: [filters: [], limit: NONE]
    │   └── estimated rows: 3.00
    └── AggregateFinal(Probe)
        ├── output columns: [col0 (#2)]
        ├── group by: [col0]
        ├── aggregate functions: []
        ├── estimated rows: 1294.00
        └── AggregatePartial
            ├── group by: [col0]
            ├── aggregate functions: []
            ├── estimated rows: 1294.00
            └── ConstantTableScan
                ├── output columns: [col0 (#2)]
                └── column 0: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300]

statement ok
drop table t1;

statement ok
drop table if exists t1;

statement ok
drop table if exists t2;

statement ok
CREATE TABLE t1(i int, j int);

statement ok
CREATE TABLE t2(k int, l int);

statement ok
INSERT INTO t1 VALUES (1, 2), (2, 3), (3, 4);

statement ok
INSERT INTO t2 VALUES (1, 10), (2, 20);

query T
EXPLAIN SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE AND t1.i = t2.k AND FALSE order by i, j;
----
Sort
├── output columns: [t1.i (#0), t1.j (#1), t2.k (#2), t2.l (#3)]
├── sort keys: [i ASC NULLS LAST, j ASC NULLS LAST]
├── estimated rows: 3.00
└── HashJoin
    ├── output columns: [t1.i (#0), t1.j (#1), t2.k (#2), t2.l (#3)]
    ├── join type: LEFT OUTER
    ├── build keys: [t2.k (#2)]
    ├── probe keys: [t1.i (#0)]
    ├── filters: []
    ├── estimated rows: 3.00
    ├── Filter(Build)
    │   ├── output columns: [t2.k (#2), t2.l (#3)]
    │   ├── filters: [false]
    │   ├── estimated rows: 0.00
    │   └── TableScan
    │       ├── table: default.default.t2
    │       ├── output columns: [k (#2), l (#3)]
    │       ├── read rows: 0
    │       ├── read size: 0
    │       ├── partitions total: 0
    │       ├── partitions scanned: 0
    │       ├── push downs: [filters: [false], limit: NONE]
    │       └── estimated rows: 2.00
    └── TableScan(Probe)
        ├── table: default.default.t1
        ├── output columns: [i (#0), j (#1)]
        ├── read rows: 3
        ├── read size: < 1 KiB
        ├── partitions total: 1
        ├── partitions scanned: 1
        ├── pruning stats: [segments: <range pruning: 1 to 1>, blocks: <range pruning: 1 to 1>]
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 3.00

query T
EXPLAIN optimized SELECT * FROM t1 LEFT OUTER JOIN t2 ON TRUE AND t1.i = t2.k AND FALSE order by i, j;
----
EvalScalar
├── scalars: [t1.i (#0) AS (#0), t1.j (#1) AS (#1), t2.k (#2) AS (#2), t2.l (#3) AS (#3)]
└── Sort
    ├── sort keys: [default.t1.i (#0) ASC, default.t1.j (#1) ASC]
    ├── limit: [NONE]
    └── Join(Left)
        ├── build keys: [t2.k (#2)]
        ├── probe keys: [t1.i (#0)]
        ├── other filters: []
        ├── Scan
        │   ├── table: default.t1
        │   ├── filters: []
        │   ├── order by: []
        │   └── limit: NONE
        └── Filter
            ├── filters: [false]
            └── Scan
                ├── table: default.t2
                ├── filters: [false]
                ├── order by: []
                └── limit: NONE


statement ok
drop table if exists t3;

statement ok
CREATE TABLE t3(a int, b map(string, string) null, c map(string, variant) null);

statement ok
INSERT INTO t3 VALUES (1, {'k1':'a', 'k2':'b'}, {'k1':'"a"', 'k2':'100'}), (2, null, null), (3, {'k3':'z'}, {'k3':'"z"'});

statement ok
INSERT INTO t3 VALUES (4, {'k1':'a', 'k2':'m'}, {'k1':'"a"', 'k2':'"m"'}), (5, null, null), (6, {'k3':'z'}, {'k3':'"v"'});

query T
EXPLAIN SELECT * FROM t3 WHERE b['k2'] = 'm';
----
Filter
├── output columns: [t3.a (#0), t3.b (#1), t3.c (#2)]
├── filters: [is_true(get(t3.b (#1), 'k2') = 'm')]
├── estimated rows: 1.20
└── TableScan
    ├── table: default.default.t3
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 3
    ├── read size: < 1 KiB
    ├── partitions total: 2
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2, bloom pruning: 2 to 1>]
    ├── push downs: [filters: [is_true(get(t3.b (#1), 'k2') = 'm')], limit: NONE]
    └── estimated rows: 6.00

query T
EXPLAIN SELECT * FROM t3 WHERE c['k3'] = 'v';
----
Filter
├── output columns: [t3.a (#0), t3.b (#1), t3.c (#2)]
├── filters: [is_true(TRY_CAST(get(t3.c (#2), 'k3') AS String NULL) = 'v')]
├── estimated rows: 1.20
└── TableScan
    ├── table: default.default.t3
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 3
    ├── read size: < 1 KiB
    ├── partitions total: 2
    ├── partitions scanned: 1
    ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2, bloom pruning: 2 to 1>]
    ├── push downs: [filters: [is_true(TRY_CAST(get(t3.c (#2), 'k3') AS String NULL) = 'v')], limit: NONE]
    └── estimated rows: 6.00

query T
EXPLAIN SELECT * FROM t3 WHERE c['k2'] = 100;
----
Filter
├── output columns: [t3.a (#0), t3.b (#1), t3.c (#2)]
├── filters: [is_true(TRY_CAST(get(t3.c (#2), 'k2') AS UInt8 NULL) = 100)]
├── estimated rows: 1.20
└── TableScan
    ├── table: default.default.t3
    ├── output columns: [a (#0), b (#1), c (#2)]
    ├── read rows: 3
    ├── read size: < 1 KiB
    ├── partitions total: 2
    ├── partitions scanned: 2
    ├── pruning stats: [segments: <range pruning: 2 to 2>, blocks: <range pruning: 2 to 2>]
    ├── push downs: [filters: [is_true(TRY_CAST(get(t3.c (#2), 'k2') AS UInt8 NULL) = 100)], limit: NONE]
    └── estimated rows: 6.00

statement ok
drop table t1;

statement ok
drop table t2;

statement ok
drop table t3;

statement ok
CREATE TABLE customers AS SELECT
  number % 100 AS customer_id,
  concat('Customer ', to_string(number % 100)) AS customer_name,
  CASE WHEN (rand() * 10000)::int % 3 = 0 THEN 'Small'
       WHEN (rand() * 10000 % 3)::int = 1 THEN 'Medium'
       ELSE 'Large'
  END AS segment,
  date_add('year', floor(rand() * 100 % 5)::int, '2021-01-01') AS create_timestamp,
  (rand() * 100)::int % 2 = 0 AS active
FROM numbers(100);


statement ok
CREATE TABLE products AS SELECT
  number % 10 AS product_id,
  concat('Product ', to_string(number % 10)) AS product_name,
  (rand() * 10000 % 2000 * 0.01)::decimal(10, 2) AS price,
  CASE WHEN (rand() * 100)::int % 4 = 0 THEN 'Electronics'
       WHEN (rand() * 100 % 4)::int = 1 THEN 'Clothing'
       WHEN (rand() * 1000 % 4)::int = 2 THEN 'Grocery'
       ELSE 'Furniture'
  END AS category
FROM numbers(10);

statement ok
CREATE TABLE sales AS SELECT
  number % 500 AS sale_id,
  number % 100 AS product_id,
  number % 100 AS customer_id,
  date_add('day', floor(rand() * 10000 % 365)::int, '2021-01-01') AS sale_date,
  (rand() * 10000 % 20 + 1)::int AS quantity,
  (rand() * 10000 % 2000 * 0.01)::decimal(10, 2) AS net_paid
FROM numbers(500);

query T
explain join SELECT customer_name, segment, (SELECT SUM(net_paid) FROM sales WHERE customer_id IN (SELECT customer_id FROM customers WHERE segment = c.segment AND active = true)) FROM customers c WHERE c.customer_id IN (SELECT customer_id FROM sales WHERE net_paid > 100) LIMIT 10;
----
HashJoin: RIGHT OUTER
├── Build
│   └── HashJoin: LEFT SEMI
│       ├── Build
│       │   └── Scan: default.default.sales (#3) (read rows: 0)
│       └── Probe
│           └── Scan: default.default.customers (#0) (read rows: 100)
└── Probe
    └── HashJoin: LEFT SEMI
        ├── Build
        │   └── Scan: default.default.customers (#2) (read rows: 100)
        └── Probe
            └── HashJoin: CROSS
                ├── Build
                │   └── Scan: default.default.customers (#0) (read rows: 100)
                └── Probe
                    └── Scan: default.default.sales (#1) (read rows: 500)


query T
explain join SELECT c.customer_name FROM customers c WHERE NOT EXISTS ( SELECT category FROM products WHERE category NOT IN ( SELECT p.category FROM sales s JOIN products p ON s.product_id = p.product_id WHERE s.customer_id = c.customer_id ) ) ORDER BY c.customer_name;
----
HashJoin: RIGHT MARK
├── Build
│   └── HashJoin: RIGHT MARK
│       ├── Build
│       │   └── HashJoin: INNER
│       │       ├── Build
│       │       │   └── Scan: default.default.products (#3) (read rows: 10)
│       │       └── Probe
│       │           └── Scan: default.default.sales (#2) (read rows: 500)
│       └── Probe
│           └── HashJoin: CROSS
│               ├── Build
│               │   └── Scan: default.default.products (#1) (read rows: 10)
│               └── Probe
│                   └── Scan: default.default.customers (#0) (read rows: 100)
└── Probe
    └── Scan: default.default.customers (#0) (read rows: 100)

statement ok
drop table customers;

statement ok
drop table products;

statement ok
drop table sales;

statement ok
create table t1 (a int);

statement ok
create table t2 (b int);

query T
explain select date from (select *, 'year' as date from t1 left join t2 on t1.a = t2.b) where date = '';
----
EvalScalar
├── output columns: [date (#2)]
├── expressions: ['year']
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: []
    ├── join type: LEFT OUTER
    ├── build keys: [t2.b (#1)]
    ├── probe keys: [t1.a (#0)]
    ├── filters: []
    ├── estimated rows: 0.00
    ├── Filter(Build)
    │   ├── output columns: [t2.b (#1)]
    │   ├── filters: [false]
    │   ├── estimated rows: 0.00
    │   └── TableScan
    │       ├── table: default.default.t2
    │       ├── output columns: [b (#1)]
    │       ├── read rows: 0
    │       ├── read size: 0
    │       ├── partitions total: 0
    │       ├── partitions scanned: 0
    │       ├── push downs: [filters: [false], limit: NONE]
    │       └── estimated rows: 0.00
    └── Filter(Probe)
        ├── output columns: [t1.a (#0)]
        ├── filters: [false]
        ├── estimated rows: 0.00
        └── TableScan
            ├── table: default.default.t1
            ├── output columns: [a (#0)]
            ├── read rows: 0
            ├── read size: 0
            ├── partitions total: 0
            ├── partitions scanned: 0
            ├── push downs: [filters: [false], limit: NONE]
            └── estimated rows: 0.00


statement ok
drop table t1;

statement ok
drop table t2;

statement ok
create table t1(a int, b int, c varchar(20));

statement ok
create table t2(a int, b int, c varchar(20));

# scalar subquery and sort plan contains count() agg function.
query T
explain select * from t2 where c > (select c from t1 where t1.a = t2.a group by c order by count(a));
----
Filter
├── output columns: [t2.a (#0), t2.b (#1), t2.c (#2)]
├── filters: [is_true(t2.c (#2) > scalar_subquery_5 (#5))]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [t2.a (#0), t2.b (#1), t2.c (#2), t1.c (#5)]
    ├── join type: INNER
    ├── build keys: [a (#3)]
    ├── probe keys: [a (#0)]
    ├── filters: []
    ├── estimated rows: 0.00
    ├── Sort(Build)
    │   ├── output columns: [t1.c (#5), t1.a (#3), count(a) (#7)]
    │   ├── sort keys: [count(a) ASC NULLS LAST]
    │   ├── estimated rows: 0.00
    │   └── EvalScalar
    │       ├── output columns: [t1.c (#5), t1.a (#3), count(a) (#7)]
    │       ├── expressions: [count(a) (#6)]
    │       ├── estimated rows: 0.00
    │       └── AggregateFinal
    │           ├── output columns: [count(a) (#6), t1.c (#5), t1.a (#3)]
    │           ├── group by: [c, a]
    │           ├── aggregate functions: [count(a)]
    │           ├── estimated rows: 0.00
    │           └── AggregatePartial
    │               ├── group by: [c, a]
    │               ├── aggregate functions: [count(a)]
    │               ├── estimated rows: 0.00
    │               └── Filter
    │                   ├── output columns: [t1.a (#3), t1.c (#5)]
    │                   ├── filters: [is_true(t1.a (#3) = t1.a (#3))]
    │                   ├── estimated rows: 0.00
    │                   └── TableScan
    │                       ├── table: default.default.t1
    │                       ├── output columns: [a (#3), c (#5)]
    │                       ├── read rows: 0
    │                       ├── read size: 0
    │                       ├── partitions total: 0
    │                       ├── partitions scanned: 0
    │                       ├── push downs: [filters: [is_true(t1.a (#3) = t1.a (#3))], limit: NONE]
    │                       └── estimated rows: 0.00
    └── TableScan(Probe)
        ├── table: default.default.t2
        ├── output columns: [a (#0), b (#1), c (#2)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 0.00

query T
explain select * from t2 where c > (select c from t1 where t1.a = t2.a group by c order by count(*));
----
Filter
├── output columns: [t2.a (#0), t2.b (#1), t2.c (#2)]
├── filters: [is_true(t2.c (#2) > scalar_subquery_5 (#5))]
├── estimated rows: 0.00
└── HashJoin
    ├── output columns: [t2.a (#0), t2.b (#1), t2.c (#2), t1.c (#5)]
    ├── join type: INNER
    ├── build keys: [a (#3)]
    ├── probe keys: [a (#0)]
    ├── filters: []
    ├── estimated rows: 0.00
    ├── Sort(Build)
    │   ├── output columns: [t1.c (#5), t1.a (#3), COUNT(*) (#7)]
    │   ├── sort keys: [COUNT(*) ASC NULLS LAST]
    │   ├── estimated rows: 0.00
    │   └── EvalScalar
    │       ├── output columns: [t1.c (#5), t1.a (#3), COUNT(*) (#7)]
    │       ├── expressions: [COUNT(*) (#6)]
    │       ├── estimated rows: 0.00
    │       └── AggregateFinal
    │           ├── output columns: [COUNT(*) (#6), t1.c (#5), t1.a (#3)]
    │           ├── group by: [c, a]
    │           ├── aggregate functions: [count()]
    │           ├── estimated rows: 0.00
    │           └── AggregatePartial
    │               ├── group by: [c, a]
    │               ├── aggregate functions: [count()]
    │               ├── estimated rows: 0.00
    │               └── Filter
    │                   ├── output columns: [t1.a (#3), t1.c (#5)]
    │                   ├── filters: [is_true(a (#3) = a (#3))]
    │                   ├── estimated rows: 0.00
    │                   └── TableScan
    │                       ├── table: default.default.t1
    │                       ├── output columns: [a (#3), c (#5)]
    │                       ├── read rows: 0
    │                       ├── read size: 0
    │                       ├── partitions total: 0
    │                       ├── partitions scanned: 0
    │                       ├── push downs: [filters: [is_true(t1.a (#3) = t1.a (#3))], limit: NONE]
    │                       └── estimated rows: 0.00
    └── TableScan(Probe)
        ├── table: default.default.t2
        ├── output columns: [a (#0), b (#1), c (#2)]
        ├── read rows: 0
        ├── read size: 0
        ├── partitions total: 0
        ├── partitions scanned: 0
        ├── push downs: [filters: [], limit: NONE]
        └── estimated rows: 0.00

query T
explain insert into t2 select * from t1;
----
InsertPlan (subquery):
├── table: default.default.t2
├── inserted columns: [t2.a (#0),t2.b (#1),t2.c (#2)]
├── overwrite: false
└── EvalScalar
    ├── scalars: [t1.a (#0) AS (#0), t1.b (#1) AS (#1), t1.c (#2) AS (#2)]
    └── Scan
        ├── table: default.t1
        ├── filters: []
        ├── order by: []
        └── limit: NONE


statement ok
drop table t1;

statement ok
drop table t2;

query T
explain select * from numbers(0);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 0
├── read size: 0
├── partitions total: 1
├── partitions scanned: 1
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 0.00

query T
explain select * from numbers(10);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10
├── read size: < 1 KiB
├── partitions total: 1
├── partitions scanned: 1
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10.00

query T
explain select * from numbers(10000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000
├── read size: 78.12 KiB
├── partitions total: 1
├── partitions scanned: 1
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000.00

query T
explain select * from numbers(10000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000
├── read size: 76.29 MiB
├── partitions total: 153
├── partitions scanned: 153
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000.00

query T
explain select * from numbers(10000000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000000
├── read size: 74.51 GiB
├── partitions total: 152588
├── partitions scanned: 152588
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000000.00

query T
explain select * from numbers(10000000000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000000000
├── read size: 72.76 TiB
├── partitions total: 152587891
├── partitions scanned: 152587891
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000000000.00

query T
explain select * from numbers(10000000000000000);
----
TableScan
├── table: default.system.numbers
├── output columns: [number (#0)]
├── read rows: 10000000000000000
├── read size: 71.05 PiB
├── partitions total: 152587890626
├── partitions scanned: 152587890626
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 10000000000000000.00



statement ok
CREATE OR REPLACE TABLE orders_placed (order_id INT, customer_id INT, order_amount FLOAT, order_date DATE);

query T
EXPLAIN AST
INSERT FIRST
WHEN order_amount > 1000 THEN INTO cat.db1.t1(order_id, update_note) VALUES (order_id, 'PriorityHandling')
WHEN order_amount > 500 THEN INTO cat2.db2.t2 VALUES (order_id, 'ExpressHandling')
WHEN order_amount > 100 THEN
   INTO cat3.db3.t3 VALUES (order_id, 'StandardHandling')
   INTO cat3.db3.t4 VALUES (order_id, 'StandardHandling')
ELSE INTO processing_updates VALUES (order_id, 'ReviewNeeded')
SELECT order_id, order_amount FROM orders_placed;
----
INSERT FIRST (children 5)
├── WHEN (children 2)
│   ├── Function > (children 2)
│   │   ├── ColumnIdentifier order_amount
│   │   └── Literal UInt64(1000)
│   └── INTO (children 2)
│       ├── TableIdentifier cat.db1.t1
│       └── Columns (children 2)
│           ├── Identifier order_id
│           └── Identifier update_note
├── WHEN (children 2)
│   ├── Function > (children 2)
│   │   ├── ColumnIdentifier order_amount
│   │   └── Literal UInt64(500)
│   └── INTO (children 1)
│       └── TableIdentifier cat2.db2.t2
├── WHEN (children 3)
│   ├── Function > (children 2)
│   │   ├── ColumnIdentifier order_amount
│   │   └── Literal UInt64(100)
│   ├── INTO (children 1)
│   │   └── TableIdentifier cat3.db3.t3
│   └── INTO (children 1)
│       └── TableIdentifier cat3.db3.t4
├── ELSE (children 1)
│   └── INTO (children 1)
│       └── TableIdentifier processing_updates
└── Query (children 1)
    └── QueryBody (children 1)
        └── SelectQuery (children 2)
            ├── SelectList (children 2)
            │   ├── Target (children 1)
            │   │   └── ColumnIdentifier order_id
            │   └── Target (children 1)
            │       └── ColumnIdentifier order_amount
            └── TableList (children 1)
                └── TableIdentifier orders_placed

query T
EXPLAIN ast
INSERT ALL
   INTO cat.db1.t1 VALUES (order_id, 'PriorityHandling')
   INTO cat3.db3.t3 VALUES (order_id, 'StandardHandling')
   INTO cat3.db3.t4 VALUES (order_id, 'StandardHandling')
SELECT order_id, order_amount FROM orders_placed;
----
INSERT ALL (children 2)
├── INTO (children 3)
│   ├── INTO (children 1)
│   │   └── TableIdentifier cat.db1.t1
│   ├── INTO (children 1)
│   │   └── TableIdentifier cat3.db3.t3
│   └── INTO (children 1)
│       └── TableIdentifier cat3.db3.t4
└── Query (children 1)
    └── QueryBody (children 1)
        └── SelectQuery (children 2)
            ├── SelectList (children 2)
            │   ├── Target (children 1)
            │   │   └── ColumnIdentifier order_id
            │   └── Target (children 1)
            │       └── ColumnIdentifier order_amount
            └── TableList (children 1)
                └── TableIdentifier orders_placed

query T
EXPLAIN ast
INSERT OVERWRITE ALL
   INTO cat.db1.t1 VALUES (order_id, 'PriorityHandling')
   INTO cat3.db3.t3 VALUES (order_id, 'StandardHandling')
   INTO cat3.db3.t4 VALUES (order_id, 'StandardHandling')
SELECT order_id, order_amount FROM orders_placed;
----
INSERT OVERWRITE ALL (children 2)
├── INTO (children 3)
│   ├── INTO (children 1)
│   │   └── TableIdentifier cat.db1.t1
│   ├── INTO (children 1)
│   │   └── TableIdentifier cat3.db3.t3
│   └── INTO (children 1)
│       └── TableIdentifier cat3.db3.t4
└── Query (children 1)
    └── QueryBody (children 1)
        └── SelectQuery (children 2)
            ├── SelectList (children 2)
            │   ├── Target (children 1)
            │   │   └── ColumnIdentifier order_id
            │   └── Target (children 1)
            │       └── ColumnIdentifier order_amount
            └── TableList (children 1)
                └── TableIdentifier orders_placed

statement ok
drop table  orders_placed
