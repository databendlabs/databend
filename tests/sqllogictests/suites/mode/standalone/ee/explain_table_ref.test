## Copyright 2023 Databend Cloud
##
## Licensed under the Elastic License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##     https://www.elastic.co/licensing/elastic-license
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

statement ok
set enable_experimental_table_ref=1;

statement ok
CREATE OR REPLACE DATABASE test_table_ref;

statement ok
use test_table_ref;

statement ok
CREATE TABLE t1 (a Int32, b Int32);

query I
insert into t1 values(1, 1),(2, 2);
----
2

statement ok
alter table t1 create branch dev;

query T
explain select * from t1/dev;
----
TableScan
├── table: default.test_table_ref.t1/dev
├── scan id: 0
├── output columns: [a (#0), b (#1)]
├── read rows: 2
├── read size: < 1 KiB
├── partitions total: 1
├── partitions scanned: 1
├── pruning stats: [segments: <range pruning: 1 to 1 cost: <slt:ignore>>, blocks: <range pruning: 1 to 1 cost: <slt:ignore>>]
├── push downs: [filters: [], limit: NONE]
└── estimated rows: 2.00

query I
insert into t1 values(3, 3);
----
1

statement ok
create table t2(a int32, b int32);

query I
insert into t2 values(2, 1);
----
1

query T
explain merge into t2 using (select * from t1/dev) as t1 on t1.a = t2.a when matched then update * when not matched then insert *;
----
CommitSink
└── DataMutation
    ├── target table: default.test_table_ref.t2
    └── MutationManipulate
        ├── matched update: [condition: None, update set a = if(CAST(_predicate (#18446744073709551615) AS Boolean NULL), a (#0), t2.a (#2)),b = if(CAST(_predicate (#18446744073709551615) AS Boolean NULL), b (#1), t2.b (#3))]
        ├── unmatched insert: [condition: None, insert into (a,b) values(a (#0),b (#1))]
        └── RowFetch
            ├── output columns: [t1.a (#0), t1.b (#1), t2.a (#2), t2._row_id (#4), t2.b (#3)]
            ├── columns to fetch: [b]
            └── HashJoin
                ├── output columns: [t1.a (#0), t1.b (#1), t2.a (#2), t2._row_id (#4)]
                ├── join type: LEFT OUTER
                ├── build keys: [t2.a (#2)]
                ├── probe keys: [t1.a (#0)]
                ├── keys is null equal: [false]
                ├── filters: []
                ├── estimated rows: 2.00
                ├── TableScan(Build)
                │   ├── table: default.test_table_ref.t2
                │   ├── scan id: 1
                │   ├── output columns: [a (#2), _row_id (#4)]
                │   ├── read rows: 1
                │   ├── read size: < 1 KiB
                │   ├── partitions total: 1
                │   ├── partitions scanned: 1
                │   ├── pruning stats: [segments: <range pruning: 1 to 1 cost: <slt:ignore>>, blocks: <range pruning: 1 to 1 cost: <slt:ignore>>]
                │   ├── push downs: [filters: [], limit: NONE]
                │   └── estimated rows: 1.00
                └── TableScan(Probe)
                    ├── table: default.test_table_ref.t1/dev
                    ├── scan id: 0
                    ├── output columns: [a (#0), b (#1)]
                    ├── read rows: 2
                    ├── read size: < 1 KiB
                    ├── partitions total: 1
                    ├── partitions scanned: 1
                    ├── pruning stats: [segments: <range pruning: 1 to 1 cost: <slt:ignore>>, blocks: <range pruning: 1 to 1 cost: <slt:ignore>>]
                    ├── push downs: [filters: [], limit: NONE]
                    └── estimated rows: 2.00

query II
merge into t2 using (select * from t1/dev) as t1 on t1.a = t2.a when matched then update * when not matched then insert *;
----
1 1

query II
select * from t2 order by a;
----
1 1
2 2

statement ok
DROP DATABASE test_table_ref;
