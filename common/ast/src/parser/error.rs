// Copyright 2022 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fmt::Write;

use logos::Span;

use crate::parser::token::*;
use crate::parser::util::Input;

const MAX_DISPLAY_ERROR_COUNT: usize = 5;

/// This error type accumulates errors and their position when backtracking
/// through a parse tree. This take a deepest error at `alt` combinator.
#[derive(Clone, Debug, PartialEq)]
pub struct Error<'a> {
    /// The next token when encountering an error.
    pub span: Token<'a>,
    /// List of errors tried in various branches that consumed
    /// the same (farthest) length of input.
    pub errors: Vec<ErrorKind>,
    /// The backtrace stack of the error.
    pub contexts: Vec<(Token<'a>, &'static str)>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum ErrorKind {
    /// Error generated by `match_token` function
    ExpectToken(TokenKind),
    /// Error generated by `match_text` function
    ExpectText(&'static str),
    /// Error generated by std's number parser
    ParseIntError(std::num::ParseIntError),
    /// Plain text description of an error
    Other(&'static str),
}

impl<'a> nom::error::ParseError<Input<'a>> for Error<'a> {
    fn from_error_kind(input: Input<'a>, _: nom::error::ErrorKind) -> Self {
        Error {
            span: input[0].clone(),
            errors: vec![],
            contexts: vec![],
        }
    }

    fn append(_: Input<'a>, _: nom::error::ErrorKind, other: Self) -> Self {
        other
    }

    fn from_char(_: Input<'a>, _: char) -> Self {
        unreachable!()
    }

    // Select the farthest parse tree while brancing by the `alt` function.
    fn or(mut self, mut other: Self) -> Self {
        if self.span.span.start == other.span.span.start {
            self.errors.append(&mut other.errors);
            self.contexts.clear();
            self
        } else if other.span.span.start > self.span.span.start {
            other
        } else {
            self
        }
    }
}

impl<'a> nom::error::ContextError<Input<'a>> for Error<'a> {
    fn add_context(input: Input<'a>, ctx: &'static str, mut other: Self) -> Self {
        other.contexts.push((input[0].clone(), ctx));
        other
    }
}

impl<'a> Error<'a> {
    pub fn from_error_kind(input: Input<'a>, kind: ErrorKind) -> Self {
        Error {
            span: input[0].clone(),
            errors: vec![kind],
            contexts: vec![],
        }
    }

    pub fn to_labels(&self) -> Vec<(Span, String)> {
        let mut expected_tokens = self
            .errors
            .iter()
            .filter_map(|kind| {
                if let ErrorKind::ExpectToken(token) = kind {
                    if token.is_keyword() {
                        Some(format!("`{:?}`", token))
                    } else {
                        Some(format!("<{:?}>", token))
                    }
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
        let mut expected_text = self
            .errors
            .iter()
            .filter_map(|kind| {
                if let ErrorKind::ExpectText(text) = kind {
                    Some(format!("{:?}", text))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        expected_tokens.sort();
        expected_tokens.dedup();
        expected_text.sort();
        expected_text.dedup();

        let msg: String = if expected_tokens.len() + expected_text.len() > 0 {
            let mut msg = String::new();
            let mut iter = expected_tokens
                .iter()
                .chain(&expected_text)
                .enumerate()
                .peekable();
            while let Some((i, error)) = iter.next() {
                if i == MAX_DISPLAY_ERROR_COUNT {
                    let more = (expected_tokens.len() + expected_text.len())
                        .saturating_sub(MAX_DISPLAY_ERROR_COUNT);
                    write!(msg, ", or {} more ...", more).unwrap();
                    break;
                } else if i == 0 {
                    msg += "expected ";
                } else if iter.peek().is_none() && i == 1 {
                    msg += " or ";
                } else if iter.peek().is_none() {
                    msg += ", or ";
                } else {
                    msg += ", ";
                }
                msg += error;
            }
            msg
        } else {
            match &self.errors[0] {
                ErrorKind::ExpectToken(_) => unreachable!(),
                ErrorKind::ExpectText(_) => unreachable!(),
                ErrorKind::ParseIntError(err) => {
                    format!("unable to parse int because it {}", match err.kind() {
                        std::num::IntErrorKind::InvalidDigit =>
                            "contains invalid characters".to_string(),
                        std::num::IntErrorKind::PosOverflow => "positive overflowed".to_string(),
                        std::num::IntErrorKind::NegOverflow => "negative overflowed".to_string(),
                        err => format!("{:?}", err),
                    })
                }
                ErrorKind::Other(msg) => msg.to_string(),
            }
        };

        let mut labels = vec![(self.span.span.clone(), msg)];
        labels.extend(
            self.contexts
                .iter()
                .map(|(span, msg)| (span.span.clone(), format!("while parsing {}", msg))),
        );
        labels
    }
}

pub fn pretty_print_error(source: &str, lables: Vec<(Span, String)>) -> String {
    use codespan_reporting::diagnostic::Diagnostic;
    use codespan_reporting::diagnostic::Label;
    use codespan_reporting::files::SimpleFile;
    use codespan_reporting::term;
    use codespan_reporting::term::termcolor::Buffer;
    use codespan_reporting::term::Chars;
    use codespan_reporting::term::Config;

    let mut writer = Buffer::no_color();
    let file = SimpleFile::new("SQL", source);
    let config = Config {
        chars: Chars::ascii(),
        before_label_lines: 3,
        ..Default::default()
    };

    let lables = lables
        .into_iter()
        .enumerate()
        .map(|(i, (span, msg))| {
            if i == 0 {
                Label::primary((), span).with_message(msg)
            } else {
                Label::secondary((), span).with_message(msg)
            }
        })
        .collect();

    let diagnostic = Diagnostic::error().with_labels(lables);

    term::emit(&mut writer, &config, &file, &diagnostic).unwrap();

    std::str::from_utf8(&writer.into_inner())
        .unwrap()
        .to_string()
}
