// Copyright 2022 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use super::fb303;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HiveObjectType(pub i32);

impl HiveObjectType {
  pub const GLOBAL: HiveObjectType = HiveObjectType(1);
  pub const DATABASE: HiveObjectType = HiveObjectType(2);
  pub const TABLE: HiveObjectType = HiveObjectType(3);
  pub const PARTITION: HiveObjectType = HiveObjectType(4);
  pub const COLUMN: HiveObjectType = HiveObjectType(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GLOBAL,
    Self::DATABASE,
    Self::TABLE,
    Self::PARTITION,
    Self::COLUMN,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HiveObjectType> {
    let enum_value = i_prot.read_i32()?;
    Ok(HiveObjectType::from(enum_value))
  }
}

impl From<i32> for HiveObjectType {
  fn from(i: i32) -> Self {
    match i {
      1 => HiveObjectType::GLOBAL,
      2 => HiveObjectType::DATABASE,
      3 => HiveObjectType::TABLE,
      4 => HiveObjectType::PARTITION,
      5 => HiveObjectType::COLUMN,
      _ => HiveObjectType(i)
    }
  }
}

impl From<&i32> for HiveObjectType {
  fn from(i: &i32) -> Self {
    HiveObjectType::from(*i)
  }
}

impl From<HiveObjectType> for i32 {
  fn from(e: HiveObjectType) -> i32 {
    e.0
  }
}

impl From<&HiveObjectType> for i32 {
  fn from(e: &HiveObjectType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrincipalType(pub i32);

impl PrincipalType {
  pub const USER: PrincipalType = PrincipalType(1);
  pub const ROLE: PrincipalType = PrincipalType(2);
  pub const GROUP: PrincipalType = PrincipalType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::USER,
    Self::ROLE,
    Self::GROUP,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrincipalType> {
    let enum_value = i_prot.read_i32()?;
    Ok(PrincipalType::from(enum_value))
  }
}

impl From<i32> for PrincipalType {
  fn from(i: i32) -> Self {
    match i {
      1 => PrincipalType::USER,
      2 => PrincipalType::ROLE,
      3 => PrincipalType::GROUP,
      _ => PrincipalType(i)
    }
  }
}

impl From<&i32> for PrincipalType {
  fn from(i: &i32) -> Self {
    PrincipalType::from(*i)
  }
}

impl From<PrincipalType> for i32 {
  fn from(e: PrincipalType) -> i32 {
    e.0
  }
}

impl From<&PrincipalType> for i32 {
  fn from(e: &PrincipalType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionEventType(pub i32);

impl PartitionEventType {
  pub const LOAD_DONE: PartitionEventType = PartitionEventType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LOAD_DONE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionEventType> {
    let enum_value = i_prot.read_i32()?;
    Ok(PartitionEventType::from(enum_value))
  }
}

impl From<i32> for PartitionEventType {
  fn from(i: i32) -> Self {
    match i {
      1 => PartitionEventType::LOAD_DONE,
      _ => PartitionEventType(i)
    }
  }
}

impl From<&i32> for PartitionEventType {
  fn from(i: &i32) -> Self {
    PartitionEventType::from(*i)
  }
}

impl From<PartitionEventType> for i32 {
  fn from(e: PartitionEventType) -> i32 {
    e.0
  }
}

impl From<&PartitionEventType> for i32 {
  fn from(e: &PartitionEventType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TxnState(pub i32);

impl TxnState {
  pub const COMMITTED: TxnState = TxnState(1);
  pub const ABORTED: TxnState = TxnState(2);
  pub const OPEN: TxnState = TxnState(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COMMITTED,
    Self::ABORTED,
    Self::OPEN,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TxnState> {
    let enum_value = i_prot.read_i32()?;
    Ok(TxnState::from(enum_value))
  }
}

impl From<i32> for TxnState {
  fn from(i: i32) -> Self {
    match i {
      1 => TxnState::COMMITTED,
      2 => TxnState::ABORTED,
      3 => TxnState::OPEN,
      _ => TxnState(i)
    }
  }
}

impl From<&i32> for TxnState {
  fn from(i: &i32) -> Self {
    TxnState::from(*i)
  }
}

impl From<TxnState> for i32 {
  fn from(e: TxnState) -> i32 {
    e.0
  }
}

impl From<&TxnState> for i32 {
  fn from(e: &TxnState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LockLevel(pub i32);

impl LockLevel {
  pub const DB: LockLevel = LockLevel(1);
  pub const TABLE: LockLevel = LockLevel(2);
  pub const PARTITION: LockLevel = LockLevel(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DB,
    Self::TABLE,
    Self::PARTITION,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LockLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(LockLevel::from(enum_value))
  }
}

impl From<i32> for LockLevel {
  fn from(i: i32) -> Self {
    match i {
      1 => LockLevel::DB,
      2 => LockLevel::TABLE,
      3 => LockLevel::PARTITION,
      _ => LockLevel(i)
    }
  }
}

impl From<&i32> for LockLevel {
  fn from(i: &i32) -> Self {
    LockLevel::from(*i)
  }
}

impl From<LockLevel> for i32 {
  fn from(e: LockLevel) -> i32 {
    e.0
  }
}

impl From<&LockLevel> for i32 {
  fn from(e: &LockLevel) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LockState(pub i32);

impl LockState {
  pub const ACQUIRED: LockState = LockState(1);
  pub const WAITING: LockState = LockState(2);
  pub const ABORT: LockState = LockState(3);
  pub const NOT_ACQUIRED: LockState = LockState(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ACQUIRED,
    Self::WAITING,
    Self::ABORT,
    Self::NOT_ACQUIRED,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LockState> {
    let enum_value = i_prot.read_i32()?;
    Ok(LockState::from(enum_value))
  }
}

impl From<i32> for LockState {
  fn from(i: i32) -> Self {
    match i {
      1 => LockState::ACQUIRED,
      2 => LockState::WAITING,
      3 => LockState::ABORT,
      4 => LockState::NOT_ACQUIRED,
      _ => LockState(i)
    }
  }
}

impl From<&i32> for LockState {
  fn from(i: &i32) -> Self {
    LockState::from(*i)
  }
}

impl From<LockState> for i32 {
  fn from(e: LockState) -> i32 {
    e.0
  }
}

impl From<&LockState> for i32 {
  fn from(e: &LockState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LockType(pub i32);

impl LockType {
  pub const SHARED_READ: LockType = LockType(1);
  pub const SHARED_WRITE: LockType = LockType(2);
  pub const EXCLUSIVE: LockType = LockType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SHARED_READ,
    Self::SHARED_WRITE,
    Self::EXCLUSIVE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LockType> {
    let enum_value = i_prot.read_i32()?;
    Ok(LockType::from(enum_value))
  }
}

impl From<i32> for LockType {
  fn from(i: i32) -> Self {
    match i {
      1 => LockType::SHARED_READ,
      2 => LockType::SHARED_WRITE,
      3 => LockType::EXCLUSIVE,
      _ => LockType(i)
    }
  }
}

impl From<&i32> for LockType {
  fn from(i: &i32) -> Self {
    LockType::from(*i)
  }
}

impl From<LockType> for i32 {
  fn from(e: LockType) -> i32 {
    e.0
  }
}

impl From<&LockType> for i32 {
  fn from(e: &LockType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactionType(pub i32);

impl CompactionType {
  pub const MINOR: CompactionType = CompactionType(1);
  pub const MAJOR: CompactionType = CompactionType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MINOR,
    Self::MAJOR,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompactionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(CompactionType::from(enum_value))
  }
}

impl From<i32> for CompactionType {
  fn from(i: i32) -> Self {
    match i {
      1 => CompactionType::MINOR,
      2 => CompactionType::MAJOR,
      _ => CompactionType(i)
    }
  }
}

impl From<&i32> for CompactionType {
  fn from(i: &i32) -> Self {
    CompactionType::from(*i)
  }
}

impl From<CompactionType> for i32 {
  fn from(e: CompactionType) -> i32 {
    e.0
  }
}

impl From<&CompactionType> for i32 {
  fn from(e: &CompactionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GrantRevokeType(pub i32);

impl GrantRevokeType {
  pub const GRANT: GrantRevokeType = GrantRevokeType(1);
  pub const REVOKE: GrantRevokeType = GrantRevokeType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GRANT,
    Self::REVOKE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GrantRevokeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(GrantRevokeType::from(enum_value))
  }
}

impl From<i32> for GrantRevokeType {
  fn from(i: i32) -> Self {
    match i {
      1 => GrantRevokeType::GRANT,
      2 => GrantRevokeType::REVOKE,
      _ => GrantRevokeType(i)
    }
  }
}

impl From<&i32> for GrantRevokeType {
  fn from(i: &i32) -> Self {
    GrantRevokeType::from(*i)
  }
}

impl From<GrantRevokeType> for i32 {
  fn from(e: GrantRevokeType) -> i32 {
    e.0
  }
}

impl From<&GrantRevokeType> for i32 {
  fn from(e: &GrantRevokeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataOperationType(pub i32);

impl DataOperationType {
  pub const SELECT: DataOperationType = DataOperationType(1);
  pub const INSERT: DataOperationType = DataOperationType(2);
  pub const UPDATE: DataOperationType = DataOperationType(3);
  pub const DELETE: DataOperationType = DataOperationType(4);
  pub const UNSET: DataOperationType = DataOperationType(5);
  pub const NO_TXN: DataOperationType = DataOperationType(6);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SELECT,
    Self::INSERT,
    Self::UPDATE,
    Self::DELETE,
    Self::UNSET,
    Self::NO_TXN,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DataOperationType> {
    let enum_value = i_prot.read_i32()?;
    Ok(DataOperationType::from(enum_value))
  }
}

impl From<i32> for DataOperationType {
  fn from(i: i32) -> Self {
    match i {
      1 => DataOperationType::SELECT,
      2 => DataOperationType::INSERT,
      3 => DataOperationType::UPDATE,
      4 => DataOperationType::DELETE,
      5 => DataOperationType::UNSET,
      6 => DataOperationType::NO_TXN,
      _ => DataOperationType(i)
    }
  }
}

impl From<&i32> for DataOperationType {
  fn from(i: &i32) -> Self {
    DataOperationType::from(*i)
  }
}

impl From<DataOperationType> for i32 {
  fn from(e: DataOperationType) -> i32 {
    e.0
  }
}

impl From<&DataOperationType> for i32 {
  fn from(e: &DataOperationType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EventRequestType(pub i32);

impl EventRequestType {
  pub const INSERT: EventRequestType = EventRequestType(1);
  pub const UPDATE: EventRequestType = EventRequestType(2);
  pub const DELETE: EventRequestType = EventRequestType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INSERT,
    Self::UPDATE,
    Self::DELETE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EventRequestType> {
    let enum_value = i_prot.read_i32()?;
    Ok(EventRequestType::from(enum_value))
  }
}

impl From<i32> for EventRequestType {
  fn from(i: i32) -> Self {
    match i {
      1 => EventRequestType::INSERT,
      2 => EventRequestType::UPDATE,
      3 => EventRequestType::DELETE,
      _ => EventRequestType(i)
    }
  }
}

impl From<&i32> for EventRequestType {
  fn from(i: &i32) -> Self {
    EventRequestType::from(*i)
  }
}

impl From<EventRequestType> for i32 {
  fn from(e: EventRequestType) -> i32 {
    e.0
  }
}

impl From<&EventRequestType> for i32 {
  fn from(e: &EventRequestType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SerdeType(pub i32);

impl SerdeType {
  pub const HIVE: SerdeType = SerdeType(1);
  pub const SCHEMA_REGISTRY: SerdeType = SerdeType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HIVE,
    Self::SCHEMA_REGISTRY,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SerdeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(SerdeType::from(enum_value))
  }
}

impl From<i32> for SerdeType {
  fn from(i: i32) -> Self {
    match i {
      1 => SerdeType::HIVE,
      2 => SerdeType::SCHEMA_REGISTRY,
      _ => SerdeType(i)
    }
  }
}

impl From<&i32> for SerdeType {
  fn from(i: &i32) -> Self {
    SerdeType::from(*i)
  }
}

impl From<SerdeType> for i32 {
  fn from(e: SerdeType) -> i32 {
    e.0
  }
}

impl From<&SerdeType> for i32 {
  fn from(e: &SerdeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaType(pub i32);

impl SchemaType {
  pub const HIVE: SchemaType = SchemaType(1);
  pub const AVRO: SchemaType = SchemaType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HIVE,
    Self::AVRO,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaType> {
    let enum_value = i_prot.read_i32()?;
    Ok(SchemaType::from(enum_value))
  }
}

impl From<i32> for SchemaType {
  fn from(i: i32) -> Self {
    match i {
      1 => SchemaType::HIVE,
      2 => SchemaType::AVRO,
      _ => SchemaType(i)
    }
  }
}

impl From<&i32> for SchemaType {
  fn from(i: &i32) -> Self {
    SchemaType::from(*i)
  }
}

impl From<SchemaType> for i32 {
  fn from(e: SchemaType) -> i32 {
    e.0
  }
}

impl From<&SchemaType> for i32 {
  fn from(e: &SchemaType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaCompatibility(pub i32);

impl SchemaCompatibility {
  pub const NONE: SchemaCompatibility = SchemaCompatibility(1);
  pub const BACKWARD: SchemaCompatibility = SchemaCompatibility(2);
  pub const FORWARD: SchemaCompatibility = SchemaCompatibility(3);
  pub const BOTH: SchemaCompatibility = SchemaCompatibility(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::BACKWARD,
    Self::FORWARD,
    Self::BOTH,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaCompatibility> {
    let enum_value = i_prot.read_i32()?;
    Ok(SchemaCompatibility::from(enum_value))
  }
}

impl From<i32> for SchemaCompatibility {
  fn from(i: i32) -> Self {
    match i {
      1 => SchemaCompatibility::NONE,
      2 => SchemaCompatibility::BACKWARD,
      3 => SchemaCompatibility::FORWARD,
      4 => SchemaCompatibility::BOTH,
      _ => SchemaCompatibility(i)
    }
  }
}

impl From<&i32> for SchemaCompatibility {
  fn from(i: &i32) -> Self {
    SchemaCompatibility::from(*i)
  }
}

impl From<SchemaCompatibility> for i32 {
  fn from(e: SchemaCompatibility) -> i32 {
    e.0
  }
}

impl From<&SchemaCompatibility> for i32 {
  fn from(e: &SchemaCompatibility) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaValidation(pub i32);

impl SchemaValidation {
  pub const LATEST: SchemaValidation = SchemaValidation(1);
  pub const ALL: SchemaValidation = SchemaValidation(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LATEST,
    Self::ALL,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaValidation> {
    let enum_value = i_prot.read_i32()?;
    Ok(SchemaValidation::from(enum_value))
  }
}

impl From<i32> for SchemaValidation {
  fn from(i: i32) -> Self {
    match i {
      1 => SchemaValidation::LATEST,
      2 => SchemaValidation::ALL,
      _ => SchemaValidation(i)
    }
  }
}

impl From<&i32> for SchemaValidation {
  fn from(i: &i32) -> Self {
    SchemaValidation::from(*i)
  }
}

impl From<SchemaValidation> for i32 {
  fn from(e: SchemaValidation) -> i32 {
    e.0
  }
}

impl From<&SchemaValidation> for i32 {
  fn from(e: &SchemaValidation) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaVersionState(pub i32);

impl SchemaVersionState {
  pub const INITIATED: SchemaVersionState = SchemaVersionState(1);
  pub const START_REVIEW: SchemaVersionState = SchemaVersionState(2);
  pub const CHANGES_REQUIRED: SchemaVersionState = SchemaVersionState(3);
  pub const REVIEWED: SchemaVersionState = SchemaVersionState(4);
  pub const ENABLED: SchemaVersionState = SchemaVersionState(5);
  pub const DISABLED: SchemaVersionState = SchemaVersionState(6);
  pub const ARCHIVED: SchemaVersionState = SchemaVersionState(7);
  pub const DELETED: SchemaVersionState = SchemaVersionState(8);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INITIATED,
    Self::START_REVIEW,
    Self::CHANGES_REQUIRED,
    Self::REVIEWED,
    Self::ENABLED,
    Self::DISABLED,
    Self::ARCHIVED,
    Self::DELETED,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaVersionState> {
    let enum_value = i_prot.read_i32()?;
    Ok(SchemaVersionState::from(enum_value))
  }
}

impl From<i32> for SchemaVersionState {
  fn from(i: i32) -> Self {
    match i {
      1 => SchemaVersionState::INITIATED,
      2 => SchemaVersionState::START_REVIEW,
      3 => SchemaVersionState::CHANGES_REQUIRED,
      4 => SchemaVersionState::REVIEWED,
      5 => SchemaVersionState::ENABLED,
      6 => SchemaVersionState::DISABLED,
      7 => SchemaVersionState::ARCHIVED,
      8 => SchemaVersionState::DELETED,
      _ => SchemaVersionState(i)
    }
  }
}

impl From<&i32> for SchemaVersionState {
  fn from(i: &i32) -> Self {
    SchemaVersionState::from(*i)
  }
}

impl From<SchemaVersionState> for i32 {
  fn from(e: SchemaVersionState) -> i32 {
    e.0
  }
}

impl From<&SchemaVersionState> for i32 {
  fn from(e: &SchemaVersionState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FunctionType(pub i32);

impl FunctionType {
  pub const JAVA: FunctionType = FunctionType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::JAVA,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FunctionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(FunctionType::from(enum_value))
  }
}

impl From<i32> for FunctionType {
  fn from(i: i32) -> Self {
    match i {
      1 => FunctionType::JAVA,
      _ => FunctionType(i)
    }
  }
}

impl From<&i32> for FunctionType {
  fn from(i: &i32) -> Self {
    FunctionType::from(*i)
  }
}

impl From<FunctionType> for i32 {
  fn from(e: FunctionType) -> i32 {
    e.0
  }
}

impl From<&FunctionType> for i32 {
  fn from(e: &FunctionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResourceType(pub i32);

impl ResourceType {
  pub const JAR: ResourceType = ResourceType(1);
  pub const FILE: ResourceType = ResourceType(2);
  pub const ARCHIVE: ResourceType = ResourceType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::JAR,
    Self::FILE,
    Self::ARCHIVE,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResourceType> {
    let enum_value = i_prot.read_i32()?;
    Ok(ResourceType::from(enum_value))
  }
}

impl From<i32> for ResourceType {
  fn from(i: i32) -> Self {
    match i {
      1 => ResourceType::JAR,
      2 => ResourceType::FILE,
      3 => ResourceType::ARCHIVE,
      _ => ResourceType(i)
    }
  }
}

impl From<&i32> for ResourceType {
  fn from(i: &i32) -> Self {
    ResourceType::from(*i)
  }
}

impl From<ResourceType> for i32 {
  fn from(e: ResourceType) -> i32 {
    e.0
  }
}

impl From<&ResourceType> for i32 {
  fn from(e: &ResourceType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FileMetadataExprType(pub i32);

impl FileMetadataExprType {
  pub const ORC_SARG: FileMetadataExprType = FileMetadataExprType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ORC_SARG,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FileMetadataExprType> {
    let enum_value = i_prot.read_i32()?;
    Ok(FileMetadataExprType::from(enum_value))
  }
}

impl From<i32> for FileMetadataExprType {
  fn from(i: i32) -> Self {
    match i {
      1 => FileMetadataExprType::ORC_SARG,
      _ => FileMetadataExprType(i)
    }
  }
}

impl From<&i32> for FileMetadataExprType {
  fn from(i: &i32) -> Self {
    FileMetadataExprType::from(*i)
  }
}

impl From<FileMetadataExprType> for i32 {
  fn from(e: FileMetadataExprType) -> i32 {
    e.0
  }
}

impl From<&FileMetadataExprType> for i32 {
  fn from(e: &FileMetadataExprType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientCapability(pub i32);

impl ClientCapability {
  pub const TEST_CAPABILITY: ClientCapability = ClientCapability(1);
  pub const INSERT_ONLY_TABLES: ClientCapability = ClientCapability(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TEST_CAPABILITY,
    Self::INSERT_ONLY_TABLES,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientCapability> {
    let enum_value = i_prot.read_i32()?;
    Ok(ClientCapability::from(enum_value))
  }
}

impl From<i32> for ClientCapability {
  fn from(i: i32) -> Self {
    match i {
      1 => ClientCapability::TEST_CAPABILITY,
      2 => ClientCapability::INSERT_ONLY_TABLES,
      _ => ClientCapability(i)
    }
  }
}

impl From<&i32> for ClientCapability {
  fn from(i: &i32) -> Self {
    ClientCapability::from(*i)
  }
}

impl From<ClientCapability> for i32 {
  fn from(e: ClientCapability) -> i32 {
    e.0
  }
}

impl From<&ClientCapability> for i32 {
  fn from(e: &ClientCapability) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMResourcePlanStatus(pub i32);

impl WMResourcePlanStatus {
  pub const ACTIVE: WMResourcePlanStatus = WMResourcePlanStatus(1);
  pub const ENABLED: WMResourcePlanStatus = WMResourcePlanStatus(2);
  pub const DISABLED: WMResourcePlanStatus = WMResourcePlanStatus(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ACTIVE,
    Self::ENABLED,
    Self::DISABLED,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMResourcePlanStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(WMResourcePlanStatus::from(enum_value))
  }
}

impl From<i32> for WMResourcePlanStatus {
  fn from(i: i32) -> Self {
    match i {
      1 => WMResourcePlanStatus::ACTIVE,
      2 => WMResourcePlanStatus::ENABLED,
      3 => WMResourcePlanStatus::DISABLED,
      _ => WMResourcePlanStatus(i)
    }
  }
}

impl From<&i32> for WMResourcePlanStatus {
  fn from(i: &i32) -> Self {
    WMResourcePlanStatus::from(*i)
  }
}

impl From<WMResourcePlanStatus> for i32 {
  fn from(e: WMResourcePlanStatus) -> i32 {
    e.0
  }
}

impl From<&WMResourcePlanStatus> for i32 {
  fn from(e: &WMResourcePlanStatus) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMPoolSchedulingPolicy(pub i32);

impl WMPoolSchedulingPolicy {
  pub const FAIR: WMPoolSchedulingPolicy = WMPoolSchedulingPolicy(1);
  pub const FIFO: WMPoolSchedulingPolicy = WMPoolSchedulingPolicy(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FAIR,
    Self::FIFO,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMPoolSchedulingPolicy> {
    let enum_value = i_prot.read_i32()?;
    Ok(WMPoolSchedulingPolicy::from(enum_value))
  }
}

impl From<i32> for WMPoolSchedulingPolicy {
  fn from(i: i32) -> Self {
    match i {
      1 => WMPoolSchedulingPolicy::FAIR,
      2 => WMPoolSchedulingPolicy::FIFO,
      _ => WMPoolSchedulingPolicy(i)
    }
  }
}

impl From<&i32> for WMPoolSchedulingPolicy {
  fn from(i: &i32) -> Self {
    WMPoolSchedulingPolicy::from(*i)
  }
}

impl From<WMPoolSchedulingPolicy> for i32 {
  fn from(e: WMPoolSchedulingPolicy) -> i32 {
    e.0
  }
}

impl From<&WMPoolSchedulingPolicy> for i32 {
  fn from(e: &WMPoolSchedulingPolicy) -> i32 {
    e.0
  }
}

//
// Version
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version {
  pub version: Option<String>,
  pub comments: Option<String>,
}

impl Version {
  pub fn new<F1, F2>(version: F1, comments: F2) -> Version where F1: Into<Option<String>>, F2: Into<Option<String>> {
    Version {
      version: version.into(),
      comments: comments.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Version> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Version {
      version: f_1,
      comments: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Version");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comments {
      o_prot.write_field_begin(&TFieldIdentifier::new("comments", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Version {
  fn default() -> Self {
    Version{
      version: Some("".to_owned()),
      comments: Some("".to_owned()),
    }
  }
}

//
// FieldSchema
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FieldSchema {
  pub name: Option<String>,
  pub type_: Option<String>,
  pub comment: Option<String>,
}

impl FieldSchema {
  pub fn new<F1, F2, F3>(name: F1, type_: F2, comment: F3) -> FieldSchema where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    FieldSchema {
      name: name.into(),
      type_: type_.into(),
      comment: comment.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FieldSchema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FieldSchema {
      name: f_1,
      type_: f_2,
      comment: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FieldSchema");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comment {
      o_prot.write_field_begin(&TFieldIdentifier::new("comment", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FieldSchema {
  fn default() -> Self {
    FieldSchema{
      name: Some("".to_owned()),
      type_: Some("".to_owned()),
      comment: Some("".to_owned()),
    }
  }
}

//
// SQLPrimaryKey
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SQLPrimaryKey {
  pub table_db: Option<String>,
  pub table_name: Option<String>,
  pub column_name: Option<String>,
  pub key_seq: Option<i32>,
  pub pk_name: Option<String>,
  pub enable_cstr: Option<bool>,
  pub validate_cstr: Option<bool>,
  pub rely_cstr: Option<bool>,
  pub cat_name: Option<String>,
}

impl SQLPrimaryKey {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(table_db: F1, table_name: F2, column_name: F3, key_seq: F4, pk_name: F5, enable_cstr: F6, validate_cstr: F7, rely_cstr: F8, cat_name: F9) -> SQLPrimaryKey where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<String>> {
    SQLPrimaryKey {
      table_db: table_db.into(),
      table_name: table_name.into(),
      column_name: column_name.into(),
      key_seq: key_seq.into(),
      pk_name: pk_name.into(),
      enable_cstr: enable_cstr.into(),
      validate_cstr: validate_cstr.into(),
      rely_cstr: rely_cstr.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SQLPrimaryKey> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SQLPrimaryKey {
      table_db: f_1,
      table_name: f_2,
      column_name: f_3,
      key_seq: f_4,
      pk_name: f_5,
      enable_cstr: f_6,
      validate_cstr: f_7,
      rely_cstr: f_8,
      cat_name: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SQLPrimaryKey");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.table_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.key_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_seq", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pk_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("pk_name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_cstr", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.validate_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("validate_cstr", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rely_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("rely_cstr", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SQLPrimaryKey {
  fn default() -> Self {
    SQLPrimaryKey{
      table_db: Some("".to_owned()),
      table_name: Some("".to_owned()),
      column_name: Some("".to_owned()),
      key_seq: Some(0),
      pk_name: Some("".to_owned()),
      enable_cstr: Some(false),
      validate_cstr: Some(false),
      rely_cstr: Some(false),
      cat_name: Some("".to_owned()),
    }
  }
}

//
// SQLForeignKey
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SQLForeignKey {
  pub pktable_db: Option<String>,
  pub pktable_name: Option<String>,
  pub pkcolumn_name: Option<String>,
  pub fktable_db: Option<String>,
  pub fktable_name: Option<String>,
  pub fkcolumn_name: Option<String>,
  pub key_seq: Option<i32>,
  pub update_rule: Option<i32>,
  pub delete_rule: Option<i32>,
  pub fk_name: Option<String>,
  pub pk_name: Option<String>,
  pub enable_cstr: Option<bool>,
  pub validate_cstr: Option<bool>,
  pub rely_cstr: Option<bool>,
  pub cat_name: Option<String>,
}

impl SQLForeignKey {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15>(pktable_db: F1, pktable_name: F2, pkcolumn_name: F3, fktable_db: F4, fktable_name: F5, fkcolumn_name: F6, key_seq: F7, update_rule: F8, delete_rule: F9, fk_name: F10, pk_name: F11, enable_cstr: F12, validate_cstr: F13, rely_cstr: F14, cat_name: F15) -> SQLForeignKey where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<i32>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<String>> {
    SQLForeignKey {
      pktable_db: pktable_db.into(),
      pktable_name: pktable_name.into(),
      pkcolumn_name: pkcolumn_name.into(),
      fktable_db: fktable_db.into(),
      fktable_name: fktable_name.into(),
      fkcolumn_name: fkcolumn_name.into(),
      key_seq: key_seq.into(),
      update_rule: update_rule.into(),
      delete_rule: delete_rule.into(),
      fk_name: fk_name.into(),
      pk_name: pk_name.into(),
      enable_cstr: enable_cstr.into(),
      validate_cstr: validate_cstr.into(),
      rely_cstr: rely_cstr.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SQLForeignKey> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<i32> = Some(0);
    let mut f_8: Option<i32> = Some(0);
    let mut f_9: Option<i32> = Some(0);
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<bool> = Some(false);
    let mut f_13: Option<bool> = Some(false);
    let mut f_14: Option<bool> = Some(false);
    let mut f_15: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SQLForeignKey {
      pktable_db: f_1,
      pktable_name: f_2,
      pkcolumn_name: f_3,
      fktable_db: f_4,
      fktable_name: f_5,
      fkcolumn_name: f_6,
      key_seq: f_7,
      update_rule: f_8,
      delete_rule: f_9,
      fk_name: f_10,
      pk_name: f_11,
      enable_cstr: f_12,
      validate_cstr: f_13,
      rely_cstr: f_14,
      cat_name: f_15,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SQLForeignKey");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pktable_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("pktable_db", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pktable_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("pktable_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pkcolumn_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("pkcolumn_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fktable_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("fktable_db", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fktable_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("fktable_name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fkcolumn_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("fkcolumn_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.key_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_seq", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_rule {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_rule", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delete_rule {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_rule", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fk_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("fk_name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pk_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("pk_name", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_cstr", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.validate_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("validate_cstr", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rely_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("rely_cstr", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SQLForeignKey {
  fn default() -> Self {
    SQLForeignKey{
      pktable_db: Some("".to_owned()),
      pktable_name: Some("".to_owned()),
      pkcolumn_name: Some("".to_owned()),
      fktable_db: Some("".to_owned()),
      fktable_name: Some("".to_owned()),
      fkcolumn_name: Some("".to_owned()),
      key_seq: Some(0),
      update_rule: Some(0),
      delete_rule: Some(0),
      fk_name: Some("".to_owned()),
      pk_name: Some("".to_owned()),
      enable_cstr: Some(false),
      validate_cstr: Some(false),
      rely_cstr: Some(false),
      cat_name: Some("".to_owned()),
    }
  }
}

//
// SQLUniqueConstraint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SQLUniqueConstraint {
  pub cat_name: Option<String>,
  pub table_db: Option<String>,
  pub table_name: Option<String>,
  pub column_name: Option<String>,
  pub key_seq: Option<i32>,
  pub uk_name: Option<String>,
  pub enable_cstr: Option<bool>,
  pub validate_cstr: Option<bool>,
  pub rely_cstr: Option<bool>,
}

impl SQLUniqueConstraint {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(cat_name: F1, table_db: F2, table_name: F3, column_name: F4, key_seq: F5, uk_name: F6, enable_cstr: F7, validate_cstr: F8, rely_cstr: F9) -> SQLUniqueConstraint where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<i32>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>> {
    SQLUniqueConstraint {
      cat_name: cat_name.into(),
      table_db: table_db.into(),
      table_name: table_name.into(),
      column_name: column_name.into(),
      key_seq: key_seq.into(),
      uk_name: uk_name.into(),
      enable_cstr: enable_cstr.into(),
      validate_cstr: validate_cstr.into(),
      rely_cstr: rely_cstr.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SQLUniqueConstraint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SQLUniqueConstraint {
      cat_name: f_1,
      table_db: f_2,
      table_name: f_3,
      column_name: f_4,
      key_seq: f_5,
      uk_name: f_6,
      enable_cstr: f_7,
      validate_cstr: f_8,
      rely_cstr: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SQLUniqueConstraint");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_db", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.key_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_seq", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.uk_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("uk_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_cstr", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.validate_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("validate_cstr", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rely_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("rely_cstr", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SQLUniqueConstraint {
  fn default() -> Self {
    SQLUniqueConstraint{
      cat_name: Some("".to_owned()),
      table_db: Some("".to_owned()),
      table_name: Some("".to_owned()),
      column_name: Some("".to_owned()),
      key_seq: Some(0),
      uk_name: Some("".to_owned()),
      enable_cstr: Some(false),
      validate_cstr: Some(false),
      rely_cstr: Some(false),
    }
  }
}

//
// SQLNotNullConstraint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SQLNotNullConstraint {
  pub cat_name: Option<String>,
  pub table_db: Option<String>,
  pub table_name: Option<String>,
  pub column_name: Option<String>,
  pub nn_name: Option<String>,
  pub enable_cstr: Option<bool>,
  pub validate_cstr: Option<bool>,
  pub rely_cstr: Option<bool>,
}

impl SQLNotNullConstraint {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(cat_name: F1, table_db: F2, table_name: F3, column_name: F4, nn_name: F5, enable_cstr: F6, validate_cstr: F7, rely_cstr: F8) -> SQLNotNullConstraint where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    SQLNotNullConstraint {
      cat_name: cat_name.into(),
      table_db: table_db.into(),
      table_name: table_name.into(),
      column_name: column_name.into(),
      nn_name: nn_name.into(),
      enable_cstr: enable_cstr.into(),
      validate_cstr: validate_cstr.into(),
      rely_cstr: rely_cstr.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SQLNotNullConstraint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SQLNotNullConstraint {
      cat_name: f_1,
      table_db: f_2,
      table_name: f_3,
      column_name: f_4,
      nn_name: f_5,
      enable_cstr: f_6,
      validate_cstr: f_7,
      rely_cstr: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SQLNotNullConstraint");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_db", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nn_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("nn_name", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_cstr", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.validate_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("validate_cstr", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rely_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("rely_cstr", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SQLNotNullConstraint {
  fn default() -> Self {
    SQLNotNullConstraint{
      cat_name: Some("".to_owned()),
      table_db: Some("".to_owned()),
      table_name: Some("".to_owned()),
      column_name: Some("".to_owned()),
      nn_name: Some("".to_owned()),
      enable_cstr: Some(false),
      validate_cstr: Some(false),
      rely_cstr: Some(false),
    }
  }
}

//
// SQLDefaultConstraint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SQLDefaultConstraint {
  pub cat_name: Option<String>,
  pub table_db: Option<String>,
  pub table_name: Option<String>,
  pub column_name: Option<String>,
  pub default_value: Option<String>,
  pub dc_name: Option<String>,
  pub enable_cstr: Option<bool>,
  pub validate_cstr: Option<bool>,
  pub rely_cstr: Option<bool>,
}

impl SQLDefaultConstraint {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(cat_name: F1, table_db: F2, table_name: F3, column_name: F4, default_value: F5, dc_name: F6, enable_cstr: F7, validate_cstr: F8, rely_cstr: F9) -> SQLDefaultConstraint where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>> {
    SQLDefaultConstraint {
      cat_name: cat_name.into(),
      table_db: table_db.into(),
      table_name: table_name.into(),
      column_name: column_name.into(),
      default_value: default_value.into(),
      dc_name: dc_name.into(),
      enable_cstr: enable_cstr.into(),
      validate_cstr: validate_cstr.into(),
      rely_cstr: rely_cstr.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SQLDefaultConstraint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SQLDefaultConstraint {
      cat_name: f_1,
      table_db: f_2,
      table_name: f_3,
      column_name: f_4,
      default_value: f_5,
      dc_name: f_6,
      enable_cstr: f_7,
      validate_cstr: f_8,
      rely_cstr: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SQLDefaultConstraint");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_db", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_value", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dc_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dc_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_cstr", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.validate_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("validate_cstr", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rely_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("rely_cstr", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SQLDefaultConstraint {
  fn default() -> Self {
    SQLDefaultConstraint{
      cat_name: Some("".to_owned()),
      table_db: Some("".to_owned()),
      table_name: Some("".to_owned()),
      column_name: Some("".to_owned()),
      default_value: Some("".to_owned()),
      dc_name: Some("".to_owned()),
      enable_cstr: Some(false),
      validate_cstr: Some(false),
      rely_cstr: Some(false),
    }
  }
}

//
// SQLCheckConstraint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SQLCheckConstraint {
  pub cat_name: Option<String>,
  pub table_db: Option<String>,
  pub table_name: Option<String>,
  pub column_name: Option<String>,
  pub check_expression: Option<String>,
  pub dc_name: Option<String>,
  pub enable_cstr: Option<bool>,
  pub validate_cstr: Option<bool>,
  pub rely_cstr: Option<bool>,
}

impl SQLCheckConstraint {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(cat_name: F1, table_db: F2, table_name: F3, column_name: F4, check_expression: F5, dc_name: F6, enable_cstr: F7, validate_cstr: F8, rely_cstr: F9) -> SQLCheckConstraint where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>> {
    SQLCheckConstraint {
      cat_name: cat_name.into(),
      table_db: table_db.into(),
      table_name: table_name.into(),
      column_name: column_name.into(),
      check_expression: check_expression.into(),
      dc_name: dc_name.into(),
      enable_cstr: enable_cstr.into(),
      validate_cstr: validate_cstr.into(),
      rely_cstr: rely_cstr.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SQLCheckConstraint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SQLCheckConstraint {
      cat_name: f_1,
      table_db: f_2,
      table_name: f_3,
      column_name: f_4,
      check_expression: f_5,
      dc_name: f_6,
      enable_cstr: f_7,
      validate_cstr: f_8,
      rely_cstr: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SQLCheckConstraint");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_db {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_db", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.check_expression {
      o_prot.write_field_begin(&TFieldIdentifier::new("check_expression", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dc_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dc_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_cstr", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.validate_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("validate_cstr", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rely_cstr {
      o_prot.write_field_begin(&TFieldIdentifier::new("rely_cstr", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SQLCheckConstraint {
  fn default() -> Self {
    SQLCheckConstraint{
      cat_name: Some("".to_owned()),
      table_db: Some("".to_owned()),
      table_name: Some("".to_owned()),
      column_name: Some("".to_owned()),
      check_expression: Some("".to_owned()),
      dc_name: Some("".to_owned()),
      enable_cstr: Some(false),
      validate_cstr: Some(false),
      rely_cstr: Some(false),
    }
  }
}

//
// Type
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Type {
  pub name: Option<String>,
  pub type1: Option<String>,
  pub type2: Option<String>,
  pub fields: Option<Vec<FieldSchema>>,
}

impl Type {
  pub fn new<F1, F2, F3, F4>(name: F1, type1: F2, type2: F3, fields: F4) -> Type where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<FieldSchema>>> {
    Type {
      name: name.into(),
      type1: type1.into(),
      type2: type2.into(),
      fields: fields.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Type> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<FieldSchema>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Type {
      name: f_1,
      type1: f_2,
      type2: f_3,
      fields: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Type");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("type1", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("type2", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Type {
  fn default() -> Self {
    Type{
      name: Some("".to_owned()),
      type1: Some("".to_owned()),
      type2: Some("".to_owned()),
      fields: Some(Vec::new()),
    }
  }
}

//
// HiveObjectRef
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HiveObjectRef {
  pub object_type: Option<HiveObjectType>,
  pub db_name: Option<String>,
  pub object_name: Option<String>,
  pub part_values: Option<Vec<String>>,
  pub column_name: Option<String>,
  pub cat_name: Option<String>,
}

impl HiveObjectRef {
  pub fn new<F1, F2, F3, F4, F5, F6>(object_type: F1, db_name: F2, object_name: F3, part_values: F4, column_name: F5, cat_name: F6) -> HiveObjectRef where F1: Into<Option<HiveObjectType>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<String>>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    HiveObjectRef {
      object_type: object_type.into(),
      db_name: db_name.into(),
      object_name: object_name.into(),
      part_values: part_values.into(),
      column_name: column_name.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HiveObjectRef> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<HiveObjectType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<Vec<String>> = Some(Vec::new());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = HiveObjectType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HiveObjectRef {
      object_type: f_1,
      db_name: f_2,
      object_name: f_3,
      part_values: f_4,
      column_name: f_5,
      cat_name: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HiveObjectRef");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.object_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.object_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("objectName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.part_values {
      o_prot.write_field_begin(&TFieldIdentifier::new("partValues", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for HiveObjectRef {
  fn default() -> Self {
    HiveObjectRef{
      object_type: None,
      db_name: Some("".to_owned()),
      object_name: Some("".to_owned()),
      part_values: Some(Vec::new()),
      column_name: Some("".to_owned()),
      cat_name: Some("".to_owned()),
    }
  }
}

//
// PrivilegeGrantInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrivilegeGrantInfo {
  pub privilege: Option<String>,
  pub create_time: Option<i32>,
  pub grantor: Option<String>,
  pub grantor_type: Option<PrincipalType>,
  pub grant_option: Option<bool>,
}

impl PrivilegeGrantInfo {
  pub fn new<F1, F2, F3, F4, F5>(privilege: F1, create_time: F2, grantor: F3, grantor_type: F4, grant_option: F5) -> PrivilegeGrantInfo where F1: Into<Option<String>>, F2: Into<Option<i32>>, F3: Into<Option<String>>, F4: Into<Option<PrincipalType>>, F5: Into<Option<bool>> {
    PrivilegeGrantInfo {
      privilege: privilege.into(),
      create_time: create_time.into(),
      grantor: grantor.into(),
      grantor_type: grantor_type.into(),
      grant_option: grant_option.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrivilegeGrantInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<PrincipalType> = None;
    let mut f_5: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PrivilegeGrantInfo {
      privilege: f_1,
      create_time: f_2,
      grantor: f_3,
      grantor_type: f_4,
      grant_option: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrivilegeGrantInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.privilege {
      o_prot.write_field_begin(&TFieldIdentifier::new("privilege", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantor {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantor", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantor_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantorType", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.grant_option {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantOption", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PrivilegeGrantInfo {
  fn default() -> Self {
    PrivilegeGrantInfo{
      privilege: Some("".to_owned()),
      create_time: Some(0),
      grantor: Some("".to_owned()),
      grantor_type: None,
      grant_option: Some(false),
    }
  }
}

//
// HiveObjectPrivilege
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HiveObjectPrivilege {
  pub hive_object: Option<HiveObjectRef>,
  pub principal_name: Option<String>,
  pub principal_type: Option<PrincipalType>,
  pub grant_info: Option<PrivilegeGrantInfo>,
  pub authorizer: Option<String>,
}

impl HiveObjectPrivilege {
  pub fn new<F1, F2, F3, F4, F5>(hive_object: F1, principal_name: F2, principal_type: F3, grant_info: F4, authorizer: F5) -> HiveObjectPrivilege where F1: Into<Option<HiveObjectRef>>, F2: Into<Option<String>>, F3: Into<Option<PrincipalType>>, F4: Into<Option<PrivilegeGrantInfo>>, F5: Into<Option<String>> {
    HiveObjectPrivilege {
      hive_object: hive_object.into(),
      principal_name: principal_name.into(),
      principal_type: principal_type.into(),
      grant_info: grant_info.into(),
      authorizer: authorizer.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HiveObjectPrivilege> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<HiveObjectRef> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<PrincipalType> = None;
    let mut f_4: Option<PrivilegeGrantInfo> = None;
    let mut f_5: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = HiveObjectRef::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = PrivilegeGrantInfo::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HiveObjectPrivilege {
      hive_object: f_1,
      principal_name: f_2,
      principal_type: f_3,
      grant_info: f_4,
      authorizer: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HiveObjectPrivilege");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hive_object {
      o_prot.write_field_begin(&TFieldIdentifier::new("hiveObject", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.principal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("principalName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.principal_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("principalType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grant_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantInfo", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.authorizer {
      o_prot.write_field_begin(&TFieldIdentifier::new("authorizer", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for HiveObjectPrivilege {
  fn default() -> Self {
    HiveObjectPrivilege{
      hive_object: None,
      principal_name: Some("".to_owned()),
      principal_type: None,
      grant_info: None,
      authorizer: Some("".to_owned()),
    }
  }
}

//
// PrivilegeBag
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrivilegeBag {
  pub privileges: Option<Vec<HiveObjectPrivilege>>,
}

impl PrivilegeBag {
  pub fn new<F1>(privileges: F1) -> PrivilegeBag where F1: Into<Option<Vec<HiveObjectPrivilege>>> {
    PrivilegeBag {
      privileges: privileges.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrivilegeBag> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<HiveObjectPrivilege>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<HiveObjectPrivilege> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = HiveObjectPrivilege::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PrivilegeBag {
      privileges: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrivilegeBag");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PrivilegeBag {
  fn default() -> Self {
    PrivilegeBag{
      privileges: Some(Vec::new()),
    }
  }
}

//
// PrincipalPrivilegeSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrincipalPrivilegeSet {
  pub user_privileges: Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>>,
  pub group_privileges: Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>>,
  pub role_privileges: Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>>,
}

impl PrincipalPrivilegeSet {
  pub fn new<F1, F2, F3>(user_privileges: F1, group_privileges: F2, role_privileges: F3) -> PrincipalPrivilegeSet where F1: Into<Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>>>, F2: Into<Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>>>, F3: Into<Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>>> {
    PrincipalPrivilegeSet {
      user_privileges: user_privileges.into(),
      group_privileges: group_privileges.into(),
      role_privileges: role_privileges.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrincipalPrivilegeSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>> = Some(BTreeMap::new());
    let mut f_2: Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>> = Some(BTreeMap::new());
    let mut f_3: Option<BTreeMap<String, Vec<PrivilegeGrantInfo>>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<PrivilegeGrantInfo>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_4: Vec<PrivilegeGrantInfo> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_5 = PrivilegeGrantInfo::read_from_in_protocol(i_prot)?;
              map_val_4.push(list_elem_5);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<PrivilegeGrantInfo>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_6 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_7: Vec<PrivilegeGrantInfo> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_8 = PrivilegeGrantInfo::read_from_in_protocol(i_prot)?;
              map_val_7.push(list_elem_8);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_6, map_val_7);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<PrivilegeGrantInfo>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_10: Vec<PrivilegeGrantInfo> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_11 = PrivilegeGrantInfo::read_from_in_protocol(i_prot)?;
              map_val_10.push(list_elem_11);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PrincipalPrivilegeSet {
      user_privileges: f_1,
      group_privileges: f_2,
      role_privileges: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrincipalPrivilegeSet");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("userPrivileges", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.group_privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("groupPrivileges", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.role_privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("rolePrivileges", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PrincipalPrivilegeSet {
  fn default() -> Self {
    PrincipalPrivilegeSet{
      user_privileges: Some(BTreeMap::new()),
      group_privileges: Some(BTreeMap::new()),
      role_privileges: Some(BTreeMap::new()),
    }
  }
}

//
// GrantRevokePrivilegeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GrantRevokePrivilegeRequest {
  pub request_type: Option<GrantRevokeType>,
  pub privileges: Option<PrivilegeBag>,
  pub revoke_grant_option: Option<bool>,
}

impl GrantRevokePrivilegeRequest {
  pub fn new<F1, F2, F3>(request_type: F1, privileges: F2, revoke_grant_option: F3) -> GrantRevokePrivilegeRequest where F1: Into<Option<GrantRevokeType>>, F2: Into<Option<PrivilegeBag>>, F3: Into<Option<bool>> {
    GrantRevokePrivilegeRequest {
      request_type: request_type.into(),
      privileges: privileges.into(),
      revoke_grant_option: revoke_grant_option.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GrantRevokePrivilegeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GrantRevokeType> = None;
    let mut f_2: Option<PrivilegeBag> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GrantRevokeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = PrivilegeBag::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GrantRevokePrivilegeRequest {
      request_type: f_1,
      privileges: f_2,
      revoke_grant_option: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GrantRevokePrivilegeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.revoke_grant_option {
      o_prot.write_field_begin(&TFieldIdentifier::new("revokeGrantOption", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GrantRevokePrivilegeRequest {
  fn default() -> Self {
    GrantRevokePrivilegeRequest{
      request_type: None,
      privileges: None,
      revoke_grant_option: Some(false),
    }
  }
}

//
// GrantRevokePrivilegeResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GrantRevokePrivilegeResponse {
  pub success: Option<bool>,
}

impl GrantRevokePrivilegeResponse {
  pub fn new<F1>(success: F1) -> GrantRevokePrivilegeResponse where F1: Into<Option<bool>> {
    GrantRevokePrivilegeResponse {
      success: success.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GrantRevokePrivilegeResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GrantRevokePrivilegeResponse {
      success: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GrantRevokePrivilegeResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GrantRevokePrivilegeResponse {
  fn default() -> Self {
    GrantRevokePrivilegeResponse{
      success: Some(false),
    }
  }
}

//
// Role
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Role {
  pub role_name: Option<String>,
  pub create_time: Option<i32>,
  pub owner_name: Option<String>,
}

impl Role {
  pub fn new<F1, F2, F3>(role_name: F1, create_time: F2, owner_name: F3) -> Role where F1: Into<Option<String>>, F2: Into<Option<i32>>, F3: Into<Option<String>> {
    Role {
      role_name: role_name.into(),
      create_time: create_time.into(),
      owner_name: owner_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Role> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Role {
      role_name: f_1,
      create_time: f_2,
      owner_name: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Role");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.role_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Role {
  fn default() -> Self {
    Role{
      role_name: Some("".to_owned()),
      create_time: Some(0),
      owner_name: Some("".to_owned()),
    }
  }
}

//
// RolePrincipalGrant
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RolePrincipalGrant {
  pub role_name: Option<String>,
  pub principal_name: Option<String>,
  pub principal_type: Option<PrincipalType>,
  pub grant_option: Option<bool>,
  pub grant_time: Option<i32>,
  pub grantor_name: Option<String>,
  pub grantor_principal_type: Option<PrincipalType>,
}

impl RolePrincipalGrant {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(role_name: F1, principal_name: F2, principal_type: F3, grant_option: F4, grant_time: F5, grantor_name: F6, grantor_principal_type: F7) -> RolePrincipalGrant where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<PrincipalType>>, F4: Into<Option<bool>>, F5: Into<Option<i32>>, F6: Into<Option<String>>, F7: Into<Option<PrincipalType>> {
    RolePrincipalGrant {
      role_name: role_name.into(),
      principal_name: principal_name.into(),
      principal_type: principal_type.into(),
      grant_option: grant_option.into(),
      grant_time: grant_time.into(),
      grantor_name: grantor_name.into(),
      grantor_principal_type: grantor_principal_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RolePrincipalGrant> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<PrincipalType> = None;
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<PrincipalType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RolePrincipalGrant {
      role_name: f_1,
      principal_name: f_2,
      principal_type: f_3,
      grant_option: f_4,
      grant_time: f_5,
      grantor_name: f_6,
      grantor_principal_type: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RolePrincipalGrant");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.role_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.principal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("principalName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.principal_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("principalType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.grant_option {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantOption", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.grant_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantTime", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantor_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantorName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantor_principal_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantorPrincipalType", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RolePrincipalGrant {
  fn default() -> Self {
    RolePrincipalGrant{
      role_name: Some("".to_owned()),
      principal_name: Some("".to_owned()),
      principal_type: None,
      grant_option: Some(false),
      grant_time: Some(0),
      grantor_name: Some("".to_owned()),
      grantor_principal_type: None,
    }
  }
}

//
// GetRoleGrantsForPrincipalRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetRoleGrantsForPrincipalRequest {
  pub principal_name: String,
  pub principal_type: PrincipalType,
}

impl GetRoleGrantsForPrincipalRequest {
  pub fn new(principal_name: String, principal_type: PrincipalType) -> GetRoleGrantsForPrincipalRequest {
    GetRoleGrantsForPrincipalRequest {
      principal_name,
      principal_type,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetRoleGrantsForPrincipalRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<PrincipalType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetRoleGrantsForPrincipalRequest.principal_name", &f_1)?;
    verify_required_field_exists("GetRoleGrantsForPrincipalRequest.principal_type", &f_2)?;
    let ret = GetRoleGrantsForPrincipalRequest {
      principal_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      principal_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetRoleGrantsForPrincipalRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_name", TType::String, 1))?;
    o_prot.write_string(&self.principal_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_type", TType::I32, 2))?;
    self.principal_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetRoleGrantsForPrincipalResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetRoleGrantsForPrincipalResponse {
  pub principal_grants: Vec<RolePrincipalGrant>,
}

impl GetRoleGrantsForPrincipalResponse {
  pub fn new(principal_grants: Vec<RolePrincipalGrant>) -> GetRoleGrantsForPrincipalResponse {
    GetRoleGrantsForPrincipalResponse {
      principal_grants,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetRoleGrantsForPrincipalResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<RolePrincipalGrant>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<RolePrincipalGrant> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = RolePrincipalGrant::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetRoleGrantsForPrincipalResponse.principal_grants", &f_1)?;
    let ret = GetRoleGrantsForPrincipalResponse {
      principal_grants: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetRoleGrantsForPrincipalResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principalGrants", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.principal_grants.len() as i32))?;
    for e in &self.principal_grants {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetPrincipalsInRoleRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetPrincipalsInRoleRequest {
  pub role_name: String,
}

impl GetPrincipalsInRoleRequest {
  pub fn new(role_name: String) -> GetPrincipalsInRoleRequest {
    GetPrincipalsInRoleRequest {
      role_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetPrincipalsInRoleRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetPrincipalsInRoleRequest.role_name", &f_1)?;
    let ret = GetPrincipalsInRoleRequest {
      role_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetPrincipalsInRoleRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 1))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetPrincipalsInRoleResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetPrincipalsInRoleResponse {
  pub principal_grants: Vec<RolePrincipalGrant>,
}

impl GetPrincipalsInRoleResponse {
  pub fn new(principal_grants: Vec<RolePrincipalGrant>) -> GetPrincipalsInRoleResponse {
    GetPrincipalsInRoleResponse {
      principal_grants,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetPrincipalsInRoleResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<RolePrincipalGrant>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<RolePrincipalGrant> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = RolePrincipalGrant::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetPrincipalsInRoleResponse.principal_grants", &f_1)?;
    let ret = GetPrincipalsInRoleResponse {
      principal_grants: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetPrincipalsInRoleResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principalGrants", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.principal_grants.len() as i32))?;
    for e in &self.principal_grants {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GrantRevokeRoleRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GrantRevokeRoleRequest {
  pub request_type: Option<GrantRevokeType>,
  pub role_name: Option<String>,
  pub principal_name: Option<String>,
  pub principal_type: Option<PrincipalType>,
  pub grantor: Option<String>,
  pub grantor_type: Option<PrincipalType>,
  pub grant_option: Option<bool>,
}

impl GrantRevokeRoleRequest {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(request_type: F1, role_name: F2, principal_name: F3, principal_type: F4, grantor: F5, grantor_type: F6, grant_option: F7) -> GrantRevokeRoleRequest where F1: Into<Option<GrantRevokeType>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<PrincipalType>>, F5: Into<Option<String>>, F6: Into<Option<PrincipalType>>, F7: Into<Option<bool>> {
    GrantRevokeRoleRequest {
      request_type: request_type.into(),
      role_name: role_name.into(),
      principal_name: principal_name.into(),
      principal_type: principal_type.into(),
      grantor: grantor.into(),
      grantor_type: grantor_type.into(),
      grant_option: grant_option.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GrantRevokeRoleRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GrantRevokeType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<PrincipalType> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<PrincipalType> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GrantRevokeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GrantRevokeRoleRequest {
      request_type: f_1,
      role_name: f_2,
      principal_name: f_3,
      principal_type: f_4,
      grantor: f_5,
      grantor_type: f_6,
      grant_option: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GrantRevokeRoleRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.role_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("roleName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.principal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("principalName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.principal_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("principalType", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantor {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantor", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.grantor_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantorType", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.grant_option {
      o_prot.write_field_begin(&TFieldIdentifier::new("grantOption", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GrantRevokeRoleRequest {
  fn default() -> Self {
    GrantRevokeRoleRequest{
      request_type: None,
      role_name: Some("".to_owned()),
      principal_name: Some("".to_owned()),
      principal_type: None,
      grantor: Some("".to_owned()),
      grantor_type: None,
      grant_option: Some(false),
    }
  }
}

//
// GrantRevokeRoleResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GrantRevokeRoleResponse {
  pub success: Option<bool>,
}

impl GrantRevokeRoleResponse {
  pub fn new<F1>(success: F1) -> GrantRevokeRoleResponse where F1: Into<Option<bool>> {
    GrantRevokeRoleResponse {
      success: success.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GrantRevokeRoleResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GrantRevokeRoleResponse {
      success: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GrantRevokeRoleResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.success {
      o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GrantRevokeRoleResponse {
  fn default() -> Self {
    GrantRevokeRoleResponse{
      success: Some(false),
    }
  }
}

//
// Catalog
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Catalog {
  pub name: Option<String>,
  pub description: Option<String>,
  pub location_uri: Option<String>,
}

impl Catalog {
  pub fn new<F1, F2, F3>(name: F1, description: F2, location_uri: F3) -> Catalog where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    Catalog {
      name: name.into(),
      description: description.into(),
      location_uri: location_uri.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Catalog> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Catalog {
      name: f_1,
      description: f_2,
      location_uri: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Catalog");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.location_uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("locationUri", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Catalog {
  fn default() -> Self {
    Catalog{
      name: Some("".to_owned()),
      description: Some("".to_owned()),
      location_uri: Some("".to_owned()),
    }
  }
}

//
// CreateCatalogRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CreateCatalogRequest {
  pub catalog: Option<Catalog>,
}

impl CreateCatalogRequest {
  pub fn new<F1>(catalog: F1) -> CreateCatalogRequest where F1: Into<Option<Catalog>> {
    CreateCatalogRequest {
      catalog: catalog.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CreateCatalogRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Catalog> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Catalog::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CreateCatalogRequest {
      catalog: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CreateCatalogRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CreateCatalogRequest {
  fn default() -> Self {
    CreateCatalogRequest{
      catalog: None,
    }
  }
}

//
// AlterCatalogRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AlterCatalogRequest {
  pub name: Option<String>,
  pub new_cat: Option<Catalog>,
}

impl AlterCatalogRequest {
  pub fn new<F1, F2>(name: F1, new_cat: F2) -> AlterCatalogRequest where F1: Into<Option<String>>, F2: Into<Option<Catalog>> {
    AlterCatalogRequest {
      name: name.into(),
      new_cat: new_cat.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AlterCatalogRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Catalog> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Catalog::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AlterCatalogRequest {
      name: f_1,
      new_cat: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AlterCatalogRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.new_cat {
      o_prot.write_field_begin(&TFieldIdentifier::new("newCat", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AlterCatalogRequest {
  fn default() -> Self {
    AlterCatalogRequest{
      name: Some("".to_owned()),
      new_cat: None,
    }
  }
}

//
// GetCatalogRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCatalogRequest {
  pub name: Option<String>,
}

impl GetCatalogRequest {
  pub fn new<F1>(name: F1) -> GetCatalogRequest where F1: Into<Option<String>> {
    GetCatalogRequest {
      name: name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCatalogRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCatalogRequest {
      name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCatalogRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetCatalogRequest {
  fn default() -> Self {
    GetCatalogRequest{
      name: Some("".to_owned()),
    }
  }
}

//
// GetCatalogResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCatalogResponse {
  pub catalog: Option<Catalog>,
}

impl GetCatalogResponse {
  pub fn new<F1>(catalog: F1) -> GetCatalogResponse where F1: Into<Option<Catalog>> {
    GetCatalogResponse {
      catalog: catalog.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCatalogResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Catalog> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Catalog::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCatalogResponse {
      catalog: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCatalogResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetCatalogResponse {
  fn default() -> Self {
    GetCatalogResponse{
      catalog: None,
    }
  }
}

//
// GetCatalogsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCatalogsResponse {
  pub names: Option<Vec<String>>,
}

impl GetCatalogsResponse {
  pub fn new<F1>(names: F1) -> GetCatalogsResponse where F1: Into<Option<Vec<String>>> {
    GetCatalogsResponse {
      names: names.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCatalogsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = i_prot.read_string()?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCatalogsResponse {
      names: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCatalogsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.names {
      o_prot.write_field_begin(&TFieldIdentifier::new("names", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetCatalogsResponse {
  fn default() -> Self {
    GetCatalogsResponse{
      names: Some(Vec::new()),
    }
  }
}

//
// DropCatalogRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DropCatalogRequest {
  pub name: Option<String>,
}

impl DropCatalogRequest {
  pub fn new<F1>(name: F1) -> DropCatalogRequest where F1: Into<Option<String>> {
    DropCatalogRequest {
      name: name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DropCatalogRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DropCatalogRequest {
      name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DropCatalogRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for DropCatalogRequest {
  fn default() -> Self {
    DropCatalogRequest{
      name: Some("".to_owned()),
    }
  }
}

//
// Database
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Database {
  pub name: Option<String>,
  pub description: Option<String>,
  pub location_uri: Option<String>,
  pub parameters: Option<BTreeMap<String, String>>,
  pub privileges: Option<PrincipalPrivilegeSet>,
  pub owner_name: Option<String>,
  pub owner_type: Option<PrincipalType>,
  pub catalog_name: Option<String>,
}

impl Database {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(name: F1, description: F2, location_uri: F3, parameters: F4, privileges: F5, owner_name: F6, owner_type: F7, catalog_name: F8) -> Database where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<BTreeMap<String, String>>>, F5: Into<Option<PrincipalPrivilegeSet>>, F6: Into<Option<String>>, F7: Into<Option<PrincipalType>>, F8: Into<Option<String>> {
    Database {
      name: name.into(),
      description: description.into(),
      location_uri: location_uri.into(),
      parameters: parameters.into(),
      privileges: privileges.into(),
      owner_name: owner_name.into(),
      owner_type: owner_type.into(),
      catalog_name: catalog_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Database> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_5: Option<PrincipalPrivilegeSet> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<PrincipalType> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_15 = i_prot.read_string()?;
            let map_val_16 = i_prot.read_string()?;
            val.insert(map_key_15, map_val_16);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = PrincipalPrivilegeSet::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Database {
      name: f_1,
      description: f_2,
      location_uri: f_3,
      parameters: f_4,
      privileges: f_5,
      owner_name: f_6,
      owner_type: f_7,
      catalog_name: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Database");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.location_uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("locationUri", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parameters {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerType", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalogName", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Database {
  fn default() -> Self {
    Database{
      name: Some("".to_owned()),
      description: Some("".to_owned()),
      location_uri: Some("".to_owned()),
      parameters: Some(BTreeMap::new()),
      privileges: None,
      owner_name: Some("".to_owned()),
      owner_type: None,
      catalog_name: Some("".to_owned()),
    }
  }
}

//
// SerDeInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SerDeInfo {
  pub name: Option<String>,
  pub serialization_lib: Option<String>,
  pub parameters: Option<BTreeMap<String, String>>,
  pub description: Option<String>,
  pub serializer_class: Option<String>,
  pub deserializer_class: Option<String>,
  pub serde_type: Option<SerdeType>,
}

impl SerDeInfo {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(name: F1, serialization_lib: F2, parameters: F3, description: F4, serializer_class: F5, deserializer_class: F6, serde_type: F7) -> SerDeInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<SerdeType>> {
    SerDeInfo {
      name: name.into(),
      serialization_lib: serialization_lib.into(),
      parameters: parameters.into(),
      description: description.into(),
      serializer_class: serializer_class.into(),
      deserializer_class: deserializer_class.into(),
      serde_type: serde_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SerDeInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<SerdeType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_17 = i_prot.read_string()?;
            let map_val_18 = i_prot.read_string()?;
            val.insert(map_key_17, map_val_18);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = SerdeType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SerDeInfo {
      name: f_1,
      serialization_lib: f_2,
      parameters: f_3,
      description: f_4,
      serializer_class: f_5,
      deserializer_class: f_6,
      serde_type: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SerDeInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serialization_lib {
      o_prot.write_field_begin(&TFieldIdentifier::new("serializationLib", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parameters {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serializer_class {
      o_prot.write_field_begin(&TFieldIdentifier::new("serializerClass", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.deserializer_class {
      o_prot.write_field_begin(&TFieldIdentifier::new("deserializerClass", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serde_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("serdeType", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SerDeInfo {
  fn default() -> Self {
    SerDeInfo{
      name: Some("".to_owned()),
      serialization_lib: Some("".to_owned()),
      parameters: Some(BTreeMap::new()),
      description: Some("".to_owned()),
      serializer_class: Some("".to_owned()),
      deserializer_class: Some("".to_owned()),
      serde_type: None,
    }
  }
}

//
// Order
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Order {
  pub col: Option<String>,
  pub order: Option<i32>,
}

impl Order {
  pub fn new<F1, F2>(col: F1, order: F2) -> Order where F1: Into<Option<String>>, F2: Into<Option<i32>> {
    Order {
      col: col.into(),
      order: order.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Order> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Order {
      col: f_1,
      order: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Order");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.col {
      o_prot.write_field_begin(&TFieldIdentifier::new("col", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.order {
      o_prot.write_field_begin(&TFieldIdentifier::new("order", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Order {
  fn default() -> Self {
    Order{
      col: Some("".to_owned()),
      order: Some(0),
    }
  }
}

//
// SkewedInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SkewedInfo {
  pub skewed_col_names: Option<Vec<String>>,
  pub skewed_col_values: Option<Vec<Vec<String>>>,
  pub skewed_col_value_location_maps: Option<BTreeMap<Vec<String>, String>>,
}

impl SkewedInfo {
  pub fn new<F1, F2, F3>(skewed_col_names: F1, skewed_col_values: F2, skewed_col_value_location_maps: F3) -> SkewedInfo where F1: Into<Option<Vec<String>>>, F2: Into<Option<Vec<Vec<String>>>>, F3: Into<Option<BTreeMap<Vec<String>, String>>> {
    SkewedInfo {
      skewed_col_names: skewed_col_names.into(),
      skewed_col_values: skewed_col_values.into(),
      skewed_col_value_location_maps: skewed_col_value_location_maps.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SkewedInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    let mut f_2: Option<Vec<Vec<String>>> = Some(Vec::new());
    let mut f_3: Option<BTreeMap<Vec<String>, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_20: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_21 = i_prot.read_string()?;
              list_elem_20.push(list_elem_21);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<Vec<String>, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut map_key_22: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_23 = i_prot.read_string()?;
              map_key_22.push(list_elem_23);
            }
            i_prot.read_list_end()?;
            let map_val_24 = i_prot.read_string()?;
            val.insert(map_key_22, map_val_24);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SkewedInfo {
      skewed_col_names: f_1,
      skewed_col_values: f_2,
      skewed_col_value_location_maps: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SkewedInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.skewed_col_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("skewedColNames", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.skewed_col_values {
      o_prot.write_field_begin(&TFieldIdentifier::new("skewedColValues", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
        for e in e {
          o_prot.write_string(e)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.skewed_col_value_location_maps {
      o_prot.write_field_begin(&TFieldIdentifier::new("skewedColValueLocationMaps", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::List, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::String, k.len() as i32))?;
        for e in k {
          o_prot.write_string(e)?;
        }
        o_prot.write_list_end()?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SkewedInfo {
  fn default() -> Self {
    SkewedInfo{
      skewed_col_names: Some(Vec::new()),
      skewed_col_values: Some(Vec::new()),
      skewed_col_value_location_maps: Some(BTreeMap::new()),
    }
  }
}

//
// StorageDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StorageDescriptor {
  pub cols: Option<Vec<FieldSchema>>,
  pub location: Option<String>,
  pub input_format: Option<String>,
  pub output_format: Option<String>,
  pub compressed: Option<bool>,
  pub num_buckets: Option<i32>,
  pub serde_info: Option<SerDeInfo>,
  pub bucket_cols: Option<Vec<String>>,
  pub sort_cols: Option<Vec<Order>>,
  pub parameters: Option<BTreeMap<String, String>>,
  pub skewed_info: Option<SkewedInfo>,
  pub stored_as_sub_directories: Option<bool>,
}

impl StorageDescriptor {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(cols: F1, location: F2, input_format: F3, output_format: F4, compressed: F5, num_buckets: F6, serde_info: F7, bucket_cols: F8, sort_cols: F9, parameters: F10, skewed_info: F11, stored_as_sub_directories: F12) -> StorageDescriptor where F1: Into<Option<Vec<FieldSchema>>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<i32>>, F7: Into<Option<SerDeInfo>>, F8: Into<Option<Vec<String>>>, F9: Into<Option<Vec<Order>>>, F10: Into<Option<BTreeMap<String, String>>>, F11: Into<Option<SkewedInfo>>, F12: Into<Option<bool>> {
    StorageDescriptor {
      cols: cols.into(),
      location: location.into(),
      input_format: input_format.into(),
      output_format: output_format.into(),
      compressed: compressed.into(),
      num_buckets: num_buckets.into(),
      serde_info: serde_info.into(),
      bucket_cols: bucket_cols.into(),
      sort_cols: sort_cols.into(),
      parameters: parameters.into(),
      skewed_info: skewed_info.into(),
      stored_as_sub_directories: stored_as_sub_directories.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StorageDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<FieldSchema>> = Some(Vec::new());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<SerDeInfo> = None;
    let mut f_8: Option<Vec<String>> = Some(Vec::new());
    let mut f_9: Option<Vec<Order>> = Some(Vec::new());
    let mut f_10: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_11: Option<SkewedInfo> = None;
    let mut f_12: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = SerDeInfo::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = i_prot.read_string()?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Order> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = Order::read_from_in_protocol(i_prot)?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_28 = i_prot.read_string()?;
            let map_val_29 = i_prot.read_string()?;
            val.insert(map_key_28, map_val_29);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        11 => {
          let val = SkewedInfo::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StorageDescriptor {
      cols: f_1,
      location: f_2,
      input_format: f_3,
      output_format: f_4,
      compressed: f_5,
      num_buckets: f_6,
      serde_info: f_7,
      bucket_cols: f_8,
      sort_cols: f_9,
      parameters: f_10,
      skewed_info: f_11,
      stored_as_sub_directories: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StorageDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.location {
      o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("inputFormat", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.output_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("outputFormat", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.compressed {
      o_prot.write_field_begin(&TFieldIdentifier::new("compressed", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_buckets {
      o_prot.write_field_begin(&TFieldIdentifier::new("numBuckets", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serde_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("serdeInfo", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bucket_cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("bucketCols", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sort_cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("sortCols", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parameters {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.skewed_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("skewedInfo", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.stored_as_sub_directories {
      o_prot.write_field_begin(&TFieldIdentifier::new("storedAsSubDirectories", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for StorageDescriptor {
  fn default() -> Self {
    StorageDescriptor{
      cols: Some(Vec::new()),
      location: Some("".to_owned()),
      input_format: Some("".to_owned()),
      output_format: Some("".to_owned()),
      compressed: Some(false),
      num_buckets: Some(0),
      serde_info: None,
      bucket_cols: Some(Vec::new()),
      sort_cols: Some(Vec::new()),
      parameters: Some(BTreeMap::new()),
      skewed_info: None,
      stored_as_sub_directories: Some(false),
    }
  }
}

//
// Table
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Table {
  pub table_name: Option<String>,
  pub db_name: Option<String>,
  pub owner: Option<String>,
  pub create_time: Option<i32>,
  pub last_access_time: Option<i32>,
  pub retention: Option<i32>,
  pub sd: Option<StorageDescriptor>,
  pub partition_keys: Option<Vec<FieldSchema>>,
  pub parameters: Option<BTreeMap<String, String>>,
  pub view_original_text: Option<String>,
  pub view_expanded_text: Option<String>,
  pub table_type: Option<String>,
  pub privileges: Option<PrincipalPrivilegeSet>,
  pub temporary: Option<bool>,
  pub rewrite_enabled: Option<bool>,
  pub creation_metadata: Option<Box<CreationMetadata>>,
  pub cat_name: Option<String>,
  pub owner_type: Option<PrincipalType>,
}

impl Table {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18>(table_name: F1, db_name: F2, owner: F3, create_time: F4, last_access_time: F5, retention: F6, sd: F7, partition_keys: F8, parameters: F9, view_original_text: F10, view_expanded_text: F11, table_type: F12, privileges: F13, temporary: F14, rewrite_enabled: F15, creation_metadata: F16, cat_name: F17, owner_type: F18) -> Table where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<StorageDescriptor>>, F8: Into<Option<Vec<FieldSchema>>>, F9: Into<Option<BTreeMap<String, String>>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>>, F13: Into<Option<PrincipalPrivilegeSet>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<Box<CreationMetadata>>>, F17: Into<Option<String>>, F18: Into<Option<PrincipalType>> {
    Table {
      table_name: table_name.into(),
      db_name: db_name.into(),
      owner: owner.into(),
      create_time: create_time.into(),
      last_access_time: last_access_time.into(),
      retention: retention.into(),
      sd: sd.into(),
      partition_keys: partition_keys.into(),
      parameters: parameters.into(),
      view_original_text: view_original_text.into(),
      view_expanded_text: view_expanded_text.into(),
      table_type: table_type.into(),
      privileges: privileges.into(),
      temporary: temporary.into(),
      rewrite_enabled: rewrite_enabled.into(),
      creation_metadata: creation_metadata.into(),
      cat_name: cat_name.into(),
      owner_type: owner_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Table> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<StorageDescriptor> = None;
    let mut f_8: Option<Vec<FieldSchema>> = Some(Vec::new());
    let mut f_9: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    let mut f_13: Option<PrincipalPrivilegeSet> = None;
    let mut f_14: Option<bool> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<Box<CreationMetadata>> = None;
    let mut f_17: Option<String> = None;
    let mut f_18: Option<PrincipalType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = StorageDescriptor::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_31 = i_prot.read_string()?;
            let map_val_32 = i_prot.read_string()?;
            val.insert(map_key_31, map_val_32);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = PrincipalPrivilegeSet::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = Box::new(CreationMetadata::read_from_in_protocol(i_prot)?);
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_string()?;
          f_17 = Some(val);
        },
        18 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Table {
      table_name: f_1,
      db_name: f_2,
      owner: f_3,
      create_time: f_4,
      last_access_time: f_5,
      retention: f_6,
      sd: f_7,
      partition_keys: f_8,
      parameters: f_9,
      view_original_text: f_10,
      view_expanded_text: f_11,
      table_type: f_12,
      privileges: f_13,
      temporary: f_14,
      rewrite_enabled: f_15,
      creation_metadata: f_16,
      cat_name: f_17,
      owner_type: f_18,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Table");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner {
      o_prot.write_field_begin(&TFieldIdentifier::new("owner", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_access_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastAccessTime", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.retention {
      o_prot.write_field_begin(&TFieldIdentifier::new("retention", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sd {
      o_prot.write_field_begin(&TFieldIdentifier::new("sd", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionKeys", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parameters {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.view_original_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("viewOriginalText", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.view_expanded_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("viewExpandedText", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableType", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.temporary {
      o_prot.write_field_begin(&TFieldIdentifier::new("temporary", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rewrite_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("rewriteEnabled", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.creation_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("creationMetadata", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 17))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerType", TType::I32, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Table {
  fn default() -> Self {
    Table{
      table_name: Some("".to_owned()),
      db_name: Some("".to_owned()),
      owner: Some("".to_owned()),
      create_time: Some(0),
      last_access_time: Some(0),
      retention: Some(0),
      sd: None,
      partition_keys: Some(Vec::new()),
      parameters: Some(BTreeMap::new()),
      view_original_text: Some("".to_owned()),
      view_expanded_text: Some("".to_owned()),
      table_type: Some("".to_owned()),
      privileges: None,
      temporary: Some(false),
      rewrite_enabled: Some(false),
      creation_metadata: None,
      cat_name: Some("".to_owned()),
      owner_type: None,
    }
  }
}

//
// Partition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Partition {
  pub values: Option<Vec<String>>,
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub create_time: Option<i32>,
  pub last_access_time: Option<i32>,
  pub sd: Option<StorageDescriptor>,
  pub parameters: Option<BTreeMap<String, String>>,
  pub privileges: Option<PrincipalPrivilegeSet>,
  pub cat_name: Option<String>,
}

impl Partition {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(values: F1, db_name: F2, table_name: F3, create_time: F4, last_access_time: F5, sd: F6, parameters: F7, privileges: F8, cat_name: F9) -> Partition where F1: Into<Option<Vec<String>>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<StorageDescriptor>>, F7: Into<Option<BTreeMap<String, String>>>, F8: Into<Option<PrincipalPrivilegeSet>>, F9: Into<Option<String>> {
    Partition {
      values: values.into(),
      db_name: db_name.into(),
      table_name: table_name.into(),
      create_time: create_time.into(),
      last_access_time: last_access_time.into(),
      sd: sd.into(),
      parameters: parameters.into(),
      privileges: privileges.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Partition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<StorageDescriptor> = None;
    let mut f_7: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_8: Option<PrincipalPrivilegeSet> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = i_prot.read_string()?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = StorageDescriptor::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_34 = i_prot.read_string()?;
            let map_val_35 = i_prot.read_string()?;
            val.insert(map_key_34, map_val_35);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = PrincipalPrivilegeSet::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Partition {
      values: f_1,
      db_name: f_2,
      table_name: f_3,
      create_time: f_4,
      last_access_time: f_5,
      sd: f_6,
      parameters: f_7,
      privileges: f_8,
      cat_name: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Partition");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_access_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastAccessTime", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sd {
      o_prot.write_field_begin(&TFieldIdentifier::new("sd", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parameters {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Map, 7))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Partition {
  fn default() -> Self {
    Partition{
      values: Some(Vec::new()),
      db_name: Some("".to_owned()),
      table_name: Some("".to_owned()),
      create_time: Some(0),
      last_access_time: Some(0),
      sd: None,
      parameters: Some(BTreeMap::new()),
      privileges: None,
      cat_name: Some("".to_owned()),
    }
  }
}

//
// PartitionWithoutSD
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionWithoutSD {
  pub values: Option<Vec<String>>,
  pub create_time: Option<i32>,
  pub last_access_time: Option<i32>,
  pub relative_path: Option<String>,
  pub parameters: Option<BTreeMap<String, String>>,
  pub privileges: Option<PrincipalPrivilegeSet>,
}

impl PartitionWithoutSD {
  pub fn new<F1, F2, F3, F4, F5, F6>(values: F1, create_time: F2, last_access_time: F3, relative_path: F4, parameters: F5, privileges: F6) -> PartitionWithoutSD where F1: Into<Option<Vec<String>>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<String>>, F5: Into<Option<BTreeMap<String, String>>>, F6: Into<Option<PrincipalPrivilegeSet>> {
    PartitionWithoutSD {
      values: values.into(),
      create_time: create_time.into(),
      last_access_time: last_access_time.into(),
      relative_path: relative_path.into(),
      parameters: parameters.into(),
      privileges: privileges.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionWithoutSD> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = Some(Vec::new());
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    let mut f_6: Option<PrincipalPrivilegeSet> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = i_prot.read_string()?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_37 = i_prot.read_string()?;
            let map_val_38 = i_prot.read_string()?;
            val.insert(map_key_37, map_val_38);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = PrincipalPrivilegeSet::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PartitionWithoutSD {
      values: f_1,
      create_time: f_2,
      last_access_time: f_3,
      relative_path: f_4,
      parameters: f_5,
      privileges: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionWithoutSD");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_access_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastAccessTime", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.relative_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("relativePath", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parameters {
      o_prot.write_field_begin(&TFieldIdentifier::new("parameters", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.privileges {
      o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PartitionWithoutSD {
  fn default() -> Self {
    PartitionWithoutSD{
      values: Some(Vec::new()),
      create_time: Some(0),
      last_access_time: Some(0),
      relative_path: Some("".to_owned()),
      parameters: Some(BTreeMap::new()),
      privileges: None,
    }
  }
}

//
// PartitionSpecWithSharedSD
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionSpecWithSharedSD {
  pub partitions: Option<Vec<PartitionWithoutSD>>,
  pub sd: Option<StorageDescriptor>,
}

impl PartitionSpecWithSharedSD {
  pub fn new<F1, F2>(partitions: F1, sd: F2) -> PartitionSpecWithSharedSD where F1: Into<Option<Vec<PartitionWithoutSD>>>, F2: Into<Option<StorageDescriptor>> {
    PartitionSpecWithSharedSD {
      partitions: partitions.into(),
      sd: sd.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionSpecWithSharedSD> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<PartitionWithoutSD>> = Some(Vec::new());
    let mut f_2: Option<StorageDescriptor> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PartitionWithoutSD> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = PartitionWithoutSD::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = StorageDescriptor::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PartitionSpecWithSharedSD {
      partitions: f_1,
      sd: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionSpecWithSharedSD");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sd {
      o_prot.write_field_begin(&TFieldIdentifier::new("sd", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PartitionSpecWithSharedSD {
  fn default() -> Self {
    PartitionSpecWithSharedSD{
      partitions: Some(Vec::new()),
      sd: None,
    }
  }
}

//
// PartitionListComposingSpec
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionListComposingSpec {
  pub partitions: Option<Vec<Partition>>,
}

impl PartitionListComposingSpec {
  pub fn new<F1>(partitions: F1) -> PartitionListComposingSpec where F1: Into<Option<Vec<Partition>>> {
    PartitionListComposingSpec {
      partitions: partitions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionListComposingSpec> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Partition>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PartitionListComposingSpec {
      partitions: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionListComposingSpec");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PartitionListComposingSpec {
  fn default() -> Self {
    PartitionListComposingSpec{
      partitions: Some(Vec::new()),
    }
  }
}

//
// PartitionSpec
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionSpec {
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub root_path: Option<String>,
  pub shared_s_d_partition_spec: Option<PartitionSpecWithSharedSD>,
  pub partition_list: Option<PartitionListComposingSpec>,
  pub cat_name: Option<String>,
}

impl PartitionSpec {
  pub fn new<F1, F2, F3, F4, F5, F6>(db_name: F1, table_name: F2, root_path: F3, shared_s_d_partition_spec: F4, partition_list: F5, cat_name: F6) -> PartitionSpec where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<PartitionSpecWithSharedSD>>, F5: Into<Option<PartitionListComposingSpec>>, F6: Into<Option<String>> {
    PartitionSpec {
      db_name: db_name.into(),
      table_name: table_name.into(),
      root_path: root_path.into(),
      shared_s_d_partition_spec: shared_s_d_partition_spec.into(),
      partition_list: partition_list.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionSpec> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<PartitionSpecWithSharedSD> = None;
    let mut f_5: Option<PartitionListComposingSpec> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = PartitionSpecWithSharedSD::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = PartitionListComposingSpec::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PartitionSpec {
      db_name: f_1,
      table_name: f_2,
      root_path: f_3,
      shared_s_d_partition_spec: f_4,
      partition_list: f_5,
      cat_name: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionSpec");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.root_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("rootPath", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shared_s_d_partition_spec {
      o_prot.write_field_begin(&TFieldIdentifier::new("sharedSDPartitionSpec", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionList", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PartitionSpec {
  fn default() -> Self {
    PartitionSpec{
      db_name: Some("".to_owned()),
      table_name: Some("".to_owned()),
      root_path: Some("".to_owned()),
      shared_s_d_partition_spec: None,
      partition_list: None,
      cat_name: Some("".to_owned()),
    }
  }
}

//
// BooleanColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BooleanColumnStatsData {
  pub num_trues: i64,
  pub num_falses: i64,
  pub num_nulls: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl BooleanColumnStatsData {
  pub fn new<F4>(num_trues: i64, num_falses: i64, num_nulls: i64, bit_vectors: F4) -> BooleanColumnStatsData where F4: Into<Option<Vec<u8>>> {
    BooleanColumnStatsData {
      num_trues,
      num_falses,
      num_nulls,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BooleanColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BooleanColumnStatsData.num_trues", &f_1)?;
    verify_required_field_exists("BooleanColumnStatsData.num_falses", &f_2)?;
    verify_required_field_exists("BooleanColumnStatsData.num_nulls", &f_3)?;
    let ret = BooleanColumnStatsData {
      num_trues: f_1.expect("auto-generated code should have checked for presence of required fields"),
      num_falses: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BooleanColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numTrues", TType::I64, 1))?;
    o_prot.write_i64(self.num_trues)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numFalses", TType::I64, 2))?;
    o_prot.write_i64(self.num_falses)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DoubleColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DoubleColumnStatsData {
  pub low_value: Option<OrderedFloat<f64>>,
  pub high_value: Option<OrderedFloat<f64>>,
  pub num_nulls: i64,
  pub num_d_vs: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl DoubleColumnStatsData {
  pub fn new<F1, F2, F5>(low_value: F1, high_value: F2, num_nulls: i64, num_d_vs: i64, bit_vectors: F5) -> DoubleColumnStatsData where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>>, F5: Into<Option<Vec<u8>>> {
    DoubleColumnStatsData {
      low_value: low_value.into(),
      high_value: high_value.into(),
      num_nulls,
      num_d_vs,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DoubleColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = None;
    let mut f_2: Option<OrderedFloat<f64>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DoubleColumnStatsData.num_nulls", &f_3)?;
    verify_required_field_exists("DoubleColumnStatsData.num_d_vs", &f_4)?;
    let ret = DoubleColumnStatsData {
      low_value: f_1,
      high_value: f_2,
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      num_d_vs: f_4.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DoubleColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.low_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("lowValue", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.high_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("highValue", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numDVs", TType::I64, 4))?;
    o_prot.write_i64(self.num_d_vs)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LongColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LongColumnStatsData {
  pub low_value: Option<i64>,
  pub high_value: Option<i64>,
  pub num_nulls: i64,
  pub num_d_vs: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl LongColumnStatsData {
  pub fn new<F1, F2, F5>(low_value: F1, high_value: F2, num_nulls: i64, num_d_vs: i64, bit_vectors: F5) -> LongColumnStatsData where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F5: Into<Option<Vec<u8>>> {
    LongColumnStatsData {
      low_value: low_value.into(),
      high_value: high_value.into(),
      num_nulls,
      num_d_vs,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LongColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LongColumnStatsData.num_nulls", &f_3)?;
    verify_required_field_exists("LongColumnStatsData.num_d_vs", &f_4)?;
    let ret = LongColumnStatsData {
      low_value: f_1,
      high_value: f_2,
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      num_d_vs: f_4.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LongColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.low_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("lowValue", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.high_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("highValue", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numDVs", TType::I64, 4))?;
    o_prot.write_i64(self.num_d_vs)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StringColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StringColumnStatsData {
  pub max_col_len: i64,
  pub avg_col_len: OrderedFloat<f64>,
  pub num_nulls: i64,
  pub num_d_vs: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl StringColumnStatsData {
  pub fn new<F5>(max_col_len: i64, avg_col_len: OrderedFloat<f64>, num_nulls: i64, num_d_vs: i64, bit_vectors: F5) -> StringColumnStatsData where F5: Into<Option<Vec<u8>>> {
    StringColumnStatsData {
      max_col_len,
      avg_col_len,
      num_nulls,
      num_d_vs,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StringColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<OrderedFloat<f64>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("StringColumnStatsData.max_col_len", &f_1)?;
    verify_required_field_exists("StringColumnStatsData.avg_col_len", &f_2)?;
    verify_required_field_exists("StringColumnStatsData.num_nulls", &f_3)?;
    verify_required_field_exists("StringColumnStatsData.num_d_vs", &f_4)?;
    let ret = StringColumnStatsData {
      max_col_len: f_1.expect("auto-generated code should have checked for presence of required fields"),
      avg_col_len: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      num_d_vs: f_4.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StringColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxColLen", TType::I64, 1))?;
    o_prot.write_i64(self.max_col_len)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("avgColLen", TType::Double, 2))?;
    o_prot.write_double(self.avg_col_len.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numDVs", TType::I64, 4))?;
    o_prot.write_i64(self.num_d_vs)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BinaryColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BinaryColumnStatsData {
  pub max_col_len: i64,
  pub avg_col_len: OrderedFloat<f64>,
  pub num_nulls: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl BinaryColumnStatsData {
  pub fn new<F4>(max_col_len: i64, avg_col_len: OrderedFloat<f64>, num_nulls: i64, bit_vectors: F4) -> BinaryColumnStatsData where F4: Into<Option<Vec<u8>>> {
    BinaryColumnStatsData {
      max_col_len,
      avg_col_len,
      num_nulls,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BinaryColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<OrderedFloat<f64>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BinaryColumnStatsData.max_col_len", &f_1)?;
    verify_required_field_exists("BinaryColumnStatsData.avg_col_len", &f_2)?;
    verify_required_field_exists("BinaryColumnStatsData.num_nulls", &f_3)?;
    let ret = BinaryColumnStatsData {
      max_col_len: f_1.expect("auto-generated code should have checked for presence of required fields"),
      avg_col_len: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BinaryColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxColLen", TType::I64, 1))?;
    o_prot.write_i64(self.max_col_len)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("avgColLen", TType::Double, 2))?;
    o_prot.write_double(self.avg_col_len.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Decimal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Decimal {
  pub unscaled: Vec<u8>,
  pub scale: i16,
}

impl Decimal {
  pub fn new(unscaled: Vec<u8>, scale: i16) -> Decimal {
    Decimal {
      unscaled,
      scale,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Decimal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_3: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Decimal.unscaled", &f_1)?;
    verify_required_field_exists("Decimal.scale", &f_3)?;
    let ret = Decimal {
      unscaled: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scale: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Decimal");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("unscaled", TType::String, 1))?;
    o_prot.write_bytes(&self.unscaled)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::I16, 3))?;
    o_prot.write_i16(self.scale)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DecimalColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecimalColumnStatsData {
  pub low_value: Option<Decimal>,
  pub high_value: Option<Decimal>,
  pub num_nulls: i64,
  pub num_d_vs: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl DecimalColumnStatsData {
  pub fn new<F1, F2, F5>(low_value: F1, high_value: F2, num_nulls: i64, num_d_vs: i64, bit_vectors: F5) -> DecimalColumnStatsData where F1: Into<Option<Decimal>>, F2: Into<Option<Decimal>>, F5: Into<Option<Vec<u8>>> {
    DecimalColumnStatsData {
      low_value: low_value.into(),
      high_value: high_value.into(),
      num_nulls,
      num_d_vs,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecimalColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Decimal> = None;
    let mut f_2: Option<Decimal> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Decimal::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Decimal::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DecimalColumnStatsData.num_nulls", &f_3)?;
    verify_required_field_exists("DecimalColumnStatsData.num_d_vs", &f_4)?;
    let ret = DecimalColumnStatsData {
      low_value: f_1,
      high_value: f_2,
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      num_d_vs: f_4.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DecimalColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.low_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("lowValue", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.high_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("highValue", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numDVs", TType::I64, 4))?;
    o_prot.write_i64(self.num_d_vs)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Date
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Date {
  pub days_since_epoch: i64,
}

impl Date {
  pub fn new(days_since_epoch: i64) -> Date {
    Date {
      days_since_epoch,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Date> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Date.days_since_epoch", &f_1)?;
    let ret = Date {
      days_since_epoch: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Date");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("daysSinceEpoch", TType::I64, 1))?;
    o_prot.write_i64(self.days_since_epoch)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DateColumnStatsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DateColumnStatsData {
  pub low_value: Option<Date>,
  pub high_value: Option<Date>,
  pub num_nulls: i64,
  pub num_d_vs: i64,
  pub bit_vectors: Option<Vec<u8>>,
}

impl DateColumnStatsData {
  pub fn new<F1, F2, F5>(low_value: F1, high_value: F2, num_nulls: i64, num_d_vs: i64, bit_vectors: F5) -> DateColumnStatsData where F1: Into<Option<Date>>, F2: Into<Option<Date>>, F5: Into<Option<Vec<u8>>> {
    DateColumnStatsData {
      low_value: low_value.into(),
      high_value: high_value.into(),
      num_nulls,
      num_d_vs,
      bit_vectors: bit_vectors.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DateColumnStatsData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Date> = None;
    let mut f_2: Option<Date> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Date::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Date::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DateColumnStatsData.num_nulls", &f_3)?;
    verify_required_field_exists("DateColumnStatsData.num_d_vs", &f_4)?;
    let ret = DateColumnStatsData {
      low_value: f_1,
      high_value: f_2,
      num_nulls: f_3.expect("auto-generated code should have checked for presence of required fields"),
      num_d_vs: f_4.expect("auto-generated code should have checked for presence of required fields"),
      bit_vectors: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DateColumnStatsData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.low_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("lowValue", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.high_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("highValue", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("numNulls", TType::I64, 3))?;
    o_prot.write_i64(self.num_nulls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numDVs", TType::I64, 4))?;
    o_prot.write_i64(self.num_d_vs)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.bit_vectors {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitVectors", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ColumnStatisticsData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ColumnStatisticsData {
  BooleanStats(BooleanColumnStatsData),
  LongStats(LongColumnStatsData),
  DoubleStats(DoubleColumnStatsData),
  StringStats(StringColumnStatsData),
  BinaryStats(BinaryColumnStatsData),
  DecimalStats(DecimalColumnStatsData),
  DateStats(DateColumnStatsData),
}

impl ColumnStatisticsData {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColumnStatisticsData> {
    let mut ret: Option<ColumnStatisticsData> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = BooleanColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::BooleanStats(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = LongColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::LongStats(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = DoubleColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::DoubleStats(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = StringColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::StringStats(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = BinaryColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::BinaryStats(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = DecimalColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::DecimalStats(val));
          }
          received_field_count += 1;
        },
        7 => {
          let val = DateColumnStatsData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(ColumnStatisticsData::DateStats(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote ColumnStatisticsData"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote ColumnStatisticsData"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColumnStatisticsData");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      ColumnStatisticsData::BooleanStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("booleanStats", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      ColumnStatisticsData::LongStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("longStats", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      ColumnStatisticsData::DoubleStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("doubleStats", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      ColumnStatisticsData::StringStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("stringStats", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      ColumnStatisticsData::BinaryStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("binaryStats", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      ColumnStatisticsData::DecimalStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("decimalStats", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      ColumnStatisticsData::DateStats(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("dateStats", TType::Struct, 7))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ColumnStatisticsObj
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ColumnStatisticsObj {
  pub col_name: String,
  pub col_type: String,
  pub stats_data: ColumnStatisticsData,
}

impl ColumnStatisticsObj {
  pub fn new(col_name: String, col_type: String, stats_data: ColumnStatisticsData) -> ColumnStatisticsObj {
    ColumnStatisticsObj {
      col_name,
      col_type,
      stats_data,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColumnStatisticsObj> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<ColumnStatisticsData> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ColumnStatisticsData::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ColumnStatisticsObj.col_name", &f_1)?;
    verify_required_field_exists("ColumnStatisticsObj.col_type", &f_2)?;
    verify_required_field_exists("ColumnStatisticsObj.stats_data", &f_3)?;
    let ret = ColumnStatisticsObj {
      col_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      col_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      stats_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColumnStatisticsObj");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colName", TType::String, 1))?;
    o_prot.write_string(&self.col_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colType", TType::String, 2))?;
    o_prot.write_string(&self.col_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statsData", TType::Struct, 3))?;
    self.stats_data.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ColumnStatisticsDesc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ColumnStatisticsDesc {
  pub is_tbl_level: bool,
  pub db_name: String,
  pub table_name: String,
  pub part_name: Option<String>,
  pub last_analyzed: Option<i64>,
  pub cat_name: Option<String>,
}

impl ColumnStatisticsDesc {
  pub fn new<F4, F5, F6>(is_tbl_level: bool, db_name: String, table_name: String, part_name: F4, last_analyzed: F5, cat_name: F6) -> ColumnStatisticsDesc where F4: Into<Option<String>>, F5: Into<Option<i64>>, F6: Into<Option<String>> {
    ColumnStatisticsDesc {
      is_tbl_level,
      db_name,
      table_name,
      part_name: part_name.into(),
      last_analyzed: last_analyzed.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColumnStatisticsDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ColumnStatisticsDesc.is_tbl_level", &f_1)?;
    verify_required_field_exists("ColumnStatisticsDesc.db_name", &f_2)?;
    verify_required_field_exists("ColumnStatisticsDesc.table_name", &f_3)?;
    let ret = ColumnStatisticsDesc {
      is_tbl_level: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_4,
      last_analyzed: f_5,
      cat_name: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColumnStatisticsDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isTblLevel", TType::Bool, 1))?;
    o_prot.write_bool(self.is_tbl_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 3))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.part_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("partName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_analyzed {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastAnalyzed", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ColumnStatistics
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ColumnStatistics {
  pub stats_desc: ColumnStatisticsDesc,
  pub stats_obj: Vec<ColumnStatisticsObj>,
}

impl ColumnStatistics {
  pub fn new(stats_desc: ColumnStatisticsDesc, stats_obj: Vec<ColumnStatisticsObj>) -> ColumnStatistics {
    ColumnStatistics {
      stats_desc,
      stats_obj,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColumnStatistics> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ColumnStatisticsDesc> = None;
    let mut f_2: Option<Vec<ColumnStatisticsObj>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ColumnStatisticsDesc::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ColumnStatisticsObj> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = ColumnStatisticsObj::read_from_in_protocol(i_prot)?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ColumnStatistics.stats_desc", &f_1)?;
    verify_required_field_exists("ColumnStatistics.stats_obj", &f_2)?;
    let ret = ColumnStatistics {
      stats_desc: f_1.expect("auto-generated code should have checked for presence of required fields"),
      stats_obj: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColumnStatistics");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statsDesc", TType::Struct, 1))?;
    self.stats_desc.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statsObj", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.stats_obj.len() as i32))?;
    for e in &self.stats_obj {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AggrStats
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AggrStats {
  pub col_stats: Vec<ColumnStatisticsObj>,
  pub parts_found: i64,
}

impl AggrStats {
  pub fn new(col_stats: Vec<ColumnStatisticsObj>, parts_found: i64) -> AggrStats {
    AggrStats {
      col_stats,
      parts_found,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AggrStats> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ColumnStatisticsObj>> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ColumnStatisticsObj> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = ColumnStatisticsObj::read_from_in_protocol(i_prot)?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AggrStats.col_stats", &f_1)?;
    verify_required_field_exists("AggrStats.parts_found", &f_2)?;
    let ret = AggrStats {
      col_stats: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parts_found: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AggrStats");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colStats", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.col_stats.len() as i32))?;
    for e in &self.col_stats {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partsFound", TType::I64, 2))?;
    o_prot.write_i64(self.parts_found)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetPartitionsStatsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetPartitionsStatsRequest {
  pub col_stats: Vec<ColumnStatistics>,
  pub need_merge: Option<bool>,
}

impl SetPartitionsStatsRequest {
  pub fn new<F2>(col_stats: Vec<ColumnStatistics>, need_merge: F2) -> SetPartitionsStatsRequest where F2: Into<Option<bool>> {
    SetPartitionsStatsRequest {
      col_stats,
      need_merge: need_merge.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetPartitionsStatsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ColumnStatistics>> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ColumnStatistics> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = ColumnStatistics::read_from_in_protocol(i_prot)?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetPartitionsStatsRequest.col_stats", &f_1)?;
    let ret = SetPartitionsStatsRequest {
      col_stats: f_1.expect("auto-generated code should have checked for presence of required fields"),
      need_merge: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetPartitionsStatsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colStats", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.col_stats.len() as i32))?;
    for e in &self.col_stats {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.need_merge {
      o_prot.write_field_begin(&TFieldIdentifier::new("needMerge", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Schema
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Schema {
  pub field_schemas: Option<Vec<FieldSchema>>,
  pub properties: Option<BTreeMap<String, String>>,
}

impl Schema {
  pub fn new<F1, F2>(field_schemas: F1, properties: F2) -> Schema where F1: Into<Option<Vec<FieldSchema>>>, F2: Into<Option<BTreeMap<String, String>>> {
    Schema {
      field_schemas: field_schemas.into(),
      properties: properties.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Schema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<FieldSchema>> = Some(Vec::new());
    let mut f_2: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_45 = i_prot.read_string()?;
            let map_val_46 = i_prot.read_string()?;
            val.insert(map_key_45, map_val_46);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Schema {
      field_schemas: f_1,
      properties: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Schema");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.field_schemas {
      o_prot.write_field_begin(&TFieldIdentifier::new("fieldSchemas", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Schema {
  fn default() -> Self {
    Schema{
      field_schemas: Some(Vec::new()),
      properties: Some(BTreeMap::new()),
    }
  }
}

//
// EnvironmentContext
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EnvironmentContext {
  pub properties: Option<BTreeMap<String, String>>,
}

impl EnvironmentContext {
  pub fn new<F1>(properties: F1) -> EnvironmentContext where F1: Into<Option<BTreeMap<String, String>>> {
    EnvironmentContext {
      properties: properties.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EnvironmentContext> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, String>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_47 = i_prot.read_string()?;
            let map_val_48 = i_prot.read_string()?;
            val.insert(map_key_47, map_val_48);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EnvironmentContext {
      properties: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EnvironmentContext");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for EnvironmentContext {
  fn default() -> Self {
    EnvironmentContext{
      properties: Some(BTreeMap::new()),
    }
  }
}

//
// PrimaryKeysRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrimaryKeysRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub cat_name: Option<String>,
}

impl PrimaryKeysRequest {
  pub fn new<F3>(db_name: String, tbl_name: String, cat_name: F3) -> PrimaryKeysRequest where F3: Into<Option<String>> {
    PrimaryKeysRequest {
      db_name,
      tbl_name,
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrimaryKeysRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PrimaryKeysRequest.db_name", &f_1)?;
    verify_required_field_exists("PrimaryKeysRequest.tbl_name", &f_2)?;
    let ret = PrimaryKeysRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cat_name: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrimaryKeysRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PrimaryKeysResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PrimaryKeysResponse {
  pub primary_keys: Vec<SQLPrimaryKey>,
}

impl PrimaryKeysResponse {
  pub fn new(primary_keys: Vec<SQLPrimaryKey>) -> PrimaryKeysResponse {
    PrimaryKeysResponse {
      primary_keys,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PrimaryKeysResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLPrimaryKey>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLPrimaryKey> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = SQLPrimaryKey::read_from_in_protocol(i_prot)?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PrimaryKeysResponse.primary_keys", &f_1)?;
    let ret = PrimaryKeysResponse {
      primary_keys: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PrimaryKeysResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primaryKeys", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.primary_keys.len() as i32))?;
    for e in &self.primary_keys {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ForeignKeysRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ForeignKeysRequest {
  pub parent_db_name: Option<String>,
  pub parent_tbl_name: Option<String>,
  pub foreign_db_name: Option<String>,
  pub foreign_tbl_name: Option<String>,
  pub cat_name: Option<String>,
}

impl ForeignKeysRequest {
  pub fn new<F1, F2, F3, F4, F5>(parent_db_name: F1, parent_tbl_name: F2, foreign_db_name: F3, foreign_tbl_name: F4, cat_name: F5) -> ForeignKeysRequest where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    ForeignKeysRequest {
      parent_db_name: parent_db_name.into(),
      parent_tbl_name: parent_tbl_name.into(),
      foreign_db_name: foreign_db_name.into(),
      foreign_tbl_name: foreign_tbl_name.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ForeignKeysRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ForeignKeysRequest {
      parent_db_name: f_1,
      parent_tbl_name: f_2,
      foreign_db_name: f_3,
      foreign_tbl_name: f_4,
      cat_name: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ForeignKeysRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.parent_db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parent_db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_tbl_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parent_tbl_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.foreign_db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("foreign_db_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.foreign_tbl_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("foreign_tbl_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ForeignKeysRequest {
  fn default() -> Self {
    ForeignKeysRequest{
      parent_db_name: Some("".to_owned()),
      parent_tbl_name: Some("".to_owned()),
      foreign_db_name: Some("".to_owned()),
      foreign_tbl_name: Some("".to_owned()),
      cat_name: Some("".to_owned()),
    }
  }
}

//
// ForeignKeysResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ForeignKeysResponse {
  pub foreign_keys: Vec<SQLForeignKey>,
}

impl ForeignKeysResponse {
  pub fn new(foreign_keys: Vec<SQLForeignKey>) -> ForeignKeysResponse {
    ForeignKeysResponse {
      foreign_keys,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ForeignKeysResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLForeignKey>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLForeignKey> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = SQLForeignKey::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ForeignKeysResponse.foreign_keys", &f_1)?;
    let ret = ForeignKeysResponse {
      foreign_keys: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ForeignKeysResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("foreignKeys", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.foreign_keys.len() as i32))?;
    for e in &self.foreign_keys {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UniqueConstraintsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UniqueConstraintsRequest {
  pub cat_name: String,
  pub db_name: String,
  pub tbl_name: String,
}

impl UniqueConstraintsRequest {
  pub fn new(cat_name: String, db_name: String, tbl_name: String) -> UniqueConstraintsRequest {
    UniqueConstraintsRequest {
      cat_name,
      db_name,
      tbl_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniqueConstraintsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UniqueConstraintsRequest.cat_name", &f_1)?;
    verify_required_field_exists("UniqueConstraintsRequest.db_name", &f_2)?;
    verify_required_field_exists("UniqueConstraintsRequest.tbl_name", &f_3)?;
    let ret = UniqueConstraintsRequest {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UniqueConstraintsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
    o_prot.write_string(&self.cat_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 3))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UniqueConstraintsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UniqueConstraintsResponse {
  pub unique_constraints: Vec<SQLUniqueConstraint>,
}

impl UniqueConstraintsResponse {
  pub fn new(unique_constraints: Vec<SQLUniqueConstraint>) -> UniqueConstraintsResponse {
    UniqueConstraintsResponse {
      unique_constraints,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniqueConstraintsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLUniqueConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLUniqueConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = SQLUniqueConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UniqueConstraintsResponse.unique_constraints", &f_1)?;
    let ret = UniqueConstraintsResponse {
      unique_constraints: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UniqueConstraintsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uniqueConstraints", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.unique_constraints.len() as i32))?;
    for e in &self.unique_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotNullConstraintsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotNullConstraintsRequest {
  pub cat_name: String,
  pub db_name: String,
  pub tbl_name: String,
}

impl NotNullConstraintsRequest {
  pub fn new(cat_name: String, db_name: String, tbl_name: String) -> NotNullConstraintsRequest {
    NotNullConstraintsRequest {
      cat_name,
      db_name,
      tbl_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotNullConstraintsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotNullConstraintsRequest.cat_name", &f_1)?;
    verify_required_field_exists("NotNullConstraintsRequest.db_name", &f_2)?;
    verify_required_field_exists("NotNullConstraintsRequest.tbl_name", &f_3)?;
    let ret = NotNullConstraintsRequest {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotNullConstraintsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
    o_prot.write_string(&self.cat_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 3))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotNullConstraintsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotNullConstraintsResponse {
  pub not_null_constraints: Vec<SQLNotNullConstraint>,
}

impl NotNullConstraintsResponse {
  pub fn new(not_null_constraints: Vec<SQLNotNullConstraint>) -> NotNullConstraintsResponse {
    NotNullConstraintsResponse {
      not_null_constraints,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotNullConstraintsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLNotNullConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLNotNullConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = SQLNotNullConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotNullConstraintsResponse.not_null_constraints", &f_1)?;
    let ret = NotNullConstraintsResponse {
      not_null_constraints: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotNullConstraintsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notNullConstraints", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.not_null_constraints.len() as i32))?;
    for e in &self.not_null_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DefaultConstraintsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DefaultConstraintsRequest {
  pub cat_name: String,
  pub db_name: String,
  pub tbl_name: String,
}

impl DefaultConstraintsRequest {
  pub fn new(cat_name: String, db_name: String, tbl_name: String) -> DefaultConstraintsRequest {
    DefaultConstraintsRequest {
      cat_name,
      db_name,
      tbl_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DefaultConstraintsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DefaultConstraintsRequest.cat_name", &f_1)?;
    verify_required_field_exists("DefaultConstraintsRequest.db_name", &f_2)?;
    verify_required_field_exists("DefaultConstraintsRequest.tbl_name", &f_3)?;
    let ret = DefaultConstraintsRequest {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DefaultConstraintsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
    o_prot.write_string(&self.cat_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 3))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DefaultConstraintsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DefaultConstraintsResponse {
  pub default_constraints: Vec<SQLDefaultConstraint>,
}

impl DefaultConstraintsResponse {
  pub fn new(default_constraints: Vec<SQLDefaultConstraint>) -> DefaultConstraintsResponse {
    DefaultConstraintsResponse {
      default_constraints,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DefaultConstraintsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLDefaultConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLDefaultConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_53 = SQLDefaultConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_53);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DefaultConstraintsResponse.default_constraints", &f_1)?;
    let ret = DefaultConstraintsResponse {
      default_constraints: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DefaultConstraintsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("defaultConstraints", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.default_constraints.len() as i32))?;
    for e in &self.default_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CheckConstraintsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CheckConstraintsRequest {
  pub cat_name: String,
  pub db_name: String,
  pub tbl_name: String,
}

impl CheckConstraintsRequest {
  pub fn new(cat_name: String, db_name: String, tbl_name: String) -> CheckConstraintsRequest {
    CheckConstraintsRequest {
      cat_name,
      db_name,
      tbl_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CheckConstraintsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CheckConstraintsRequest.cat_name", &f_1)?;
    verify_required_field_exists("CheckConstraintsRequest.db_name", &f_2)?;
    verify_required_field_exists("CheckConstraintsRequest.tbl_name", &f_3)?;
    let ret = CheckConstraintsRequest {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CheckConstraintsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
    o_prot.write_string(&self.cat_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 3))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CheckConstraintsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CheckConstraintsResponse {
  pub check_constraints: Vec<SQLCheckConstraint>,
}

impl CheckConstraintsResponse {
  pub fn new(check_constraints: Vec<SQLCheckConstraint>) -> CheckConstraintsResponse {
    CheckConstraintsResponse {
      check_constraints,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CheckConstraintsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLCheckConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLCheckConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = SQLCheckConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CheckConstraintsResponse.check_constraints", &f_1)?;
    let ret = CheckConstraintsResponse {
      check_constraints: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CheckConstraintsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("checkConstraints", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.check_constraints.len() as i32))?;
    for e in &self.check_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DropConstraintRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DropConstraintRequest {
  pub dbname: String,
  pub tablename: String,
  pub constraintname: String,
  pub cat_name: Option<String>,
}

impl DropConstraintRequest {
  pub fn new<F4>(dbname: String, tablename: String, constraintname: String, cat_name: F4) -> DropConstraintRequest where F4: Into<Option<String>> {
    DropConstraintRequest {
      dbname,
      tablename,
      constraintname,
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DropConstraintRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DropConstraintRequest.dbname", &f_1)?;
    verify_required_field_exists("DropConstraintRequest.tablename", &f_2)?;
    verify_required_field_exists("DropConstraintRequest.constraintname", &f_3)?;
    let ret = DropConstraintRequest {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tablename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      constraintname: f_3.expect("auto-generated code should have checked for presence of required fields"),
      cat_name: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DropConstraintRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 2))?;
    o_prot.write_string(&self.tablename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("constraintname", TType::String, 3))?;
    o_prot.write_string(&self.constraintname)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddPrimaryKeyRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddPrimaryKeyRequest {
  pub primary_key_cols: Vec<SQLPrimaryKey>,
}

impl AddPrimaryKeyRequest {
  pub fn new(primary_key_cols: Vec<SQLPrimaryKey>) -> AddPrimaryKeyRequest {
    AddPrimaryKeyRequest {
      primary_key_cols,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddPrimaryKeyRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLPrimaryKey>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLPrimaryKey> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = SQLPrimaryKey::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddPrimaryKeyRequest.primary_key_cols", &f_1)?;
    let ret = AddPrimaryKeyRequest {
      primary_key_cols: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddPrimaryKeyRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primaryKeyCols", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.primary_key_cols.len() as i32))?;
    for e in &self.primary_key_cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddForeignKeyRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddForeignKeyRequest {
  pub foreign_key_cols: Vec<SQLForeignKey>,
}

impl AddForeignKeyRequest {
  pub fn new(foreign_key_cols: Vec<SQLForeignKey>) -> AddForeignKeyRequest {
    AddForeignKeyRequest {
      foreign_key_cols,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddForeignKeyRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLForeignKey>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLForeignKey> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = SQLForeignKey::read_from_in_protocol(i_prot)?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddForeignKeyRequest.foreign_key_cols", &f_1)?;
    let ret = AddForeignKeyRequest {
      foreign_key_cols: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddForeignKeyRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("foreignKeyCols", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.foreign_key_cols.len() as i32))?;
    for e in &self.foreign_key_cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddUniqueConstraintRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddUniqueConstraintRequest {
  pub unique_constraint_cols: Vec<SQLUniqueConstraint>,
}

impl AddUniqueConstraintRequest {
  pub fn new(unique_constraint_cols: Vec<SQLUniqueConstraint>) -> AddUniqueConstraintRequest {
    AddUniqueConstraintRequest {
      unique_constraint_cols,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddUniqueConstraintRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLUniqueConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLUniqueConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = SQLUniqueConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddUniqueConstraintRequest.unique_constraint_cols", &f_1)?;
    let ret = AddUniqueConstraintRequest {
      unique_constraint_cols: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddUniqueConstraintRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uniqueConstraintCols", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.unique_constraint_cols.len() as i32))?;
    for e in &self.unique_constraint_cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddNotNullConstraintRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddNotNullConstraintRequest {
  pub not_null_constraint_cols: Vec<SQLNotNullConstraint>,
}

impl AddNotNullConstraintRequest {
  pub fn new(not_null_constraint_cols: Vec<SQLNotNullConstraint>) -> AddNotNullConstraintRequest {
    AddNotNullConstraintRequest {
      not_null_constraint_cols,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddNotNullConstraintRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLNotNullConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLNotNullConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = SQLNotNullConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddNotNullConstraintRequest.not_null_constraint_cols", &f_1)?;
    let ret = AddNotNullConstraintRequest {
      not_null_constraint_cols: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddNotNullConstraintRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notNullConstraintCols", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.not_null_constraint_cols.len() as i32))?;
    for e in &self.not_null_constraint_cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddDefaultConstraintRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddDefaultConstraintRequest {
  pub default_constraint_cols: Vec<SQLDefaultConstraint>,
}

impl AddDefaultConstraintRequest {
  pub fn new(default_constraint_cols: Vec<SQLDefaultConstraint>) -> AddDefaultConstraintRequest {
    AddDefaultConstraintRequest {
      default_constraint_cols,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddDefaultConstraintRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLDefaultConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLDefaultConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = SQLDefaultConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddDefaultConstraintRequest.default_constraint_cols", &f_1)?;
    let ret = AddDefaultConstraintRequest {
      default_constraint_cols: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddDefaultConstraintRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("defaultConstraintCols", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.default_constraint_cols.len() as i32))?;
    for e in &self.default_constraint_cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddCheckConstraintRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddCheckConstraintRequest {
  pub check_constraint_cols: Vec<SQLCheckConstraint>,
}

impl AddCheckConstraintRequest {
  pub fn new(check_constraint_cols: Vec<SQLCheckConstraint>) -> AddCheckConstraintRequest {
    AddCheckConstraintRequest {
      check_constraint_cols,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddCheckConstraintRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SQLCheckConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLCheckConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = SQLCheckConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddCheckConstraintRequest.check_constraint_cols", &f_1)?;
    let ret = AddCheckConstraintRequest {
      check_constraint_cols: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddCheckConstraintRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("checkConstraintCols", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.check_constraint_cols.len() as i32))?;
    for e in &self.check_constraint_cols {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionsByExprResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionsByExprResult {
  pub partitions: Vec<Partition>,
  pub has_unknown_partitions: bool,
}

impl PartitionsByExprResult {
  pub fn new(partitions: Vec<Partition>, has_unknown_partitions: bool) -> PartitionsByExprResult {
    PartitionsByExprResult {
      partitions,
      has_unknown_partitions,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionsByExprResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Partition>> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionsByExprResult.partitions", &f_1)?;
    verify_required_field_exists("PartitionsByExprResult.has_unknown_partitions", &f_2)?;
    let ret = PartitionsByExprResult {
      partitions: f_1.expect("auto-generated code should have checked for presence of required fields"),
      has_unknown_partitions: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionsByExprResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.partitions.len() as i32))?;
    for e in &self.partitions {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hasUnknownPartitions", TType::Bool, 2))?;
    o_prot.write_bool(self.has_unknown_partitions)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionsByExprRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionsByExprRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub expr: Vec<u8>,
  pub default_partition_name: Option<String>,
  pub max_parts: Option<i16>,
  pub cat_name: Option<String>,
}

impl PartitionsByExprRequest {
  pub fn new<F4, F5, F6>(db_name: String, tbl_name: String, expr: Vec<u8>, default_partition_name: F4, max_parts: F5, cat_name: F6) -> PartitionsByExprRequest where F4: Into<Option<String>>, F5: Into<Option<i16>>, F6: Into<Option<String>> {
    PartitionsByExprRequest {
      db_name,
      tbl_name,
      expr,
      default_partition_name: default_partition_name.into(),
      max_parts: max_parts.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionsByExprRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i16> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i16()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionsByExprRequest.db_name", &f_1)?;
    verify_required_field_exists("PartitionsByExprRequest.tbl_name", &f_2)?;
    verify_required_field_exists("PartitionsByExprRequest.expr", &f_3)?;
    let ret = PartitionsByExprRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      expr: f_3.expect("auto-generated code should have checked for presence of required fields"),
      default_partition_name: f_4,
      max_parts: f_5,
      cat_name: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionsByExprRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expr", TType::String, 3))?;
    o_prot.write_bytes(&self.expr)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.default_partition_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultPartitionName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_parts {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxParts", TType::I16, 5))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TableStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TableStatsResult {
  pub table_stats: Vec<ColumnStatisticsObj>,
}

impl TableStatsResult {
  pub fn new(table_stats: Vec<ColumnStatisticsObj>) -> TableStatsResult {
    TableStatsResult {
      table_stats,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TableStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ColumnStatisticsObj>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ColumnStatisticsObj> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = ColumnStatisticsObj::read_from_in_protocol(i_prot)?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TableStatsResult.table_stats", &f_1)?;
    let ret = TableStatsResult {
      table_stats: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TableStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableStats", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.table_stats.len() as i32))?;
    for e in &self.table_stats {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionsStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionsStatsResult {
  pub part_stats: BTreeMap<String, Vec<ColumnStatisticsObj>>,
}

impl PartitionsStatsResult {
  pub fn new(part_stats: BTreeMap<String, Vec<ColumnStatisticsObj>>) -> PartitionsStatsResult {
    PartitionsStatsResult {
      part_stats,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionsStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, Vec<ColumnStatisticsObj>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<ColumnStatisticsObj>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_63 = i_prot.read_string()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_64: Vec<ColumnStatisticsObj> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_65 = ColumnStatisticsObj::read_from_in_protocol(i_prot)?;
              map_val_64.push(list_elem_65);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_63, map_val_64);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionsStatsResult.part_stats", &f_1)?;
    let ret = PartitionsStatsResult {
      part_stats: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionsStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partStats", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::List, self.part_stats.len() as i32))?;
    for (k, v) in &self.part_stats {
      o_prot.write_string(k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TableStatsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TableStatsRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub col_names: Vec<String>,
  pub cat_name: Option<String>,
}

impl TableStatsRequest {
  pub fn new<F4>(db_name: String, tbl_name: String, col_names: Vec<String>, cat_name: F4) -> TableStatsRequest where F4: Into<Option<String>> {
    TableStatsRequest {
      db_name,
      tbl_name,
      col_names,
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TableStatsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = i_prot.read_string()?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TableStatsRequest.db_name", &f_1)?;
    verify_required_field_exists("TableStatsRequest.tbl_name", &f_2)?;
    verify_required_field_exists("TableStatsRequest.col_names", &f_3)?;
    let ret = TableStatsRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      col_names: f_3.expect("auto-generated code should have checked for presence of required fields"),
      cat_name: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TableStatsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colNames", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.col_names.len() as i32))?;
    for e in &self.col_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionsStatsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionsStatsRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub col_names: Vec<String>,
  pub part_names: Vec<String>,
  pub cat_name: Option<String>,
}

impl PartitionsStatsRequest {
  pub fn new<F5>(db_name: String, tbl_name: String, col_names: Vec<String>, part_names: Vec<String>, cat_name: F5) -> PartitionsStatsRequest where F5: Into<Option<String>> {
    PartitionsStatsRequest {
      db_name,
      tbl_name,
      col_names,
      part_names,
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionsStatsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = i_prot.read_string()?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_68 = i_prot.read_string()?;
            val.push(list_elem_68);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionsStatsRequest.db_name", &f_1)?;
    verify_required_field_exists("PartitionsStatsRequest.tbl_name", &f_2)?;
    verify_required_field_exists("PartitionsStatsRequest.col_names", &f_3)?;
    verify_required_field_exists("PartitionsStatsRequest.part_names", &f_4)?;
    let ret = PartitionsStatsRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      col_names: f_3.expect("auto-generated code should have checked for presence of required fields"),
      part_names: f_4.expect("auto-generated code should have checked for presence of required fields"),
      cat_name: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionsStatsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colNames", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.col_names.len() as i32))?;
    for e in &self.col_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partNames", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_names.len() as i32))?;
    for e in &self.part_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddPartitionsResult {
  pub partitions: Option<Vec<Partition>>,
}

impl AddPartitionsResult {
  pub fn new<F1>(partitions: F1) -> AddPartitionsResult where F1: Into<Option<Vec<Partition>>> {
    AddPartitionsResult {
      partitions: partitions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Partition>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_69 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_69);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AddPartitionsResult {
      partitions: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AddPartitionsResult {
  fn default() -> Self {
    AddPartitionsResult{
      partitions: Some(Vec::new()),
    }
  }
}

//
// AddPartitionsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddPartitionsRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub parts: Vec<Partition>,
  pub if_not_exists: bool,
  pub need_result: Option<bool>,
  pub cat_name: Option<String>,
}

impl AddPartitionsRequest {
  pub fn new<F5, F6>(db_name: String, tbl_name: String, parts: Vec<Partition>, if_not_exists: bool, need_result: F5, cat_name: F6) -> AddPartitionsRequest where F5: Into<Option<bool>>, F6: Into<Option<String>> {
    AddPartitionsRequest {
      db_name,
      tbl_name,
      parts,
      if_not_exists,
      need_result: need_result.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddPartitionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Partition>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_70 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_70);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddPartitionsRequest.db_name", &f_1)?;
    verify_required_field_exists("AddPartitionsRequest.tbl_name", &f_2)?;
    verify_required_field_exists("AddPartitionsRequest.parts", &f_3)?;
    verify_required_field_exists("AddPartitionsRequest.if_not_exists", &f_4)?;
    let ret = AddPartitionsRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
      if_not_exists: f_4.expect("auto-generated code should have checked for presence of required fields"),
      need_result: f_5,
      cat_name: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddPartitionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parts", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.parts.len() as i32))?;
    for e in &self.parts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ifNotExists", TType::Bool, 4))?;
    o_prot.write_bool(self.if_not_exists)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.need_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("needResult", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DropPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DropPartitionsResult {
  pub partitions: Option<Vec<Partition>>,
}

impl DropPartitionsResult {
  pub fn new<F1>(partitions: F1) -> DropPartitionsResult where F1: Into<Option<Vec<Partition>>> {
    DropPartitionsResult {
      partitions: partitions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DropPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Partition>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DropPartitionsResult {
      partitions: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DropPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for DropPartitionsResult {
  fn default() -> Self {
    DropPartitionsResult{
      partitions: Some(Vec::new()),
    }
  }
}

//
// DropPartitionsExpr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DropPartitionsExpr {
  pub expr: Vec<u8>,
  pub part_archive_level: Option<i32>,
}

impl DropPartitionsExpr {
  pub fn new<F2>(expr: Vec<u8>, part_archive_level: F2) -> DropPartitionsExpr where F2: Into<Option<i32>> {
    DropPartitionsExpr {
      expr,
      part_archive_level: part_archive_level.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DropPartitionsExpr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DropPartitionsExpr.expr", &f_1)?;
    let ret = DropPartitionsExpr {
      expr: f_1.expect("auto-generated code should have checked for presence of required fields"),
      part_archive_level: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DropPartitionsExpr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expr", TType::String, 1))?;
    o_prot.write_bytes(&self.expr)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.part_archive_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("partArchiveLevel", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestPartsSpec
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RequestPartsSpec {
  Names(Vec<String>),
  Exprs(Vec<DropPartitionsExpr>),
}

impl RequestPartsSpec {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestPartsSpec> {
    let mut ret: Option<RequestPartsSpec> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_72 = i_prot.read_string()?;
            val.push(list_elem_72);
          }
          i_prot.read_list_end()?;
          if ret.is_none() {
            ret = Some(RequestPartsSpec::Names(val));
          }
          received_field_count += 1;
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<DropPartitionsExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = DropPartitionsExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          if ret.is_none() {
            ret = Some(RequestPartsSpec::Exprs(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote RequestPartsSpec"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote RequestPartsSpec"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestPartsSpec");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      RequestPartsSpec::Names(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("names", TType::List, 1))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::String, f.len() as i32))?;
        for e in f {
          o_prot.write_string(e)?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
      },
      RequestPartsSpec::Exprs(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("exprs", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, f.len() as i32))?;
        for e in f {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DropPartitionsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DropPartitionsRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub parts: RequestPartsSpec,
  pub delete_data: Option<bool>,
  pub if_exists: Option<bool>,
  pub ignore_protection: Option<bool>,
  pub environment_context: Option<EnvironmentContext>,
  pub need_result: Option<bool>,
  pub cat_name: Option<String>,
}

impl DropPartitionsRequest {
  pub fn new<F4, F5, F6, F7, F8, F9>(db_name: String, tbl_name: String, parts: RequestPartsSpec, delete_data: F4, if_exists: F5, ignore_protection: F6, environment_context: F7, need_result: F8, cat_name: F9) -> DropPartitionsRequest where F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<EnvironmentContext>>, F8: Into<Option<bool>>, F9: Into<Option<String>> {
    DropPartitionsRequest {
      db_name,
      tbl_name,
      parts,
      delete_data: delete_data.into(),
      if_exists: if_exists.into(),
      ignore_protection: ignore_protection.into(),
      environment_context: environment_context.into(),
      need_result: need_result.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DropPartitionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<RequestPartsSpec> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<EnvironmentContext> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = RequestPartsSpec::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DropPartitionsRequest.db_name", &f_1)?;
    verify_required_field_exists("DropPartitionsRequest.tbl_name", &f_2)?;
    verify_required_field_exists("DropPartitionsRequest.parts", &f_3)?;
    let ret = DropPartitionsRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_4,
      if_exists: f_5,
      ignore_protection: f_6,
      environment_context: f_7,
      need_result: f_8,
      cat_name: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DropPartitionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parts", TType::Struct, 3))?;
    self.parts.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.delete_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.if_exists {
      o_prot.write_field_begin(&TFieldIdentifier::new("ifExists", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ignore_protection {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignoreProtection", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.environment_context {
      o_prot.write_field_begin(&TFieldIdentifier::new("environmentContext", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.need_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("needResult", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionValuesRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionValuesRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub partition_keys: Vec<FieldSchema>,
  pub apply_distinct: Option<bool>,
  pub filter: Option<String>,
  pub partition_order: Option<Vec<FieldSchema>>,
  pub ascending: Option<bool>,
  pub max_parts: Option<i64>,
  pub cat_name: Option<String>,
}

impl PartitionValuesRequest {
  pub fn new<F4, F5, F6, F7, F8, F9>(db_name: String, tbl_name: String, partition_keys: Vec<FieldSchema>, apply_distinct: F4, filter: F5, partition_order: F6, ascending: F7, max_parts: F8, cat_name: F9) -> PartitionValuesRequest where F4: Into<Option<bool>>, F5: Into<Option<String>>, F6: Into<Option<Vec<FieldSchema>>>, F7: Into<Option<bool>>, F8: Into<Option<i64>>, F9: Into<Option<String>> {
    PartitionValuesRequest {
      db_name,
      tbl_name,
      partition_keys,
      apply_distinct: apply_distinct.into(),
      filter: filter.into(),
      partition_order: partition_order.into(),
      ascending: ascending.into(),
      max_parts: max_parts.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionValuesRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<FieldSchema>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<FieldSchema>> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_75 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_75);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionValuesRequest.db_name", &f_1)?;
    verify_required_field_exists("PartitionValuesRequest.tbl_name", &f_2)?;
    verify_required_field_exists("PartitionValuesRequest.partition_keys", &f_3)?;
    let ret = PartitionValuesRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      partition_keys: f_3.expect("auto-generated code should have checked for presence of required fields"),
      apply_distinct: f_4,
      filter: f_5,
      partition_order: f_6,
      ascending: f_7,
      max_parts: f_8,
      cat_name: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionValuesRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitionKeys", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.partition_keys.len() as i32))?;
    for e in &self.partition_keys {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.apply_distinct {
      o_prot.write_field_begin(&TFieldIdentifier::new("applyDistinct", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_order {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionOrder", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ascending {
      o_prot.write_field_begin(&TFieldIdentifier::new("ascending", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_parts {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxParts", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionValuesRow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionValuesRow {
  pub row: Vec<String>,
}

impl PartitionValuesRow {
  pub fn new(row: Vec<String>) -> PartitionValuesRow {
    PartitionValuesRow {
      row,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionValuesRow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_76 = i_prot.read_string()?;
            val.push(list_elem_76);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionValuesRow.row", &f_1)?;
    let ret = PartitionValuesRow {
      row: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionValuesRow");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.row.len() as i32))?;
    for e in &self.row {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PartitionValuesResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PartitionValuesResponse {
  pub partition_values: Vec<PartitionValuesRow>,
}

impl PartitionValuesResponse {
  pub fn new(partition_values: Vec<PartitionValuesRow>) -> PartitionValuesResponse {
    PartitionValuesResponse {
      partition_values,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PartitionValuesResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<PartitionValuesRow>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PartitionValuesRow> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_77 = PartitionValuesRow::read_from_in_protocol(i_prot)?;
            val.push(list_elem_77);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PartitionValuesResponse.partition_values", &f_1)?;
    let ret = PartitionValuesResponse {
      partition_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PartitionValuesResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitionValues", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.partition_values.len() as i32))?;
    for e in &self.partition_values {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResourceUri
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResourceUri {
  pub resource_type: Option<ResourceType>,
  pub uri: Option<String>,
}

impl ResourceUri {
  pub fn new<F1, F2>(resource_type: F1, uri: F2) -> ResourceUri where F1: Into<Option<ResourceType>>, F2: Into<Option<String>> {
    ResourceUri {
      resource_type: resource_type.into(),
      uri: uri.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResourceUri> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ResourceType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ResourceType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResourceUri {
      resource_type: f_1,
      uri: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResourceUri");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourceType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("uri", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ResourceUri {
  fn default() -> Self {
    ResourceUri{
      resource_type: None,
      uri: Some("".to_owned()),
    }
  }
}

//
// Function
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Function {
  pub function_name: Option<String>,
  pub db_name: Option<String>,
  pub class_name: Option<String>,
  pub owner_name: Option<String>,
  pub owner_type: Option<PrincipalType>,
  pub create_time: Option<i32>,
  pub function_type: Option<FunctionType>,
  pub resource_uris: Option<Vec<ResourceUri>>,
  pub cat_name: Option<String>,
}

impl Function {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(function_name: F1, db_name: F2, class_name: F3, owner_name: F4, owner_type: F5, create_time: F6, function_type: F7, resource_uris: F8, cat_name: F9) -> Function where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<PrincipalType>>, F6: Into<Option<i32>>, F7: Into<Option<FunctionType>>, F8: Into<Option<Vec<ResourceUri>>>, F9: Into<Option<String>> {
    Function {
      function_name: function_name.into(),
      db_name: db_name.into(),
      class_name: class_name.into(),
      owner_name: owner_name.into(),
      owner_type: owner_type.into(),
      create_time: create_time.into(),
      function_type: function_type.into(),
      resource_uris: resource_uris.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Function> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<PrincipalType> = None;
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<FunctionType> = None;
    let mut f_8: Option<Vec<ResourceUri>> = Some(Vec::new());
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = FunctionType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ResourceUri> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_78 = ResourceUri::read_from_in_protocol(i_prot)?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Function {
      function_name: f_1,
      db_name: f_2,
      class_name: f_3,
      owner_name: f_4,
      owner_type: f_5,
      create_time: f_6,
      function_type: f_7,
      resource_uris: f_8,
      cat_name: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Function");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.function_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("functionName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.class_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("className", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerType", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.function_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("functionType", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource_uris {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourceUris", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Function {
  fn default() -> Self {
    Function{
      function_name: Some("".to_owned()),
      db_name: Some("".to_owned()),
      class_name: Some("".to_owned()),
      owner_name: Some("".to_owned()),
      owner_type: None,
      create_time: Some(0),
      function_type: None,
      resource_uris: Some(Vec::new()),
      cat_name: Some("".to_owned()),
    }
  }
}

//
// TxnInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TxnInfo {
  pub id: i64,
  pub state: TxnState,
  pub user: String,
  pub hostname: String,
  pub agent_info: Option<String>,
  pub heartbeat_count: Option<i32>,
  pub meta_info: Option<String>,
  pub started_time: Option<i64>,
  pub last_heartbeat_time: Option<i64>,
}

impl TxnInfo {
  pub fn new<F5, F6, F7, F8, F9>(id: i64, state: TxnState, user: String, hostname: String, agent_info: F5, heartbeat_count: F6, meta_info: F7, started_time: F8, last_heartbeat_time: F9) -> TxnInfo where F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<String>>, F8: Into<Option<i64>>, F9: Into<Option<i64>> {
    TxnInfo {
      id,
      state,
      user,
      hostname,
      agent_info: agent_info.into(),
      heartbeat_count: heartbeat_count.into(),
      meta_info: meta_info.into(),
      started_time: started_time.into(),
      last_heartbeat_time: last_heartbeat_time.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TxnInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<TxnState> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TxnInfo.id", &f_1)?;
    verify_required_field_exists("TxnInfo.state", &f_2)?;
    verify_required_field_exists("TxnInfo.user", &f_3)?;
    verify_required_field_exists("TxnInfo.hostname", &f_4)?;
    let ret = TxnInfo {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      user: f_3.expect("auto-generated code should have checked for presence of required fields"),
      hostname: f_4.expect("auto-generated code should have checked for presence of required fields"),
      agent_info: f_5,
      heartbeat_count: f_6,
      meta_info: f_7,
      started_time: f_8,
      last_heartbeat_time: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TxnInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 2))?;
    self.state.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 3))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hostname", TType::String, 4))?;
    o_prot.write_string(&self.hostname)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.agent_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("agentInfo", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.heartbeat_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatCount", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.meta_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("metaInfo", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedTime", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_heartbeat_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastHeartbeatTime", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetOpenTxnsInfoResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetOpenTxnsInfoResponse {
  pub txn_high_water_mark: i64,
  pub open_txns: Vec<TxnInfo>,
}

impl GetOpenTxnsInfoResponse {
  pub fn new(txn_high_water_mark: i64, open_txns: Vec<TxnInfo>) -> GetOpenTxnsInfoResponse {
    GetOpenTxnsInfoResponse {
      txn_high_water_mark,
      open_txns,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetOpenTxnsInfoResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<TxnInfo>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TxnInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_79 = TxnInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_79);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetOpenTxnsInfoResponse.txn_high_water_mark", &f_1)?;
    verify_required_field_exists("GetOpenTxnsInfoResponse.open_txns", &f_2)?;
    let ret = GetOpenTxnsInfoResponse {
      txn_high_water_mark: f_1.expect("auto-generated code should have checked for presence of required fields"),
      open_txns: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetOpenTxnsInfoResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txn_high_water_mark", TType::I64, 1))?;
    o_prot.write_i64(self.txn_high_water_mark)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("open_txns", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.open_txns.len() as i32))?;
    for e in &self.open_txns {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetOpenTxnsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetOpenTxnsResponse {
  pub txn_high_water_mark: i64,
  pub open_txns: Vec<i64>,
  pub min_open_txn: Option<i64>,
  pub aborted_bits: Vec<u8>,
}

impl GetOpenTxnsResponse {
  pub fn new<F3>(txn_high_water_mark: i64, open_txns: Vec<i64>, min_open_txn: F3, aborted_bits: Vec<u8>) -> GetOpenTxnsResponse where F3: Into<Option<i64>> {
    GetOpenTxnsResponse {
      txn_high_water_mark,
      open_txns,
      min_open_txn: min_open_txn.into(),
      aborted_bits,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetOpenTxnsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<i64>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_80 = i_prot.read_i64()?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetOpenTxnsResponse.txn_high_water_mark", &f_1)?;
    verify_required_field_exists("GetOpenTxnsResponse.open_txns", &f_2)?;
    verify_required_field_exists("GetOpenTxnsResponse.aborted_bits", &f_4)?;
    let ret = GetOpenTxnsResponse {
      txn_high_water_mark: f_1.expect("auto-generated code should have checked for presence of required fields"),
      open_txns: f_2.expect("auto-generated code should have checked for presence of required fields"),
      min_open_txn: f_3,
      aborted_bits: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetOpenTxnsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txn_high_water_mark", TType::I64, 1))?;
    o_prot.write_i64(self.txn_high_water_mark)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("open_txns", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.open_txns.len() as i32))?;
    for e in &self.open_txns {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.min_open_txn {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_open_txn", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("abortedBits", TType::String, 4))?;
    o_prot.write_bytes(&self.aborted_bits)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OpenTxnRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct OpenTxnRequest {
  pub num_txns: i32,
  pub user: String,
  pub hostname: String,
  pub agent_info: Option<String>,
  pub repl_policy: Option<String>,
  pub repl_src_txn_ids: Option<Vec<i64>>,
}

impl OpenTxnRequest {
  pub fn new<F4, F5, F6>(num_txns: i32, user: String, hostname: String, agent_info: F4, repl_policy: F5, repl_src_txn_ids: F6) -> OpenTxnRequest where F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<Vec<i64>>> {
    OpenTxnRequest {
      num_txns,
      user,
      hostname,
      agent_info: agent_info.into(),
      repl_policy: repl_policy.into(),
      repl_src_txn_ids: repl_src_txn_ids.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OpenTxnRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_81 = i_prot.read_i64()?;
            val.push(list_elem_81);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OpenTxnRequest.num_txns", &f_1)?;
    verify_required_field_exists("OpenTxnRequest.user", &f_2)?;
    verify_required_field_exists("OpenTxnRequest.hostname", &f_3)?;
    let ret = OpenTxnRequest {
      num_txns: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user: f_2.expect("auto-generated code should have checked for presence of required fields"),
      hostname: f_3.expect("auto-generated code should have checked for presence of required fields"),
      agent_info: f_4,
      repl_policy: f_5,
      repl_src_txn_ids: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OpenTxnRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_txns", TType::I32, 1))?;
    o_prot.write_i32(self.num_txns)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 2))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hostname", TType::String, 3))?;
    o_prot.write_string(&self.hostname)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.agent_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("agentInfo", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.repl_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("replPolicy", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.repl_src_txn_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("replSrcTxnIds", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// OpenTxnsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct OpenTxnsResponse {
  pub txn_ids: Vec<i64>,
}

impl OpenTxnsResponse {
  pub fn new(txn_ids: Vec<i64>) -> OpenTxnsResponse {
    OpenTxnsResponse {
      txn_ids,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<OpenTxnsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_82 = i_prot.read_i64()?;
            val.push(list_elem_82);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("OpenTxnsResponse.txn_ids", &f_1)?;
    let ret = OpenTxnsResponse {
      txn_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OpenTxnsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txn_ids", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.txn_ids.len() as i32))?;
    for e in &self.txn_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AbortTxnRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AbortTxnRequest {
  pub txnid: i64,
  pub repl_policy: Option<String>,
}

impl AbortTxnRequest {
  pub fn new<F2>(txnid: i64, repl_policy: F2) -> AbortTxnRequest where F2: Into<Option<String>> {
    AbortTxnRequest {
      txnid,
      repl_policy: repl_policy.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AbortTxnRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AbortTxnRequest.txnid", &f_1)?;
    let ret = AbortTxnRequest {
      txnid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      repl_policy: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AbortTxnRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 1))?;
    o_prot.write_i64(self.txnid)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.repl_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("replPolicy", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AbortTxnsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AbortTxnsRequest {
  pub txn_ids: Vec<i64>,
}

impl AbortTxnsRequest {
  pub fn new(txn_ids: Vec<i64>) -> AbortTxnsRequest {
    AbortTxnsRequest {
      txn_ids,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AbortTxnsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = i_prot.read_i64()?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AbortTxnsRequest.txn_ids", &f_1)?;
    let ret = AbortTxnsRequest {
      txn_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AbortTxnsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txn_ids", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.txn_ids.len() as i32))?;
    for e in &self.txn_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CommitTxnRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CommitTxnRequest {
  pub txnid: i64,
  pub repl_policy: Option<String>,
}

impl CommitTxnRequest {
  pub fn new<F2>(txnid: i64, repl_policy: F2) -> CommitTxnRequest where F2: Into<Option<String>> {
    CommitTxnRequest {
      txnid,
      repl_policy: repl_policy.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CommitTxnRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CommitTxnRequest.txnid", &f_1)?;
    let ret = CommitTxnRequest {
      txnid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      repl_policy: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CommitTxnRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 1))?;
    o_prot.write_i64(self.txnid)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.repl_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("replPolicy", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReplTblWriteIdStateRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ReplTblWriteIdStateRequest {
  pub valid_write_idlist: String,
  pub user: String,
  pub host_name: String,
  pub db_name: String,
  pub table_name: String,
  pub part_names: Option<Vec<String>>,
}

impl ReplTblWriteIdStateRequest {
  pub fn new<F6>(valid_write_idlist: String, user: String, host_name: String, db_name: String, table_name: String, part_names: F6) -> ReplTblWriteIdStateRequest where F6: Into<Option<Vec<String>>> {
    ReplTblWriteIdStateRequest {
      valid_write_idlist,
      user,
      host_name,
      db_name,
      table_name,
      part_names: part_names.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReplTblWriteIdStateRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = i_prot.read_string()?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ReplTblWriteIdStateRequest.valid_write_idlist", &f_1)?;
    verify_required_field_exists("ReplTblWriteIdStateRequest.user", &f_2)?;
    verify_required_field_exists("ReplTblWriteIdStateRequest.host_name", &f_3)?;
    verify_required_field_exists("ReplTblWriteIdStateRequest.db_name", &f_4)?;
    verify_required_field_exists("ReplTblWriteIdStateRequest.table_name", &f_5)?;
    let ret = ReplTblWriteIdStateRequest {
      valid_write_idlist: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user: f_2.expect("auto-generated code should have checked for presence of required fields"),
      host_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_5.expect("auto-generated code should have checked for presence of required fields"),
      part_names: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReplTblWriteIdStateRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("validWriteIdlist", TType::String, 1))?;
    o_prot.write_string(&self.valid_write_idlist)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 2))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hostName", TType::String, 3))?;
    o_prot.write_string(&self.host_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 4))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 5))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.part_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("partNames", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetValidWriteIdsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetValidWriteIdsRequest {
  pub full_table_names: Vec<String>,
  pub valid_txn_list: String,
}

impl GetValidWriteIdsRequest {
  pub fn new(full_table_names: Vec<String>, valid_txn_list: String) -> GetValidWriteIdsRequest {
    GetValidWriteIdsRequest {
      full_table_names,
      valid_txn_list,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetValidWriteIdsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_85 = i_prot.read_string()?;
            val.push(list_elem_85);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetValidWriteIdsRequest.full_table_names", &f_1)?;
    verify_required_field_exists("GetValidWriteIdsRequest.valid_txn_list", &f_2)?;
    let ret = GetValidWriteIdsRequest {
      full_table_names: f_1.expect("auto-generated code should have checked for presence of required fields"),
      valid_txn_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetValidWriteIdsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fullTableNames", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.full_table_names.len() as i32))?;
    for e in &self.full_table_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("validTxnList", TType::String, 2))?;
    o_prot.write_string(&self.valid_txn_list)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TableValidWriteIds
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TableValidWriteIds {
  pub full_table_name: String,
  pub write_id_high_water_mark: i64,
  pub invalid_write_ids: Vec<i64>,
  pub min_open_write_id: Option<i64>,
  pub aborted_bits: Vec<u8>,
}

impl TableValidWriteIds {
  pub fn new<F4>(full_table_name: String, write_id_high_water_mark: i64, invalid_write_ids: Vec<i64>, min_open_write_id: F4, aborted_bits: Vec<u8>) -> TableValidWriteIds where F4: Into<Option<i64>> {
    TableValidWriteIds {
      full_table_name,
      write_id_high_water_mark,
      invalid_write_ids,
      min_open_write_id: min_open_write_id.into(),
      aborted_bits,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TableValidWriteIds> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Vec<i64>> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_86 = i_prot.read_i64()?;
            val.push(list_elem_86);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TableValidWriteIds.full_table_name", &f_1)?;
    verify_required_field_exists("TableValidWriteIds.write_id_high_water_mark", &f_2)?;
    verify_required_field_exists("TableValidWriteIds.invalid_write_ids", &f_3)?;
    verify_required_field_exists("TableValidWriteIds.aborted_bits", &f_5)?;
    let ret = TableValidWriteIds {
      full_table_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      write_id_high_water_mark: f_2.expect("auto-generated code should have checked for presence of required fields"),
      invalid_write_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
      min_open_write_id: f_4,
      aborted_bits: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TableValidWriteIds");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fullTableName", TType::String, 1))?;
    o_prot.write_string(&self.full_table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("writeIdHighWaterMark", TType::I64, 2))?;
    o_prot.write_i64(self.write_id_high_water_mark)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("invalidWriteIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.invalid_write_ids.len() as i32))?;
    for e in &self.invalid_write_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.min_open_write_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("minOpenWriteId", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("abortedBits", TType::String, 5))?;
    o_prot.write_bytes(&self.aborted_bits)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetValidWriteIdsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetValidWriteIdsResponse {
  pub tbl_valid_write_ids: Vec<TableValidWriteIds>,
}

impl GetValidWriteIdsResponse {
  pub fn new(tbl_valid_write_ids: Vec<TableValidWriteIds>) -> GetValidWriteIdsResponse {
    GetValidWriteIdsResponse {
      tbl_valid_write_ids,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetValidWriteIdsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TableValidWriteIds>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TableValidWriteIds> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_87 = TableValidWriteIds::read_from_in_protocol(i_prot)?;
            val.push(list_elem_87);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetValidWriteIdsResponse.tbl_valid_write_ids", &f_1)?;
    let ret = GetValidWriteIdsResponse {
      tbl_valid_write_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetValidWriteIdsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblValidWriteIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.tbl_valid_write_ids.len() as i32))?;
    for e in &self.tbl_valid_write_ids {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AllocateTableWriteIdsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AllocateTableWriteIdsRequest {
  pub db_name: String,
  pub table_name: String,
  pub txn_ids: Option<Vec<i64>>,
  pub repl_policy: Option<String>,
  pub src_txn_to_write_id_list: Option<Vec<Box<TxnToWriteId>>>,
}

impl AllocateTableWriteIdsRequest {
  pub fn new<F3, F4, F5>(db_name: String, table_name: String, txn_ids: F3, repl_policy: F4, src_txn_to_write_id_list: F5) -> AllocateTableWriteIdsRequest where F3: Into<Option<Vec<i64>>>, F4: Into<Option<String>>, F5: Into<Option<Vec<Box<TxnToWriteId>>>> {
    AllocateTableWriteIdsRequest {
      db_name,
      table_name,
      txn_ids: txn_ids.into(),
      repl_policy: repl_policy.into(),
      src_txn_to_write_id_list: src_txn_to_write_id_list.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AllocateTableWriteIdsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<i64>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<Box<TxnToWriteId>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_88 = i_prot.read_i64()?;
            val.push(list_elem_88);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TxnToWriteId>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_89 = Box::new(TxnToWriteId::read_from_in_protocol(i_prot)?);
            val.push(list_elem_89);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AllocateTableWriteIdsRequest.db_name", &f_1)?;
    verify_required_field_exists("AllocateTableWriteIdsRequest.table_name", &f_2)?;
    let ret = AllocateTableWriteIdsRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      txn_ids: f_3,
      repl_policy: f_4,
      src_txn_to_write_id_list: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AllocateTableWriteIdsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.txn_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("txnIds", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.repl_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("replPolicy", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.src_txn_to_write_id_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("srcTxnToWriteIdList", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TxnToWriteId
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TxnToWriteId {
  pub txn_id: i64,
  pub write_id: i64,
}

impl TxnToWriteId {
  pub fn new(txn_id: i64, write_id: i64) -> TxnToWriteId {
    TxnToWriteId {
      txn_id,
      write_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TxnToWriteId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TxnToWriteId.txn_id", &f_1)?;
    verify_required_field_exists("TxnToWriteId.write_id", &f_2)?;
    let ret = TxnToWriteId {
      txn_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      write_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TxnToWriteId");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnId", TType::I64, 1))?;
    o_prot.write_i64(self.txn_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("writeId", TType::I64, 2))?;
    o_prot.write_i64(self.write_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AllocateTableWriteIdsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AllocateTableWriteIdsResponse {
  pub txn_to_write_ids: Vec<TxnToWriteId>,
}

impl AllocateTableWriteIdsResponse {
  pub fn new(txn_to_write_ids: Vec<TxnToWriteId>) -> AllocateTableWriteIdsResponse {
    AllocateTableWriteIdsResponse {
      txn_to_write_ids,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AllocateTableWriteIdsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TxnToWriteId>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TxnToWriteId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_90 = TxnToWriteId::read_from_in_protocol(i_prot)?;
            val.push(list_elem_90);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AllocateTableWriteIdsResponse.txn_to_write_ids", &f_1)?;
    let ret = AllocateTableWriteIdsResponse {
      txn_to_write_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AllocateTableWriteIdsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnToWriteIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.txn_to_write_ids.len() as i32))?;
    for e in &self.txn_to_write_ids {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LockComponent
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LockComponent {
  pub type_: LockType,
  pub level: LockLevel,
  pub dbname: String,
  pub tablename: Option<String>,
  pub partitionname: Option<String>,
  pub operation_type: Option<DataOperationType>,
  pub is_transactional: Option<bool>,
  pub is_dynamic_partition_write: Option<bool>,
}

impl LockComponent {
  pub fn new<F4, F5, F6, F7, F8>(type_: LockType, level: LockLevel, dbname: String, tablename: F4, partitionname: F5, operation_type: F6, is_transactional: F7, is_dynamic_partition_write: F8) -> LockComponent where F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<DataOperationType>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    LockComponent {
      type_,
      level,
      dbname,
      tablename: tablename.into(),
      partitionname: partitionname.into(),
      operation_type: operation_type.into(),
      is_transactional: is_transactional.into(),
      is_dynamic_partition_write: is_dynamic_partition_write.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LockComponent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<LockType> = None;
    let mut f_2: Option<LockLevel> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<DataOperationType> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = LockType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = LockLevel::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = DataOperationType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LockComponent.type_", &f_1)?;
    verify_required_field_exists("LockComponent.level", &f_2)?;
    verify_required_field_exists("LockComponent.dbname", &f_3)?;
    let ret = LockComponent {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      level: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_3.expect("auto-generated code should have checked for presence of required fields"),
      tablename: f_4,
      partitionname: f_5,
      operation_type: f_6,
      is_transactional: f_7,
      is_dynamic_partition_write: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LockComponent");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("level", TType::I32, 2))?;
    self.level.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 3))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.tablename {
      o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partitionname {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionname", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.operation_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationType", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_transactional {
      o_prot.write_field_begin(&TFieldIdentifier::new("isTransactional", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_dynamic_partition_write {
      o_prot.write_field_begin(&TFieldIdentifier::new("isDynamicPartitionWrite", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LockRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LockRequest {
  pub component: Vec<LockComponent>,
  pub txnid: Option<i64>,
  pub user: String,
  pub hostname: String,
  pub agent_info: Option<String>,
}

impl LockRequest {
  pub fn new<F2, F5>(component: Vec<LockComponent>, txnid: F2, user: String, hostname: String, agent_info: F5) -> LockRequest where F2: Into<Option<i64>>, F5: Into<Option<String>> {
    LockRequest {
      component,
      txnid: txnid.into(),
      user,
      hostname,
      agent_info: agent_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LockRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<LockComponent>> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<LockComponent> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_91 = LockComponent::read_from_in_protocol(i_prot)?;
            val.push(list_elem_91);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LockRequest.component", &f_1)?;
    verify_required_field_exists("LockRequest.user", &f_3)?;
    verify_required_field_exists("LockRequest.hostname", &f_4)?;
    let ret = LockRequest {
      component: f_1.expect("auto-generated code should have checked for presence of required fields"),
      txnid: f_2,
      user: f_3.expect("auto-generated code should have checked for presence of required fields"),
      hostname: f_4.expect("auto-generated code should have checked for presence of required fields"),
      agent_info: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LockRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("component", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.component.len() as i32))?;
    for e in &self.component {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.txnid {
      o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 3))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hostname", TType::String, 4))?;
    o_prot.write_string(&self.hostname)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.agent_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("agentInfo", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// LockResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LockResponse {
  pub lockid: i64,
  pub state: LockState,
}

impl LockResponse {
  pub fn new(lockid: i64, state: LockState) -> LockResponse {
    LockResponse {
      lockid,
      state,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LockResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<LockState> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = LockState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LockResponse.lockid", &f_1)?;
    verify_required_field_exists("LockResponse.state", &f_2)?;
    let ret = LockResponse {
      lockid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      state: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LockResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lockid", TType::I64, 1))?;
    o_prot.write_i64(self.lockid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 2))?;
    self.state.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CheckLockRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CheckLockRequest {
  pub lockid: i64,
  pub txnid: Option<i64>,
  pub elapsed_ms: Option<i64>,
}

impl CheckLockRequest {
  pub fn new<F2, F3>(lockid: i64, txnid: F2, elapsed_ms: F3) -> CheckLockRequest where F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    CheckLockRequest {
      lockid,
      txnid: txnid.into(),
      elapsed_ms: elapsed_ms.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CheckLockRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CheckLockRequest.lockid", &f_1)?;
    let ret = CheckLockRequest {
      lockid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      txnid: f_2,
      elapsed_ms: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CheckLockRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lockid", TType::I64, 1))?;
    o_prot.write_i64(self.lockid)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.txnid {
      o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.elapsed_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("elapsed_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UnlockRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UnlockRequest {
  pub lockid: i64,
}

impl UnlockRequest {
  pub fn new(lockid: i64) -> UnlockRequest {
    UnlockRequest {
      lockid,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UnlockRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UnlockRequest.lockid", &f_1)?;
    let ret = UnlockRequest {
      lockid: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UnlockRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lockid", TType::I64, 1))?;
    o_prot.write_i64(self.lockid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShowLocksRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShowLocksRequest {
  pub dbname: Option<String>,
  pub tablename: Option<String>,
  pub partname: Option<String>,
  pub is_extended: Option<bool>,
}

impl ShowLocksRequest {
  pub fn new<F1, F2, F3, F4>(dbname: F1, tablename: F2, partname: F3, is_extended: F4) -> ShowLocksRequest where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<bool>> {
    ShowLocksRequest {
      dbname: dbname.into(),
      tablename: tablename.into(),
      partname: partname.into(),
      is_extended: is_extended.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShowLocksRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShowLocksRequest {
      dbname: f_1,
      tablename: f_2,
      partname: f_3,
      is_extended: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShowLocksRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dbname {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tablename {
      o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partname {
      o_prot.write_field_begin(&TFieldIdentifier::new("partname", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_extended {
      o_prot.write_field_begin(&TFieldIdentifier::new("isExtended", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ShowLocksRequest {
  fn default() -> Self {
    ShowLocksRequest{
      dbname: Some("".to_owned()),
      tablename: Some("".to_owned()),
      partname: Some("".to_owned()),
      is_extended: Some(false),
    }
  }
}

//
// ShowLocksResponseElement
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShowLocksResponseElement {
  pub lockid: i64,
  pub dbname: String,
  pub tablename: Option<String>,
  pub partname: Option<String>,
  pub state: LockState,
  pub type_: LockType,
  pub txnid: Option<i64>,
  pub lastheartbeat: i64,
  pub acquiredat: Option<i64>,
  pub user: String,
  pub hostname: String,
  pub heartbeat_count: Option<i32>,
  pub agent_info: Option<String>,
  pub blocked_by_ext_id: Option<i64>,
  pub blocked_by_int_id: Option<i64>,
  pub lock_id_internal: Option<i64>,
}

impl ShowLocksResponseElement {
  pub fn new<F3, F4, F7, F9, F12, F13, F14, F15, F16>(lockid: i64, dbname: String, tablename: F3, partname: F4, state: LockState, type_: LockType, txnid: F7, lastheartbeat: i64, acquiredat: F9, user: String, hostname: String, heartbeat_count: F12, agent_info: F13, blocked_by_ext_id: F14, blocked_by_int_id: F15, lock_id_internal: F16) -> ShowLocksResponseElement where F3: Into<Option<String>>, F4: Into<Option<String>>, F7: Into<Option<i64>>, F9: Into<Option<i64>>, F12: Into<Option<i32>>, F13: Into<Option<String>>, F14: Into<Option<i64>>, F15: Into<Option<i64>>, F16: Into<Option<i64>> {
    ShowLocksResponseElement {
      lockid,
      dbname,
      tablename: tablename.into(),
      partname: partname.into(),
      state,
      type_,
      txnid: txnid.into(),
      lastheartbeat,
      acquiredat: acquiredat.into(),
      user,
      hostname,
      heartbeat_count: heartbeat_count.into(),
      agent_info: agent_info.into(),
      blocked_by_ext_id: blocked_by_ext_id.into(),
      blocked_by_int_id: blocked_by_int_id.into(),
      lock_id_internal: lock_id_internal.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShowLocksResponseElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<LockState> = None;
    let mut f_6: Option<LockType> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<String> = None;
    let mut f_14: Option<i64> = None;
    let mut f_15: Option<i64> = None;
    let mut f_16: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = LockState::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = LockType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShowLocksResponseElement.lockid", &f_1)?;
    verify_required_field_exists("ShowLocksResponseElement.dbname", &f_2)?;
    verify_required_field_exists("ShowLocksResponseElement.state", &f_5)?;
    verify_required_field_exists("ShowLocksResponseElement.type_", &f_6)?;
    verify_required_field_exists("ShowLocksResponseElement.lastheartbeat", &f_8)?;
    verify_required_field_exists("ShowLocksResponseElement.user", &f_10)?;
    verify_required_field_exists("ShowLocksResponseElement.hostname", &f_11)?;
    let ret = ShowLocksResponseElement {
      lockid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tablename: f_3,
      partname: f_4,
      state: f_5.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_6.expect("auto-generated code should have checked for presence of required fields"),
      txnid: f_7,
      lastheartbeat: f_8.expect("auto-generated code should have checked for presence of required fields"),
      acquiredat: f_9,
      user: f_10.expect("auto-generated code should have checked for presence of required fields"),
      hostname: f_11.expect("auto-generated code should have checked for presence of required fields"),
      heartbeat_count: f_12,
      agent_info: f_13,
      blocked_by_ext_id: f_14,
      blocked_by_int_id: f_15,
      lock_id_internal: f_16,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShowLocksResponseElement");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lockid", TType::I64, 1))?;
    o_prot.write_i64(self.lockid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.tablename {
      o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partname {
      o_prot.write_field_begin(&TFieldIdentifier::new("partname", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 5))?;
    self.state.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 6))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.txnid {
      o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("lastheartbeat", TType::I64, 8))?;
    o_prot.write_i64(self.lastheartbeat)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.acquiredat {
      o_prot.write_field_begin(&TFieldIdentifier::new("acquiredat", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 10))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hostname", TType::String, 11))?;
    o_prot.write_string(&self.hostname)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.heartbeat_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatCount", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.agent_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("agentInfo", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.blocked_by_ext_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("blockedByExtId", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.blocked_by_int_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("blockedByIntId", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.lock_id_internal {
      o_prot.write_field_begin(&TFieldIdentifier::new("lockIdInternal", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShowLocksResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShowLocksResponse {
  pub locks: Option<Vec<ShowLocksResponseElement>>,
}

impl ShowLocksResponse {
  pub fn new<F1>(locks: F1) -> ShowLocksResponse where F1: Into<Option<Vec<ShowLocksResponseElement>>> {
    ShowLocksResponse {
      locks: locks.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShowLocksResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ShowLocksResponseElement>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ShowLocksResponseElement> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_92 = ShowLocksResponseElement::read_from_in_protocol(i_prot)?;
            val.push(list_elem_92);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShowLocksResponse {
      locks: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShowLocksResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.locks {
      o_prot.write_field_begin(&TFieldIdentifier::new("locks", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ShowLocksResponse {
  fn default() -> Self {
    ShowLocksResponse{
      locks: Some(Vec::new()),
    }
  }
}

//
// HeartbeatRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HeartbeatRequest {
  pub lockid: Option<i64>,
  pub txnid: Option<i64>,
}

impl HeartbeatRequest {
  pub fn new<F1, F2>(lockid: F1, txnid: F2) -> HeartbeatRequest where F1: Into<Option<i64>>, F2: Into<Option<i64>> {
    HeartbeatRequest {
      lockid: lockid.into(),
      txnid: txnid.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeartbeatRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HeartbeatRequest {
      lockid: f_1,
      txnid: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeartbeatRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.lockid {
      o_prot.write_field_begin(&TFieldIdentifier::new("lockid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.txnid {
      o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for HeartbeatRequest {
  fn default() -> Self {
    HeartbeatRequest{
      lockid: Some(0),
      txnid: Some(0),
    }
  }
}

//
// HeartbeatTxnRangeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HeartbeatTxnRangeRequest {
  pub min: i64,
  pub max: i64,
}

impl HeartbeatTxnRangeRequest {
  pub fn new(min: i64, max: i64) -> HeartbeatTxnRangeRequest {
    HeartbeatTxnRangeRequest {
      min,
      max,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeartbeatTxnRangeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeartbeatTxnRangeRequest.min", &f_1)?;
    verify_required_field_exists("HeartbeatTxnRangeRequest.max", &f_2)?;
    let ret = HeartbeatTxnRangeRequest {
      min: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeartbeatTxnRangeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("min", TType::I64, 1))?;
    o_prot.write_i64(self.min)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max", TType::I64, 2))?;
    o_prot.write_i64(self.max)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HeartbeatTxnRangeResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HeartbeatTxnRangeResponse {
  pub aborted: BTreeSet<i64>,
  pub nosuch: BTreeSet<i64>,
}

impl HeartbeatTxnRangeResponse {
  pub fn new(aborted: BTreeSet<i64>, nosuch: BTreeSet<i64>) -> HeartbeatTxnRangeResponse {
    HeartbeatTxnRangeResponse {
      aborted,
      nosuch,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HeartbeatTxnRangeResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeSet<i64>> = None;
    let mut f_2: Option<BTreeSet<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<i64> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_93 = i_prot.read_i64()?;
            val.insert(set_elem_93);
          }
          i_prot.read_set_end()?;
          f_1 = Some(val);
        },
        2 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<i64> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_94 = i_prot.read_i64()?;
            val.insert(set_elem_94);
          }
          i_prot.read_set_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("HeartbeatTxnRangeResponse.aborted", &f_1)?;
    verify_required_field_exists("HeartbeatTxnRangeResponse.nosuch", &f_2)?;
    let ret = HeartbeatTxnRangeResponse {
      aborted: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nosuch: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HeartbeatTxnRangeResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("aborted", TType::Set, 1))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::I64, self.aborted.len() as i32))?;
    for e in &self.aborted {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_set_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nosuch", TType::Set, 2))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::I64, self.nosuch.len() as i32))?;
    for e in &self.nosuch {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_set_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CompactionRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactionRequest {
  pub dbname: String,
  pub tablename: String,
  pub partitionname: Option<String>,
  pub type_: CompactionType,
  pub runas: Option<String>,
  pub properties: Option<BTreeMap<String, String>>,
}

impl CompactionRequest {
  pub fn new<F3, F5, F6>(dbname: String, tablename: String, partitionname: F3, type_: CompactionType, runas: F5, properties: F6) -> CompactionRequest where F3: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<BTreeMap<String, String>>> {
    CompactionRequest {
      dbname,
      tablename,
      partitionname: partitionname.into(),
      type_,
      runas: runas.into(),
      properties: properties.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompactionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<CompactionType> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = CompactionType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_95 = i_prot.read_string()?;
            let map_val_96 = i_prot.read_string()?;
            val.insert(map_key_95, map_val_96);
          }
          i_prot.read_map_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CompactionRequest.dbname", &f_1)?;
    verify_required_field_exists("CompactionRequest.tablename", &f_2)?;
    verify_required_field_exists("CompactionRequest.type_", &f_4)?;
    let ret = CompactionRequest {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tablename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      partitionname: f_3,
      type_: f_4.expect("auto-generated code should have checked for presence of required fields"),
      runas: f_5,
      properties: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompactionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 2))?;
    o_prot.write_string(&self.tablename)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partitionname {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionname", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 4))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.runas {
      o_prot.write_field_begin(&TFieldIdentifier::new("runas", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 6))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CompactionResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactionResponse {
  pub id: i64,
  pub state: String,
  pub accepted: bool,
}

impl CompactionResponse {
  pub fn new(id: i64, state: String, accepted: bool) -> CompactionResponse {
    CompactionResponse {
      id,
      state,
      accepted,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompactionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CompactionResponse.id", &f_1)?;
    verify_required_field_exists("CompactionResponse.state", &f_2)?;
    verify_required_field_exists("CompactionResponse.accepted", &f_3)?;
    let ret = CompactionResponse {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      accepted: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompactionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::String, 2))?;
    o_prot.write_string(&self.state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("accepted", TType::Bool, 3))?;
    o_prot.write_bool(self.accepted)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShowCompactRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShowCompactRequest {
}

impl ShowCompactRequest {
  pub fn new() -> ShowCompactRequest {
    ShowCompactRequest {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShowCompactRequest> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ShowCompactRequest {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShowCompactRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ShowCompactRequest {
  fn default() -> Self {
    ShowCompactRequest{}
  }
}

//
// ShowCompactResponseElement
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShowCompactResponseElement {
  pub dbname: String,
  pub tablename: String,
  pub partitionname: Option<String>,
  pub type_: CompactionType,
  pub state: String,
  pub workerid: Option<String>,
  pub start: Option<i64>,
  pub run_as: Option<String>,
  pub hightest_txn_id: Option<i64>,
  pub meta_info: Option<String>,
  pub end_time: Option<i64>,
  pub hadoop_job_id: Option<String>,
  pub id: Option<i64>,
}

impl ShowCompactResponseElement {
  pub fn new<F3, F6, F7, F8, F9, F10, F11, F12, F13>(dbname: String, tablename: String, partitionname: F3, type_: CompactionType, state: String, workerid: F6, start: F7, run_as: F8, hightest_txn_id: F9, meta_info: F10, end_time: F11, hadoop_job_id: F12, id: F13) -> ShowCompactResponseElement where F3: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<i64>>, F8: Into<Option<String>>, F9: Into<Option<i64>>, F10: Into<Option<String>>, F11: Into<Option<i64>>, F12: Into<Option<String>>, F13: Into<Option<i64>> {
    ShowCompactResponseElement {
      dbname,
      tablename,
      partitionname: partitionname.into(),
      type_,
      state,
      workerid: workerid.into(),
      start: start.into(),
      run_as: run_as.into(),
      hightest_txn_id: hightest_txn_id.into(),
      meta_info: meta_info.into(),
      end_time: end_time.into(),
      hadoop_job_id: hadoop_job_id.into(),
      id: id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShowCompactResponseElement> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<CompactionType> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<i64> = None;
    let mut f_12: Option<String> = None;
    let mut f_13: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = CompactionType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShowCompactResponseElement.dbname", &f_1)?;
    verify_required_field_exists("ShowCompactResponseElement.tablename", &f_2)?;
    verify_required_field_exists("ShowCompactResponseElement.type_", &f_4)?;
    verify_required_field_exists("ShowCompactResponseElement.state", &f_5)?;
    let ret = ShowCompactResponseElement {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tablename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      partitionname: f_3,
      type_: f_4.expect("auto-generated code should have checked for presence of required fields"),
      state: f_5.expect("auto-generated code should have checked for presence of required fields"),
      workerid: f_6,
      start: f_7,
      run_as: f_8,
      hightest_txn_id: f_9,
      meta_info: f_10,
      end_time: f_11,
      hadoop_job_id: f_12,
      id: f_13,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShowCompactResponseElement");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 2))?;
    o_prot.write_string(&self.tablename)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partitionname {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionname", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 4))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::String, 5))?;
    o_prot.write_string(&self.state)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.workerid {
      o_prot.write_field_begin(&TFieldIdentifier::new("workerid", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start {
      o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_as {
      o_prot.write_field_begin(&TFieldIdentifier::new("runAs", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hightest_txn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("hightestTxnId", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.meta_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("metaInfo", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.end_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("endTime", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hadoop_job_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("hadoopJobId", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ShowCompactResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ShowCompactResponse {
  pub compacts: Vec<ShowCompactResponseElement>,
}

impl ShowCompactResponse {
  pub fn new(compacts: Vec<ShowCompactResponseElement>) -> ShowCompactResponse {
    ShowCompactResponse {
      compacts,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ShowCompactResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ShowCompactResponseElement>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ShowCompactResponseElement> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_97 = ShowCompactResponseElement::read_from_in_protocol(i_prot)?;
            val.push(list_elem_97);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ShowCompactResponse.compacts", &f_1)?;
    let ret = ShowCompactResponse {
      compacts: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ShowCompactResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compacts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.compacts.len() as i32))?;
    for e in &self.compacts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AddDynamicPartitions
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddDynamicPartitions {
  pub txnid: i64,
  pub writeid: i64,
  pub dbname: String,
  pub tablename: String,
  pub partitionnames: Vec<String>,
  pub operation_type: Option<DataOperationType>,
}

impl AddDynamicPartitions {
  pub fn new<F6>(txnid: i64, writeid: i64, dbname: String, tablename: String, partitionnames: Vec<String>, operation_type: F6) -> AddDynamicPartitions where F6: Into<Option<DataOperationType>> {
    AddDynamicPartitions {
      txnid,
      writeid,
      dbname,
      tablename,
      partitionnames,
      operation_type: operation_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AddDynamicPartitions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<DataOperationType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_98 = i_prot.read_string()?;
            val.push(list_elem_98);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = DataOperationType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AddDynamicPartitions.txnid", &f_1)?;
    verify_required_field_exists("AddDynamicPartitions.writeid", &f_2)?;
    verify_required_field_exists("AddDynamicPartitions.dbname", &f_3)?;
    verify_required_field_exists("AddDynamicPartitions.tablename", &f_4)?;
    verify_required_field_exists("AddDynamicPartitions.partitionnames", &f_5)?;
    let ret = AddDynamicPartitions {
      txnid: f_1.expect("auto-generated code should have checked for presence of required fields"),
      writeid: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_3.expect("auto-generated code should have checked for presence of required fields"),
      tablename: f_4.expect("auto-generated code should have checked for presence of required fields"),
      partitionnames: f_5.expect("auto-generated code should have checked for presence of required fields"),
      operation_type: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddDynamicPartitions");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 1))?;
    o_prot.write_i64(self.txnid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("writeid", TType::I64, 2))?;
    o_prot.write_i64(self.writeid)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 3))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 4))?;
    o_prot.write_string(&self.tablename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitionnames", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.partitionnames.len() as i32))?;
    for e in &self.partitionnames {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.operation_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationType", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BasicTxnInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BasicTxnInfo {
  pub isnull: bool,
  pub time: Option<i64>,
  pub txnid: Option<i64>,
  pub dbname: Option<String>,
  pub tablename: Option<String>,
  pub partitionname: Option<String>,
}

impl BasicTxnInfo {
  pub fn new<F2, F3, F4, F5, F6>(isnull: bool, time: F2, txnid: F3, dbname: F4, tablename: F5, partitionname: F6) -> BasicTxnInfo where F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    BasicTxnInfo {
      isnull,
      time: time.into(),
      txnid: txnid.into(),
      dbname: dbname.into(),
      tablename: tablename.into(),
      partitionname: partitionname.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BasicTxnInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BasicTxnInfo.isnull", &f_1)?;
    let ret = BasicTxnInfo {
      isnull: f_1.expect("auto-generated code should have checked for presence of required fields"),
      time: f_2,
      txnid: f_3,
      dbname: f_4,
      tablename: f_5,
      partitionname: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BasicTxnInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isnull", TType::Bool, 1))?;
    o_prot.write_bool(self.isnull)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.time {
      o_prot.write_field_begin(&TFieldIdentifier::new("time", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.txnid {
      o_prot.write_field_begin(&TFieldIdentifier::new("txnid", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dbname {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tablename {
      o_prot.write_field_begin(&TFieldIdentifier::new("tablename", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partitionname {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionname", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CreationMetadata
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CreationMetadata {
  pub cat_name: String,
  pub db_name: String,
  pub tbl_name: String,
  pub tables_used: BTreeSet<String>,
  pub valid_txn_list: Option<String>,
  pub materialization_time: Option<i64>,
}

impl CreationMetadata {
  pub fn new<F5, F6>(cat_name: String, db_name: String, tbl_name: String, tables_used: BTreeSet<String>, valid_txn_list: F5, materialization_time: F6) -> CreationMetadata where F5: Into<Option<String>>, F6: Into<Option<i64>> {
    CreationMetadata {
      cat_name,
      db_name,
      tbl_name,
      tables_used,
      valid_txn_list: valid_txn_list.into(),
      materialization_time: materialization_time.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CreationMetadata> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<BTreeSet<String>> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<String> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_99 = i_prot.read_string()?;
            val.insert(set_elem_99);
          }
          i_prot.read_set_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CreationMetadata.cat_name", &f_1)?;
    verify_required_field_exists("CreationMetadata.db_name", &f_2)?;
    verify_required_field_exists("CreationMetadata.tbl_name", &f_3)?;
    verify_required_field_exists("CreationMetadata.tables_used", &f_4)?;
    let ret = CreationMetadata {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      tables_used: f_4.expect("auto-generated code should have checked for presence of required fields"),
      valid_txn_list: f_5,
      materialization_time: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CreationMetadata");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
    o_prot.write_string(&self.cat_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 3))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablesUsed", TType::Set, 4))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::String, self.tables_used.len() as i32))?;
    for e in &self.tables_used {
      o_prot.write_string(e)?;
    }
    o_prot.write_set_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.valid_txn_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("validTxnList", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.materialization_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("materializationTime", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotificationEventRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationEventRequest {
  pub last_event: i64,
  pub max_events: Option<i32>,
}

impl NotificationEventRequest {
  pub fn new<F2>(last_event: i64, max_events: F2) -> NotificationEventRequest where F2: Into<Option<i32>> {
    NotificationEventRequest {
      last_event,
      max_events: max_events.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationEventRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotificationEventRequest.last_event", &f_1)?;
    let ret = NotificationEventRequest {
      last_event: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_events: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationEventRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lastEvent", TType::I64, 1))?;
    o_prot.write_i64(self.last_event)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.max_events {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxEvents", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotificationEvent
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationEvent {
  pub event_id: i64,
  pub event_time: i32,
  pub event_type: String,
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub message: String,
  pub message_format: Option<String>,
  pub cat_name: Option<String>,
}

impl NotificationEvent {
  pub fn new<F4, F5, F7, F8>(event_id: i64, event_time: i32, event_type: String, db_name: F4, table_name: F5, message: String, message_format: F7, cat_name: F8) -> NotificationEvent where F4: Into<Option<String>>, F5: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>> {
    NotificationEvent {
      event_id,
      event_time,
      event_type,
      db_name: db_name.into(),
      table_name: table_name.into(),
      message,
      message_format: message_format.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotificationEvent.event_id", &f_1)?;
    verify_required_field_exists("NotificationEvent.event_time", &f_2)?;
    verify_required_field_exists("NotificationEvent.event_type", &f_3)?;
    verify_required_field_exists("NotificationEvent.message", &f_6)?;
    let ret = NotificationEvent {
      event_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      event_time: f_2.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_4,
      table_name: f_5,
      message: f_6.expect("auto-generated code should have checked for presence of required fields"),
      message_format: f_7,
      cat_name: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventId", TType::I64, 1))?;
    o_prot.write_i64(self.event_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventTime", TType::I32, 2))?;
    o_prot.write_i32(self.event_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::String, 3))?;
    o_prot.write_string(&self.event_type)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 6))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.message_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("messageFormat", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotificationEventResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationEventResponse {
  pub events: Vec<NotificationEvent>,
}

impl NotificationEventResponse {
  pub fn new(events: Vec<NotificationEvent>) -> NotificationEventResponse {
    NotificationEventResponse {
      events,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationEventResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<NotificationEvent>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<NotificationEvent> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_100 = NotificationEvent::read_from_in_protocol(i_prot)?;
            val.push(list_elem_100);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotificationEventResponse.events", &f_1)?;
    let ret = NotificationEventResponse {
      events: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationEventResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("events", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.events.len() as i32))?;
    for e in &self.events {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CurrentNotificationEventId
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CurrentNotificationEventId {
  pub event_id: i64,
}

impl CurrentNotificationEventId {
  pub fn new(event_id: i64) -> CurrentNotificationEventId {
    CurrentNotificationEventId {
      event_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CurrentNotificationEventId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CurrentNotificationEventId.event_id", &f_1)?;
    let ret = CurrentNotificationEventId {
      event_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CurrentNotificationEventId");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventId", TType::I64, 1))?;
    o_prot.write_i64(self.event_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotificationEventsCountRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationEventsCountRequest {
  pub from_event_id: i64,
  pub db_name: String,
  pub cat_name: Option<String>,
}

impl NotificationEventsCountRequest {
  pub fn new<F3>(from_event_id: i64, db_name: String, cat_name: F3) -> NotificationEventsCountRequest where F3: Into<Option<String>> {
    NotificationEventsCountRequest {
      from_event_id,
      db_name,
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationEventsCountRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotificationEventsCountRequest.from_event_id", &f_1)?;
    verify_required_field_exists("NotificationEventsCountRequest.db_name", &f_2)?;
    let ret = NotificationEventsCountRequest {
      from_event_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cat_name: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationEventsCountRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fromEventId", TType::I64, 1))?;
    o_prot.write_i64(self.from_event_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// NotificationEventsCountResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NotificationEventsCountResponse {
  pub events_count: i64,
}

impl NotificationEventsCountResponse {
  pub fn new(events_count: i64) -> NotificationEventsCountResponse {
    NotificationEventsCountResponse {
      events_count,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NotificationEventsCountResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("NotificationEventsCountResponse.events_count", &f_1)?;
    let ret = NotificationEventsCountResponse {
      events_count: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NotificationEventsCountResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventsCount", TType::I64, 1))?;
    o_prot.write_i64(self.events_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// InsertEventRequestData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InsertEventRequestData {
  pub replace: Option<bool>,
  pub files_added: Vec<String>,
  pub files_added_checksum: Option<Vec<String>>,
}

impl InsertEventRequestData {
  pub fn new<F1, F3>(replace: F1, files_added: Vec<String>, files_added_checksum: F3) -> InsertEventRequestData where F1: Into<Option<bool>>, F3: Into<Option<Vec<String>>> {
    InsertEventRequestData {
      replace: replace.into(),
      files_added,
      files_added_checksum: files_added_checksum.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InsertEventRequestData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_101 = i_prot.read_string()?;
            val.push(list_elem_101);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_102 = i_prot.read_string()?;
            val.push(list_elem_102);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("InsertEventRequestData.files_added", &f_2)?;
    let ret = InsertEventRequestData {
      replace: f_1,
      files_added: f_2.expect("auto-generated code should have checked for presence of required fields"),
      files_added_checksum: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InsertEventRequestData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.replace {
      o_prot.write_field_begin(&TFieldIdentifier::new("replace", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("filesAdded", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.files_added.len() as i32))?;
    for e in &self.files_added {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.files_added_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("filesAddedChecksum", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FireEventRequestData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum FireEventRequestData {
  InsertData(InsertEventRequestData),
}

impl FireEventRequestData {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FireEventRequestData> {
    let mut ret: Option<FireEventRequestData> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InsertEventRequestData::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(FireEventRequestData::InsertData(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote FireEventRequestData"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote FireEventRequestData"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FireEventRequestData");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      FireEventRequestData::InsertData(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("insertData", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FireEventRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FireEventRequest {
  pub successful: bool,
  pub data: FireEventRequestData,
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub partition_vals: Option<Vec<String>>,
  pub cat_name: Option<String>,
}

impl FireEventRequest {
  pub fn new<F3, F4, F5, F6>(successful: bool, data: FireEventRequestData, db_name: F3, table_name: F4, partition_vals: F5, cat_name: F6) -> FireEventRequest where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<Vec<String>>>, F6: Into<Option<String>> {
    FireEventRequest {
      successful,
      data,
      db_name: db_name.into(),
      table_name: table_name.into(),
      partition_vals: partition_vals.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FireEventRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<FireEventRequestData> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FireEventRequestData::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_103 = i_prot.read_string()?;
            val.push(list_elem_103);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("FireEventRequest.successful", &f_1)?;
    verify_required_field_exists("FireEventRequest.data", &f_2)?;
    let ret = FireEventRequest {
      successful: f_1.expect("auto-generated code should have checked for presence of required fields"),
      data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_3,
      table_name: f_4,
      partition_vals: f_5,
      cat_name: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FireEventRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("successful", TType::Bool, 1))?;
    o_prot.write_bool(self.successful)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Struct, 2))?;
    self.data.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_vals {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionVals", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FireEventResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FireEventResponse {
}

impl FireEventResponse {
  pub fn new() -> FireEventResponse {
    FireEventResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FireEventResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FireEventResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FireEventResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FireEventResponse {
  fn default() -> Self {
    FireEventResponse{}
  }
}

//
// MetadataPpdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MetadataPpdResult {
  pub metadata: Option<Vec<u8>>,
  pub include_bitset: Option<Vec<u8>>,
}

impl MetadataPpdResult {
  pub fn new<F1, F2>(metadata: F1, include_bitset: F2) -> MetadataPpdResult where F1: Into<Option<Vec<u8>>>, F2: Into<Option<Vec<u8>>> {
    MetadataPpdResult {
      metadata: metadata.into(),
      include_bitset: include_bitset.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MetadataPpdResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MetadataPpdResult {
      metadata: f_1,
      include_bitset: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MetadataPpdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("metadata", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.include_bitset {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeBitset", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MetadataPpdResult {
  fn default() -> Self {
    MetadataPpdResult{
      metadata: Some(Vec::new()),
      include_bitset: Some(Vec::new()),
    }
  }
}

//
// GetFileMetadataByExprResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetFileMetadataByExprResult {
  pub metadata: BTreeMap<i64, MetadataPpdResult>,
  pub is_supported: bool,
}

impl GetFileMetadataByExprResult {
  pub fn new(metadata: BTreeMap<i64, MetadataPpdResult>, is_supported: bool) -> GetFileMetadataByExprResult {
    GetFileMetadataByExprResult {
      metadata,
      is_supported,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetFileMetadataByExprResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<i64, MetadataPpdResult>> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, MetadataPpdResult> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_104 = i_prot.read_i64()?;
            let map_val_105 = MetadataPpdResult::read_from_in_protocol(i_prot)?;
            val.insert(map_key_104, map_val_105);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetFileMetadataByExprResult.metadata", &f_1)?;
    verify_required_field_exists("GetFileMetadataByExprResult.is_supported", &f_2)?;
    let ret = GetFileMetadataByExprResult {
      metadata: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_supported: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetFileMetadataByExprResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("metadata", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::Struct, self.metadata.len() as i32))?;
    for (k, v) in &self.metadata {
      o_prot.write_i64(*k)?;
      v.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isSupported", TType::Bool, 2))?;
    o_prot.write_bool(self.is_supported)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetFileMetadataByExprRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetFileMetadataByExprRequest {
  pub file_ids: Vec<i64>,
  pub expr: Vec<u8>,
  pub do_get_footers: Option<bool>,
  pub type_: Option<FileMetadataExprType>,
}

impl GetFileMetadataByExprRequest {
  pub fn new<F3, F4>(file_ids: Vec<i64>, expr: Vec<u8>, do_get_footers: F3, type_: F4) -> GetFileMetadataByExprRequest where F3: Into<Option<bool>>, F4: Into<Option<FileMetadataExprType>> {
    GetFileMetadataByExprRequest {
      file_ids,
      expr,
      do_get_footers: do_get_footers.into(),
      type_: type_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetFileMetadataByExprRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<FileMetadataExprType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_106 = i_prot.read_i64()?;
            val.push(list_elem_106);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = FileMetadataExprType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetFileMetadataByExprRequest.file_ids", &f_1)?;
    verify_required_field_exists("GetFileMetadataByExprRequest.expr", &f_2)?;
    let ret = GetFileMetadataByExprRequest {
      file_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      expr: f_2.expect("auto-generated code should have checked for presence of required fields"),
      do_get_footers: f_3,
      type_: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetFileMetadataByExprRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.file_ids.len() as i32))?;
    for e in &self.file_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expr", TType::String, 2))?;
    o_prot.write_bytes(&self.expr)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.do_get_footers {
      o_prot.write_field_begin(&TFieldIdentifier::new("doGetFooters", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetFileMetadataResult {
  pub metadata: BTreeMap<i64, Vec<u8>>,
  pub is_supported: bool,
}

impl GetFileMetadataResult {
  pub fn new(metadata: BTreeMap<i64, Vec<u8>>, is_supported: bool) -> GetFileMetadataResult {
    GetFileMetadataResult {
      metadata,
      is_supported,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetFileMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<i64, Vec<u8>>> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_107 = i_prot.read_i64()?;
            let map_val_108 = i_prot.read_bytes()?;
            val.insert(map_key_107, map_val_108);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetFileMetadataResult.metadata", &f_1)?;
    verify_required_field_exists("GetFileMetadataResult.is_supported", &f_2)?;
    let ret = GetFileMetadataResult {
      metadata: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_supported: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("metadata", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::String, self.metadata.len() as i32))?;
    for (k, v) in &self.metadata {
      o_prot.write_i64(*k)?;
      o_prot.write_bytes(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isSupported", TType::Bool, 2))?;
    o_prot.write_bool(self.is_supported)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetFileMetadataRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetFileMetadataRequest {
  pub file_ids: Vec<i64>,
}

impl GetFileMetadataRequest {
  pub fn new(file_ids: Vec<i64>) -> GetFileMetadataRequest {
    GetFileMetadataRequest {
      file_ids,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetFileMetadataRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_109 = i_prot.read_i64()?;
            val.push(list_elem_109);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetFileMetadataRequest.file_ids", &f_1)?;
    let ret = GetFileMetadataRequest {
      file_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetFileMetadataRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.file_ids.len() as i32))?;
    for e in &self.file_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PutFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PutFileMetadataResult {
}

impl PutFileMetadataResult {
  pub fn new() -> PutFileMetadataResult {
    PutFileMetadataResult {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PutFileMetadataResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PutFileMetadataResult {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PutFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PutFileMetadataResult {
  fn default() -> Self {
    PutFileMetadataResult{}
  }
}

//
// PutFileMetadataRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PutFileMetadataRequest {
  pub file_ids: Vec<i64>,
  pub metadata: Vec<Vec<u8>>,
  pub type_: Option<FileMetadataExprType>,
}

impl PutFileMetadataRequest {
  pub fn new<F3>(file_ids: Vec<i64>, metadata: Vec<Vec<u8>>, type_: F3) -> PutFileMetadataRequest where F3: Into<Option<FileMetadataExprType>> {
    PutFileMetadataRequest {
      file_ids,
      metadata,
      type_: type_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PutFileMetadataRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    let mut f_3: Option<FileMetadataExprType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_110 = i_prot.read_i64()?;
            val.push(list_elem_110);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_111 = i_prot.read_bytes()?;
            val.push(list_elem_111);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = FileMetadataExprType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PutFileMetadataRequest.file_ids", &f_1)?;
    verify_required_field_exists("PutFileMetadataRequest.metadata", &f_2)?;
    let ret = PutFileMetadataRequest {
      file_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      metadata: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PutFileMetadataRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.file_ids.len() as i32))?;
    for e in &self.file_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("metadata", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.metadata.len() as i32))?;
    for e in &self.metadata {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClearFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClearFileMetadataResult {
}

impl ClearFileMetadataResult {
  pub fn new() -> ClearFileMetadataResult {
    ClearFileMetadataResult {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClearFileMetadataResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClearFileMetadataResult {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClearFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ClearFileMetadataResult {
  fn default() -> Self {
    ClearFileMetadataResult{}
  }
}

//
// ClearFileMetadataRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClearFileMetadataRequest {
  pub file_ids: Vec<i64>,
}

impl ClearFileMetadataRequest {
  pub fn new(file_ids: Vec<i64>) -> ClearFileMetadataRequest {
    ClearFileMetadataRequest {
      file_ids,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClearFileMetadataRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_112 = i_prot.read_i64()?;
            val.push(list_elem_112);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ClearFileMetadataRequest.file_ids", &f_1)?;
    let ret = ClearFileMetadataRequest {
      file_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClearFileMetadataRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.file_ids.len() as i32))?;
    for e in &self.file_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CacheFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CacheFileMetadataResult {
  pub is_supported: bool,
}

impl CacheFileMetadataResult {
  pub fn new(is_supported: bool) -> CacheFileMetadataResult {
    CacheFileMetadataResult {
      is_supported,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CacheFileMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CacheFileMetadataResult.is_supported", &f_1)?;
    let ret = CacheFileMetadataResult {
      is_supported: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CacheFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isSupported", TType::Bool, 1))?;
    o_prot.write_bool(self.is_supported)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CacheFileMetadataRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CacheFileMetadataRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub part_name: Option<String>,
  pub is_all_parts: Option<bool>,
}

impl CacheFileMetadataRequest {
  pub fn new<F3, F4>(db_name: String, tbl_name: String, part_name: F3, is_all_parts: F4) -> CacheFileMetadataRequest where F3: Into<Option<String>>, F4: Into<Option<bool>> {
    CacheFileMetadataRequest {
      db_name,
      tbl_name,
      part_name: part_name.into(),
      is_all_parts: is_all_parts.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CacheFileMetadataRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CacheFileMetadataRequest.db_name", &f_1)?;
    verify_required_field_exists("CacheFileMetadataRequest.tbl_name", &f_2)?;
    let ret = CacheFileMetadataRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3,
      is_all_parts: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CacheFileMetadataRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.part_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("partName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_all_parts {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAllParts", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetAllFunctionsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetAllFunctionsResponse {
  pub functions: Option<Vec<Function>>,
}

impl GetAllFunctionsResponse {
  pub fn new<F1>(functions: F1) -> GetAllFunctionsResponse where F1: Into<Option<Vec<Function>>> {
    GetAllFunctionsResponse {
      functions: functions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetAllFunctionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Function>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Function> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_113 = Function::read_from_in_protocol(i_prot)?;
            val.push(list_elem_113);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetAllFunctionsResponse {
      functions: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetAllFunctionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.functions {
      o_prot.write_field_begin(&TFieldIdentifier::new("functions", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetAllFunctionsResponse {
  fn default() -> Self {
    GetAllFunctionsResponse{
      functions: Some(Vec::new()),
    }
  }
}

//
// ClientCapabilities
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientCapabilities {
  pub values: Vec<ClientCapability>,
}

impl ClientCapabilities {
  pub fn new(values: Vec<ClientCapability>) -> ClientCapabilities {
    ClientCapabilities {
      values,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientCapabilities> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<ClientCapability>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ClientCapability> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_114 = ClientCapability::read_from_in_protocol(i_prot)?;
            val.push(list_elem_114);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ClientCapabilities.values", &f_1)?;
    let ret = ClientCapabilities {
      values: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClientCapabilities");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.values.len() as i32))?;
    for e in &self.values {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetTableRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTableRequest {
  pub db_name: String,
  pub tbl_name: String,
  pub capabilities: Option<ClientCapabilities>,
  pub cat_name: Option<String>,
}

impl GetTableRequest {
  pub fn new<F3, F4>(db_name: String, tbl_name: String, capabilities: F3, cat_name: F4) -> GetTableRequest where F3: Into<Option<ClientCapabilities>>, F4: Into<Option<String>> {
    GetTableRequest {
      db_name,
      tbl_name,
      capabilities: capabilities.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTableRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<ClientCapabilities> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ClientCapabilities::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetTableRequest.db_name", &f_1)?;
    verify_required_field_exists("GetTableRequest.tbl_name", &f_2)?;
    let ret = GetTableRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      capabilities: f_3,
      cat_name: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTableRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tblName", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.capabilities {
      o_prot.write_field_begin(&TFieldIdentifier::new("capabilities", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTableResult {
  pub table: Table,
}

impl GetTableResult {
  pub fn new(table: Table) -> GetTableResult {
    GetTableResult {
      table,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Table> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetTableResult.table", &f_1)?;
    let ret = GetTableResult {
      table: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 1))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetTablesRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTablesRequest {
  pub db_name: String,
  pub tbl_names: Option<Vec<String>>,
  pub capabilities: Option<ClientCapabilities>,
  pub cat_name: Option<String>,
}

impl GetTablesRequest {
  pub fn new<F2, F3, F4>(db_name: String, tbl_names: F2, capabilities: F3, cat_name: F4) -> GetTablesRequest where F2: Into<Option<Vec<String>>>, F3: Into<Option<ClientCapabilities>>, F4: Into<Option<String>> {
    GetTablesRequest {
      db_name,
      tbl_names: tbl_names.into(),
      capabilities: capabilities.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTablesRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<ClientCapabilities> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_115 = i_prot.read_string()?;
            val.push(list_elem_115);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = ClientCapabilities::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetTablesRequest.db_name", &f_1)?;
    let ret = GetTablesRequest {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_names: f_2,
      capabilities: f_3,
      cat_name: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTablesRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.tbl_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("tblNames", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.capabilities {
      o_prot.write_field_begin(&TFieldIdentifier::new("capabilities", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTablesResult {
  pub tables: Vec<Table>,
}

impl GetTablesResult {
  pub fn new(tables: Vec<Table>) -> GetTablesResult {
    GetTablesResult {
      tables,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Table>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Table> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_116 = Table::read_from_in_protocol(i_prot)?;
            val.push(list_elem_116);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetTablesResult.tables", &f_1)?;
    let ret = GetTablesResult {
      tables: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tables", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.tables.len() as i32))?;
    for e in &self.tables {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CmRecycleRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CmRecycleRequest {
  pub data_path: String,
  pub purge: bool,
}

impl CmRecycleRequest {
  pub fn new(data_path: String, purge: bool) -> CmRecycleRequest {
    CmRecycleRequest {
      data_path,
      purge,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CmRecycleRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CmRecycleRequest.data_path", &f_1)?;
    verify_required_field_exists("CmRecycleRequest.purge", &f_2)?;
    let ret = CmRecycleRequest {
      data_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      purge: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CmRecycleRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataPath", TType::String, 1))?;
    o_prot.write_string(&self.data_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("purge", TType::Bool, 2))?;
    o_prot.write_bool(self.purge)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CmRecycleResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CmRecycleResponse {
}

impl CmRecycleResponse {
  pub fn new() -> CmRecycleResponse {
    CmRecycleResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CmRecycleResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CmRecycleResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CmRecycleResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CmRecycleResponse {
  fn default() -> Self {
    CmRecycleResponse{}
  }
}

//
// TableMeta
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TableMeta {
  pub db_name: String,
  pub table_name: String,
  pub table_type: String,
  pub comments: Option<String>,
  pub cat_name: Option<String>,
}

impl TableMeta {
  pub fn new<F4, F5>(db_name: String, table_name: String, table_type: String, comments: F4, cat_name: F5) -> TableMeta where F4: Into<Option<String>>, F5: Into<Option<String>> {
    TableMeta {
      db_name,
      table_name,
      table_type,
      comments: comments.into(),
      cat_name: cat_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TableMeta> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TableMeta.db_name", &f_1)?;
    verify_required_field_exists("TableMeta.table_name", &f_2)?;
    verify_required_field_exists("TableMeta.table_type", &f_3)?;
    let ret = TableMeta {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      comments: f_4,
      cat_name: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TableMeta");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableType", TType::String, 3))?;
    o_prot.write_string(&self.table_type)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.comments {
      o_prot.write_field_begin(&TFieldIdentifier::new("comments", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Materialization
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Materialization {
  pub source_tables_update_delete_modified: bool,
}

impl Materialization {
  pub fn new(source_tables_update_delete_modified: bool) -> Materialization {
    Materialization {
      source_tables_update_delete_modified,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Materialization> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("Materialization.source_tables_update_delete_modified", &f_1)?;
    let ret = Materialization {
      source_tables_update_delete_modified: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Materialization");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sourceTablesUpdateDeleteModified", TType::Bool, 1))?;
    o_prot.write_bool(self.source_tables_update_delete_modified)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMResourcePlan
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMResourcePlan {
  pub name: String,
  pub status: Option<WMResourcePlanStatus>,
  pub query_parallelism: Option<i32>,
  pub default_pool_path: Option<String>,
}

impl WMResourcePlan {
  pub fn new<F2, F3, F4>(name: String, status: F2, query_parallelism: F3, default_pool_path: F4) -> WMResourcePlan where F2: Into<Option<WMResourcePlanStatus>>, F3: Into<Option<i32>>, F4: Into<Option<String>> {
    WMResourcePlan {
      name,
      status: status.into(),
      query_parallelism: query_parallelism.into(),
      default_pool_path: default_pool_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMResourcePlan> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<WMResourcePlanStatus> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = WMResourcePlanStatus::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMResourcePlan.name", &f_1)?;
    let ret = WMResourcePlan {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      status: f_2,
      query_parallelism: f_3,
      default_pool_path: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMResourcePlan");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_parallelism {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryParallelism", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultPoolPath", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMNullableResourcePlan
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMNullableResourcePlan {
  pub name: Option<String>,
  pub status: Option<WMResourcePlanStatus>,
  pub query_parallelism: Option<i32>,
  pub is_set_query_parallelism: Option<bool>,
  pub default_pool_path: Option<String>,
  pub is_set_default_pool_path: Option<bool>,
}

impl WMNullableResourcePlan {
  pub fn new<F1, F2, F4, F5, F6, F7>(name: F1, status: F2, query_parallelism: F4, is_set_query_parallelism: F5, default_pool_path: F6, is_set_default_pool_path: F7) -> WMNullableResourcePlan where F1: Into<Option<String>>, F2: Into<Option<WMResourcePlanStatus>>, F4: Into<Option<i32>>, F5: Into<Option<bool>>, F6: Into<Option<String>>, F7: Into<Option<bool>> {
    WMNullableResourcePlan {
      name: name.into(),
      status: status.into(),
      query_parallelism: query_parallelism.into(),
      is_set_query_parallelism: is_set_query_parallelism.into(),
      default_pool_path: default_pool_path.into(),
      is_set_default_pool_path: is_set_default_pool_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMNullableResourcePlan> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<WMResourcePlanStatus> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = WMResourcePlanStatus::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMNullableResourcePlan {
      name: f_1,
      status: f_2,
      query_parallelism: f_4,
      is_set_query_parallelism: f_5,
      default_pool_path: f_6,
      is_set_default_pool_path: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMNullableResourcePlan");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_parallelism {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryParallelism", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_set_query_parallelism {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSetQueryParallelism", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("defaultPoolPath", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_set_default_pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSetDefaultPoolPath", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMNullableResourcePlan {
  fn default() -> Self {
    WMNullableResourcePlan{
      name: Some("".to_owned()),
      status: None,
      query_parallelism: Some(0),
      is_set_query_parallelism: Some(false),
      default_pool_path: Some("".to_owned()),
      is_set_default_pool_path: Some(false),
    }
  }
}

//
// WMPool
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMPool {
  pub resource_plan_name: String,
  pub pool_path: String,
  pub alloc_fraction: Option<OrderedFloat<f64>>,
  pub query_parallelism: Option<i32>,
  pub scheduling_policy: Option<String>,
}

impl WMPool {
  pub fn new<F3, F4, F5>(resource_plan_name: String, pool_path: String, alloc_fraction: F3, query_parallelism: F4, scheduling_policy: F5) -> WMPool where F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<i32>>, F5: Into<Option<String>> {
    WMPool {
      resource_plan_name,
      pool_path,
      alloc_fraction: alloc_fraction.into(),
      query_parallelism: query_parallelism.into(),
      scheduling_policy: scheduling_policy.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMPool> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMPool.resource_plan_name", &f_1)?;
    verify_required_field_exists("WMPool.pool_path", &f_2)?;
    let ret = WMPool {
      resource_plan_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pool_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      alloc_fraction: f_3,
      query_parallelism: f_4,
      scheduling_policy: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMPool");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
    o_prot.write_string(&self.resource_plan_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("poolPath", TType::String, 2))?;
    o_prot.write_string(&self.pool_path)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.alloc_fraction {
      o_prot.write_field_begin(&TFieldIdentifier::new("allocFraction", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_parallelism {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryParallelism", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.scheduling_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("schedulingPolicy", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMNullablePool
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMNullablePool {
  pub resource_plan_name: String,
  pub pool_path: String,
  pub alloc_fraction: Option<OrderedFloat<f64>>,
  pub query_parallelism: Option<i32>,
  pub scheduling_policy: Option<String>,
  pub is_set_scheduling_policy: Option<bool>,
}

impl WMNullablePool {
  pub fn new<F3, F4, F5, F6>(resource_plan_name: String, pool_path: String, alloc_fraction: F3, query_parallelism: F4, scheduling_policy: F5, is_set_scheduling_policy: F6) -> WMNullablePool where F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<bool>> {
    WMNullablePool {
      resource_plan_name,
      pool_path,
      alloc_fraction: alloc_fraction.into(),
      query_parallelism: query_parallelism.into(),
      scheduling_policy: scheduling_policy.into(),
      is_set_scheduling_policy: is_set_scheduling_policy.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMNullablePool> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMNullablePool.resource_plan_name", &f_1)?;
    verify_required_field_exists("WMNullablePool.pool_path", &f_2)?;
    let ret = WMNullablePool {
      resource_plan_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pool_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      alloc_fraction: f_3,
      query_parallelism: f_4,
      scheduling_policy: f_5,
      is_set_scheduling_policy: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMNullablePool");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
    o_prot.write_string(&self.resource_plan_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("poolPath", TType::String, 2))?;
    o_prot.write_string(&self.pool_path)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.alloc_fraction {
      o_prot.write_field_begin(&TFieldIdentifier::new("allocFraction", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_parallelism {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryParallelism", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.scheduling_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("schedulingPolicy", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_set_scheduling_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSetSchedulingPolicy", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMTrigger
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMTrigger {
  pub resource_plan_name: String,
  pub trigger_name: String,
  pub trigger_expression: Option<String>,
  pub action_expression: Option<String>,
  pub is_in_unmanaged: Option<bool>,
}

impl WMTrigger {
  pub fn new<F3, F4, F5>(resource_plan_name: String, trigger_name: String, trigger_expression: F3, action_expression: F4, is_in_unmanaged: F5) -> WMTrigger where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<bool>> {
    WMTrigger {
      resource_plan_name,
      trigger_name,
      trigger_expression: trigger_expression.into(),
      action_expression: action_expression.into(),
      is_in_unmanaged: is_in_unmanaged.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMTrigger> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMTrigger.resource_plan_name", &f_1)?;
    verify_required_field_exists("WMTrigger.trigger_name", &f_2)?;
    let ret = WMTrigger {
      resource_plan_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      trigger_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      trigger_expression: f_3,
      action_expression: f_4,
      is_in_unmanaged: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMTrigger");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
    o_prot.write_string(&self.resource_plan_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("triggerName", TType::String, 2))?;
    o_prot.write_string(&self.trigger_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.trigger_expression {
      o_prot.write_field_begin(&TFieldIdentifier::new("triggerExpression", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.action_expression {
      o_prot.write_field_begin(&TFieldIdentifier::new("actionExpression", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_in_unmanaged {
      o_prot.write_field_begin(&TFieldIdentifier::new("isInUnmanaged", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMMapping
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMMapping {
  pub resource_plan_name: String,
  pub entity_type: String,
  pub entity_name: String,
  pub pool_path: Option<String>,
  pub ordering: Option<i32>,
}

impl WMMapping {
  pub fn new<F4, F5>(resource_plan_name: String, entity_type: String, entity_name: String, pool_path: F4, ordering: F5) -> WMMapping where F4: Into<Option<String>>, F5: Into<Option<i32>> {
    WMMapping {
      resource_plan_name,
      entity_type,
      entity_name,
      pool_path: pool_path.into(),
      ordering: ordering.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMMapping> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMMapping.resource_plan_name", &f_1)?;
    verify_required_field_exists("WMMapping.entity_type", &f_2)?;
    verify_required_field_exists("WMMapping.entity_name", &f_3)?;
    let ret = WMMapping {
      resource_plan_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      entity_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      pool_path: f_4,
      ordering: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMMapping");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
    o_prot.write_string(&self.resource_plan_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 2))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityName", TType::String, 3))?;
    o_prot.write_string(&self.entity_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("poolPath", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ordering {
      o_prot.write_field_begin(&TFieldIdentifier::new("ordering", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMPoolTrigger
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMPoolTrigger {
  pub pool: String,
  pub trigger: String,
}

impl WMPoolTrigger {
  pub fn new(pool: String, trigger: String) -> WMPoolTrigger {
    WMPoolTrigger {
      pool,
      trigger,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMPoolTrigger> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMPoolTrigger.pool", &f_1)?;
    verify_required_field_exists("WMPoolTrigger.trigger", &f_2)?;
    let ret = WMPoolTrigger {
      pool: f_1.expect("auto-generated code should have checked for presence of required fields"),
      trigger: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMPoolTrigger");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pool", TType::String, 1))?;
    o_prot.write_string(&self.pool)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("trigger", TType::String, 2))?;
    o_prot.write_string(&self.trigger)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMFullResourcePlan
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMFullResourcePlan {
  pub plan: WMResourcePlan,
  pub pools: Vec<WMPool>,
  pub mappings: Option<Vec<WMMapping>>,
  pub triggers: Option<Vec<WMTrigger>>,
  pub pool_triggers: Option<Vec<WMPoolTrigger>>,
}

impl WMFullResourcePlan {
  pub fn new<F3, F4, F5>(plan: WMResourcePlan, pools: Vec<WMPool>, mappings: F3, triggers: F4, pool_triggers: F5) -> WMFullResourcePlan where F3: Into<Option<Vec<WMMapping>>>, F4: Into<Option<Vec<WMTrigger>>>, F5: Into<Option<Vec<WMPoolTrigger>>> {
    WMFullResourcePlan {
      plan,
      pools,
      mappings: mappings.into(),
      triggers: triggers.into(),
      pool_triggers: pool_triggers.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMFullResourcePlan> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMResourcePlan> = None;
    let mut f_2: Option<Vec<WMPool>> = None;
    let mut f_3: Option<Vec<WMMapping>> = None;
    let mut f_4: Option<Vec<WMTrigger>> = None;
    let mut f_5: Option<Vec<WMPoolTrigger>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMResourcePlan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WMPool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_117 = WMPool::read_from_in_protocol(i_prot)?;
            val.push(list_elem_117);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WMMapping> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_118 = WMMapping::read_from_in_protocol(i_prot)?;
            val.push(list_elem_118);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WMTrigger> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_119 = WMTrigger::read_from_in_protocol(i_prot)?;
            val.push(list_elem_119);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WMPoolTrigger> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_120 = WMPoolTrigger::read_from_in_protocol(i_prot)?;
            val.push(list_elem_120);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WMFullResourcePlan.plan", &f_1)?;
    verify_required_field_exists("WMFullResourcePlan.pools", &f_2)?;
    let ret = WMFullResourcePlan {
      plan: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pools: f_2.expect("auto-generated code should have checked for presence of required fields"),
      mappings: f_3,
      triggers: f_4,
      pool_triggers: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMFullResourcePlan");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("plan", TType::Struct, 1))?;
    self.plan.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pools", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.pools.len() as i32))?;
    for e in &self.pools {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.mappings {
      o_prot.write_field_begin(&TFieldIdentifier::new("mappings", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.triggers {
      o_prot.write_field_begin(&TFieldIdentifier::new("triggers", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pool_triggers {
      o_prot.write_field_begin(&TFieldIdentifier::new("poolTriggers", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WMCreateResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateResourcePlanRequest {
  pub resource_plan: Option<WMResourcePlan>,
  pub copy_from: Option<String>,
}

impl WMCreateResourcePlanRequest {
  pub fn new<F1, F2>(resource_plan: F1, copy_from: F2) -> WMCreateResourcePlanRequest where F1: Into<Option<WMResourcePlan>>, F2: Into<Option<String>> {
    WMCreateResourcePlanRequest {
      resource_plan: resource_plan.into(),
      copy_from: copy_from.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMResourcePlan> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMResourcePlan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateResourcePlanRequest {
      resource_plan: f_1,
      copy_from: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlan", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.copy_from {
      o_prot.write_field_begin(&TFieldIdentifier::new("copyFrom", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateResourcePlanRequest {
  fn default() -> Self {
    WMCreateResourcePlanRequest{
      resource_plan: None,
      copy_from: Some("".to_owned()),
    }
  }
}

//
// WMCreateResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateResourcePlanResponse {
}

impl WMCreateResourcePlanResponse {
  pub fn new() -> WMCreateResourcePlanResponse {
    WMCreateResourcePlanResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateResourcePlanResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateResourcePlanResponse {
  fn default() -> Self {
    WMCreateResourcePlanResponse{}
  }
}

//
// WMGetActiveResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetActiveResourcePlanRequest {
}

impl WMGetActiveResourcePlanRequest {
  pub fn new() -> WMGetActiveResourcePlanRequest {
    WMGetActiveResourcePlanRequest {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetActiveResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetActiveResourcePlanRequest {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetActiveResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetActiveResourcePlanRequest {
  fn default() -> Self {
    WMGetActiveResourcePlanRequest{}
  }
}

//
// WMGetActiveResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetActiveResourcePlanResponse {
  pub resource_plan: Option<WMFullResourcePlan>,
}

impl WMGetActiveResourcePlanResponse {
  pub fn new<F1>(resource_plan: F1) -> WMGetActiveResourcePlanResponse where F1: Into<Option<WMFullResourcePlan>> {
    WMGetActiveResourcePlanResponse {
      resource_plan: resource_plan.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetActiveResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMFullResourcePlan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMFullResourcePlan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetActiveResourcePlanResponse {
      resource_plan: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetActiveResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlan", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetActiveResourcePlanResponse {
  fn default() -> Self {
    WMGetActiveResourcePlanResponse{
      resource_plan: None,
    }
  }
}

//
// WMGetResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetResourcePlanRequest {
  pub resource_plan_name: Option<String>,
}

impl WMGetResourcePlanRequest {
  pub fn new<F1>(resource_plan_name: F1) -> WMGetResourcePlanRequest where F1: Into<Option<String>> {
    WMGetResourcePlanRequest {
      resource_plan_name: resource_plan_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetResourcePlanRequest {
      resource_plan_name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetResourcePlanRequest {
  fn default() -> Self {
    WMGetResourcePlanRequest{
      resource_plan_name: Some("".to_owned()),
    }
  }
}

//
// WMGetResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetResourcePlanResponse {
  pub resource_plan: Option<WMFullResourcePlan>,
}

impl WMGetResourcePlanResponse {
  pub fn new<F1>(resource_plan: F1) -> WMGetResourcePlanResponse where F1: Into<Option<WMFullResourcePlan>> {
    WMGetResourcePlanResponse {
      resource_plan: resource_plan.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMFullResourcePlan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMFullResourcePlan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetResourcePlanResponse {
      resource_plan: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlan", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetResourcePlanResponse {
  fn default() -> Self {
    WMGetResourcePlanResponse{
      resource_plan: None,
    }
  }
}

//
// WMGetAllResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetAllResourcePlanRequest {
}

impl WMGetAllResourcePlanRequest {
  pub fn new() -> WMGetAllResourcePlanRequest {
    WMGetAllResourcePlanRequest {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetAllResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetAllResourcePlanRequest {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetAllResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetAllResourcePlanRequest {
  fn default() -> Self {
    WMGetAllResourcePlanRequest{}
  }
}

//
// WMGetAllResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetAllResourcePlanResponse {
  pub resource_plans: Option<Vec<WMResourcePlan>>,
}

impl WMGetAllResourcePlanResponse {
  pub fn new<F1>(resource_plans: F1) -> WMGetAllResourcePlanResponse where F1: Into<Option<Vec<WMResourcePlan>>> {
    WMGetAllResourcePlanResponse {
      resource_plans: resource_plans.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetAllResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<WMResourcePlan>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WMResourcePlan> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_121 = WMResourcePlan::read_from_in_protocol(i_prot)?;
            val.push(list_elem_121);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetAllResourcePlanResponse {
      resource_plans: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetAllResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plans {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlans", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetAllResourcePlanResponse {
  fn default() -> Self {
    WMGetAllResourcePlanResponse{
      resource_plans: Some(Vec::new()),
    }
  }
}

//
// WMAlterResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMAlterResourcePlanRequest {
  pub resource_plan_name: Option<String>,
  pub resource_plan: Option<WMNullableResourcePlan>,
  pub is_enable_and_activate: Option<bool>,
  pub is_force_deactivate: Option<bool>,
  pub is_replace: Option<bool>,
}

impl WMAlterResourcePlanRequest {
  pub fn new<F1, F2, F3, F4, F5>(resource_plan_name: F1, resource_plan: F2, is_enable_and_activate: F3, is_force_deactivate: F4, is_replace: F5) -> WMAlterResourcePlanRequest where F1: Into<Option<String>>, F2: Into<Option<WMNullableResourcePlan>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>> {
    WMAlterResourcePlanRequest {
      resource_plan_name: resource_plan_name.into(),
      resource_plan: resource_plan.into(),
      is_enable_and_activate: is_enable_and_activate.into(),
      is_force_deactivate: is_force_deactivate.into(),
      is_replace: is_replace.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMAlterResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<WMNullableResourcePlan> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = WMNullableResourcePlan::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMAlterResourcePlanRequest {
      resource_plan_name: f_1,
      resource_plan: f_2,
      is_enable_and_activate: f_3,
      is_force_deactivate: f_4,
      is_replace: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMAlterResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource_plan {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlan", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_enable_and_activate {
      o_prot.write_field_begin(&TFieldIdentifier::new("isEnableAndActivate", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_force_deactivate {
      o_prot.write_field_begin(&TFieldIdentifier::new("isForceDeactivate", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_replace {
      o_prot.write_field_begin(&TFieldIdentifier::new("isReplace", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMAlterResourcePlanRequest {
  fn default() -> Self {
    WMAlterResourcePlanRequest{
      resource_plan_name: Some("".to_owned()),
      resource_plan: None,
      is_enable_and_activate: Some(false),
      is_force_deactivate: Some(false),
      is_replace: Some(false),
    }
  }
}

//
// WMAlterResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMAlterResourcePlanResponse {
  pub full_resource_plan: Option<WMFullResourcePlan>,
}

impl WMAlterResourcePlanResponse {
  pub fn new<F1>(full_resource_plan: F1) -> WMAlterResourcePlanResponse where F1: Into<Option<WMFullResourcePlan>> {
    WMAlterResourcePlanResponse {
      full_resource_plan: full_resource_plan.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMAlterResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMFullResourcePlan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMFullResourcePlan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMAlterResourcePlanResponse {
      full_resource_plan: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMAlterResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.full_resource_plan {
      o_prot.write_field_begin(&TFieldIdentifier::new("fullResourcePlan", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMAlterResourcePlanResponse {
  fn default() -> Self {
    WMAlterResourcePlanResponse{
      full_resource_plan: None,
    }
  }
}

//
// WMValidateResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMValidateResourcePlanRequest {
  pub resource_plan_name: Option<String>,
}

impl WMValidateResourcePlanRequest {
  pub fn new<F1>(resource_plan_name: F1) -> WMValidateResourcePlanRequest where F1: Into<Option<String>> {
    WMValidateResourcePlanRequest {
      resource_plan_name: resource_plan_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMValidateResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMValidateResourcePlanRequest {
      resource_plan_name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMValidateResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMValidateResourcePlanRequest {
  fn default() -> Self {
    WMValidateResourcePlanRequest{
      resource_plan_name: Some("".to_owned()),
    }
  }
}

//
// WMValidateResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMValidateResourcePlanResponse {
  pub errors: Option<Vec<String>>,
  pub warnings: Option<Vec<String>>,
}

impl WMValidateResourcePlanResponse {
  pub fn new<F1, F2>(errors: F1, warnings: F2) -> WMValidateResourcePlanResponse where F1: Into<Option<Vec<String>>>, F2: Into<Option<Vec<String>>> {
    WMValidateResourcePlanResponse {
      errors: errors.into(),
      warnings: warnings.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMValidateResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_122 = i_prot.read_string()?;
            val.push(list_elem_122);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_123 = i_prot.read_string()?;
            val.push(list_elem_123);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMValidateResourcePlanResponse {
      errors: f_1,
      warnings: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMValidateResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.errors {
      o_prot.write_field_begin(&TFieldIdentifier::new("errors", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.warnings {
      o_prot.write_field_begin(&TFieldIdentifier::new("warnings", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMValidateResourcePlanResponse {
  fn default() -> Self {
    WMValidateResourcePlanResponse{
      errors: Some(Vec::new()),
      warnings: Some(Vec::new()),
    }
  }
}

//
// WMDropResourcePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropResourcePlanRequest {
  pub resource_plan_name: Option<String>,
}

impl WMDropResourcePlanRequest {
  pub fn new<F1>(resource_plan_name: F1) -> WMDropResourcePlanRequest where F1: Into<Option<String>> {
    WMDropResourcePlanRequest {
      resource_plan_name: resource_plan_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropResourcePlanRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropResourcePlanRequest {
      resource_plan_name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropResourcePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropResourcePlanRequest {
  fn default() -> Self {
    WMDropResourcePlanRequest{
      resource_plan_name: Some("".to_owned()),
    }
  }
}

//
// WMDropResourcePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropResourcePlanResponse {
}

impl WMDropResourcePlanResponse {
  pub fn new() -> WMDropResourcePlanResponse {
    WMDropResourcePlanResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropResourcePlanResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropResourcePlanResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropResourcePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropResourcePlanResponse {
  fn default() -> Self {
    WMDropResourcePlanResponse{}
  }
}

//
// WMCreateTriggerRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateTriggerRequest {
  pub trigger: Option<WMTrigger>,
}

impl WMCreateTriggerRequest {
  pub fn new<F1>(trigger: F1) -> WMCreateTriggerRequest where F1: Into<Option<WMTrigger>> {
    WMCreateTriggerRequest {
      trigger: trigger.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateTriggerRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMTrigger> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMTrigger::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateTriggerRequest {
      trigger: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateTriggerRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("trigger", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateTriggerRequest {
  fn default() -> Self {
    WMCreateTriggerRequest{
      trigger: None,
    }
  }
}

//
// WMCreateTriggerResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateTriggerResponse {
}

impl WMCreateTriggerResponse {
  pub fn new() -> WMCreateTriggerResponse {
    WMCreateTriggerResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateTriggerResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateTriggerResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateTriggerResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateTriggerResponse {
  fn default() -> Self {
    WMCreateTriggerResponse{}
  }
}

//
// WMAlterTriggerRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMAlterTriggerRequest {
  pub trigger: Option<WMTrigger>,
}

impl WMAlterTriggerRequest {
  pub fn new<F1>(trigger: F1) -> WMAlterTriggerRequest where F1: Into<Option<WMTrigger>> {
    WMAlterTriggerRequest {
      trigger: trigger.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMAlterTriggerRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMTrigger> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMTrigger::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMAlterTriggerRequest {
      trigger: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMAlterTriggerRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("trigger", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMAlterTriggerRequest {
  fn default() -> Self {
    WMAlterTriggerRequest{
      trigger: None,
    }
  }
}

//
// WMAlterTriggerResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMAlterTriggerResponse {
}

impl WMAlterTriggerResponse {
  pub fn new() -> WMAlterTriggerResponse {
    WMAlterTriggerResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMAlterTriggerResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMAlterTriggerResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMAlterTriggerResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMAlterTriggerResponse {
  fn default() -> Self {
    WMAlterTriggerResponse{}
  }
}

//
// WMDropTriggerRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropTriggerRequest {
  pub resource_plan_name: Option<String>,
  pub trigger_name: Option<String>,
}

impl WMDropTriggerRequest {
  pub fn new<F1, F2>(resource_plan_name: F1, trigger_name: F2) -> WMDropTriggerRequest where F1: Into<Option<String>>, F2: Into<Option<String>> {
    WMDropTriggerRequest {
      resource_plan_name: resource_plan_name.into(),
      trigger_name: trigger_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropTriggerRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropTriggerRequest {
      resource_plan_name: f_1,
      trigger_name: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropTriggerRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trigger_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("triggerName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropTriggerRequest {
  fn default() -> Self {
    WMDropTriggerRequest{
      resource_plan_name: Some("".to_owned()),
      trigger_name: Some("".to_owned()),
    }
  }
}

//
// WMDropTriggerResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropTriggerResponse {
}

impl WMDropTriggerResponse {
  pub fn new() -> WMDropTriggerResponse {
    WMDropTriggerResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropTriggerResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropTriggerResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropTriggerResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropTriggerResponse {
  fn default() -> Self {
    WMDropTriggerResponse{}
  }
}

//
// WMGetTriggersForResourePlanRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetTriggersForResourePlanRequest {
  pub resource_plan_name: Option<String>,
}

impl WMGetTriggersForResourePlanRequest {
  pub fn new<F1>(resource_plan_name: F1) -> WMGetTriggersForResourePlanRequest where F1: Into<Option<String>> {
    WMGetTriggersForResourePlanRequest {
      resource_plan_name: resource_plan_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetTriggersForResourePlanRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetTriggersForResourePlanRequest {
      resource_plan_name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetTriggersForResourePlanRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetTriggersForResourePlanRequest {
  fn default() -> Self {
    WMGetTriggersForResourePlanRequest{
      resource_plan_name: Some("".to_owned()),
    }
  }
}

//
// WMGetTriggersForResourePlanResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMGetTriggersForResourePlanResponse {
  pub triggers: Option<Vec<WMTrigger>>,
}

impl WMGetTriggersForResourePlanResponse {
  pub fn new<F1>(triggers: F1) -> WMGetTriggersForResourePlanResponse where F1: Into<Option<Vec<WMTrigger>>> {
    WMGetTriggersForResourePlanResponse {
      triggers: triggers.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMGetTriggersForResourePlanResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<WMTrigger>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WMTrigger> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_124 = WMTrigger::read_from_in_protocol(i_prot)?;
            val.push(list_elem_124);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMGetTriggersForResourePlanResponse {
      triggers: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMGetTriggersForResourePlanResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.triggers {
      o_prot.write_field_begin(&TFieldIdentifier::new("triggers", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMGetTriggersForResourePlanResponse {
  fn default() -> Self {
    WMGetTriggersForResourePlanResponse{
      triggers: Some(Vec::new()),
    }
  }
}

//
// WMCreatePoolRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreatePoolRequest {
  pub pool: Option<WMPool>,
}

impl WMCreatePoolRequest {
  pub fn new<F1>(pool: F1) -> WMCreatePoolRequest where F1: Into<Option<WMPool>> {
    WMCreatePoolRequest {
      pool: pool.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreatePoolRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMPool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMPool::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreatePoolRequest {
      pool: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreatePoolRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pool {
      o_prot.write_field_begin(&TFieldIdentifier::new("pool", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreatePoolRequest {
  fn default() -> Self {
    WMCreatePoolRequest{
      pool: None,
    }
  }
}

//
// WMCreatePoolResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreatePoolResponse {
}

impl WMCreatePoolResponse {
  pub fn new() -> WMCreatePoolResponse {
    WMCreatePoolResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreatePoolResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreatePoolResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreatePoolResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreatePoolResponse {
  fn default() -> Self {
    WMCreatePoolResponse{}
  }
}

//
// WMAlterPoolRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMAlterPoolRequest {
  pub pool: Option<WMNullablePool>,
  pub pool_path: Option<String>,
}

impl WMAlterPoolRequest {
  pub fn new<F1, F2>(pool: F1, pool_path: F2) -> WMAlterPoolRequest where F1: Into<Option<WMNullablePool>>, F2: Into<Option<String>> {
    WMAlterPoolRequest {
      pool: pool.into(),
      pool_path: pool_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMAlterPoolRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMNullablePool> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMNullablePool::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMAlterPoolRequest {
      pool: f_1,
      pool_path: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMAlterPoolRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pool {
      o_prot.write_field_begin(&TFieldIdentifier::new("pool", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("poolPath", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMAlterPoolRequest {
  fn default() -> Self {
    WMAlterPoolRequest{
      pool: None,
      pool_path: Some("".to_owned()),
    }
  }
}

//
// WMAlterPoolResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMAlterPoolResponse {
}

impl WMAlterPoolResponse {
  pub fn new() -> WMAlterPoolResponse {
    WMAlterPoolResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMAlterPoolResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMAlterPoolResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMAlterPoolResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMAlterPoolResponse {
  fn default() -> Self {
    WMAlterPoolResponse{}
  }
}

//
// WMDropPoolRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropPoolRequest {
  pub resource_plan_name: Option<String>,
  pub pool_path: Option<String>,
}

impl WMDropPoolRequest {
  pub fn new<F1, F2>(resource_plan_name: F1, pool_path: F2) -> WMDropPoolRequest where F1: Into<Option<String>>, F2: Into<Option<String>> {
    WMDropPoolRequest {
      resource_plan_name: resource_plan_name.into(),
      pool_path: pool_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropPoolRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropPoolRequest {
      resource_plan_name: f_1,
      pool_path: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropPoolRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("poolPath", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropPoolRequest {
  fn default() -> Self {
    WMDropPoolRequest{
      resource_plan_name: Some("".to_owned()),
      pool_path: Some("".to_owned()),
    }
  }
}

//
// WMDropPoolResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropPoolResponse {
}

impl WMDropPoolResponse {
  pub fn new() -> WMDropPoolResponse {
    WMDropPoolResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropPoolResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropPoolResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropPoolResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropPoolResponse {
  fn default() -> Self {
    WMDropPoolResponse{}
  }
}

//
// WMCreateOrUpdateMappingRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateOrUpdateMappingRequest {
  pub mapping: Option<WMMapping>,
  pub update: Option<bool>,
}

impl WMCreateOrUpdateMappingRequest {
  pub fn new<F1, F2>(mapping: F1, update: F2) -> WMCreateOrUpdateMappingRequest where F1: Into<Option<WMMapping>>, F2: Into<Option<bool>> {
    WMCreateOrUpdateMappingRequest {
      mapping: mapping.into(),
      update: update.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateOrUpdateMappingRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMMapping> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMMapping::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateOrUpdateMappingRequest {
      mapping: f_1,
      update: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateOrUpdateMappingRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mapping {
      o_prot.write_field_begin(&TFieldIdentifier::new("mapping", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update {
      o_prot.write_field_begin(&TFieldIdentifier::new("update", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateOrUpdateMappingRequest {
  fn default() -> Self {
    WMCreateOrUpdateMappingRequest{
      mapping: None,
      update: Some(false),
    }
  }
}

//
// WMCreateOrUpdateMappingResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateOrUpdateMappingResponse {
}

impl WMCreateOrUpdateMappingResponse {
  pub fn new() -> WMCreateOrUpdateMappingResponse {
    WMCreateOrUpdateMappingResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateOrUpdateMappingResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateOrUpdateMappingResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateOrUpdateMappingResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateOrUpdateMappingResponse {
  fn default() -> Self {
    WMCreateOrUpdateMappingResponse{}
  }
}

//
// WMDropMappingRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropMappingRequest {
  pub mapping: Option<WMMapping>,
}

impl WMDropMappingRequest {
  pub fn new<F1>(mapping: F1) -> WMDropMappingRequest where F1: Into<Option<WMMapping>> {
    WMDropMappingRequest {
      mapping: mapping.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropMappingRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMMapping> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMMapping::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropMappingRequest {
      mapping: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropMappingRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.mapping {
      o_prot.write_field_begin(&TFieldIdentifier::new("mapping", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropMappingRequest {
  fn default() -> Self {
    WMDropMappingRequest{
      mapping: None,
    }
  }
}

//
// WMDropMappingResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMDropMappingResponse {
}

impl WMDropMappingResponse {
  pub fn new() -> WMDropMappingResponse {
    WMDropMappingResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMDropMappingResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMDropMappingResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMDropMappingResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMDropMappingResponse {
  fn default() -> Self {
    WMDropMappingResponse{}
  }
}

//
// WMCreateOrDropTriggerToPoolMappingRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateOrDropTriggerToPoolMappingRequest {
  pub resource_plan_name: Option<String>,
  pub trigger_name: Option<String>,
  pub pool_path: Option<String>,
  pub drop: Option<bool>,
}

impl WMCreateOrDropTriggerToPoolMappingRequest {
  pub fn new<F1, F2, F3, F4>(resource_plan_name: F1, trigger_name: F2, pool_path: F3, drop: F4) -> WMCreateOrDropTriggerToPoolMappingRequest where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<bool>> {
    WMCreateOrDropTriggerToPoolMappingRequest {
      resource_plan_name: resource_plan_name.into(),
      trigger_name: trigger_name.into(),
      pool_path: pool_path.into(),
      drop: drop.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateOrDropTriggerToPoolMappingRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateOrDropTriggerToPoolMappingRequest {
      resource_plan_name: f_1,
      trigger_name: f_2,
      pool_path: f_3,
      drop: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateOrDropTriggerToPoolMappingRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.resource_plan_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("resourcePlanName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trigger_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("triggerName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pool_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("poolPath", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.drop {
      o_prot.write_field_begin(&TFieldIdentifier::new("drop", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateOrDropTriggerToPoolMappingRequest {
  fn default() -> Self {
    WMCreateOrDropTriggerToPoolMappingRequest{
      resource_plan_name: Some("".to_owned()),
      trigger_name: Some("".to_owned()),
      pool_path: Some("".to_owned()),
      drop: Some(false),
    }
  }
}

//
// WMCreateOrDropTriggerToPoolMappingResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WMCreateOrDropTriggerToPoolMappingResponse {
}

impl WMCreateOrDropTriggerToPoolMappingResponse {
  pub fn new() -> WMCreateOrDropTriggerToPoolMappingResponse {
    WMCreateOrDropTriggerToPoolMappingResponse {}
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WMCreateOrDropTriggerToPoolMappingResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WMCreateOrDropTriggerToPoolMappingResponse {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WMCreateOrDropTriggerToPoolMappingResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WMCreateOrDropTriggerToPoolMappingResponse {
  fn default() -> Self {
    WMCreateOrDropTriggerToPoolMappingResponse{}
  }
}

//
// ISchema
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ISchema {
  pub schema_type: Option<SchemaType>,
  pub name: Option<String>,
  pub cat_name: Option<String>,
  pub db_name: Option<String>,
  pub compatibility: Option<SchemaCompatibility>,
  pub validation_level: Option<SchemaValidation>,
  pub can_evolve: Option<bool>,
  pub schema_group: Option<String>,
  pub description: Option<String>,
}

impl ISchema {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(schema_type: F1, name: F2, cat_name: F3, db_name: F4, compatibility: F5, validation_level: F6, can_evolve: F7, schema_group: F8, description: F9) -> ISchema where F1: Into<Option<SchemaType>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<SchemaCompatibility>>, F6: Into<Option<SchemaValidation>>, F7: Into<Option<bool>>, F8: Into<Option<String>>, F9: Into<Option<String>> {
    ISchema {
      schema_type: schema_type.into(),
      name: name.into(),
      cat_name: cat_name.into(),
      db_name: db_name.into(),
      compatibility: compatibility.into(),
      validation_level: validation_level.into(),
      can_evolve: can_evolve.into(),
      schema_group: schema_group.into(),
      description: description.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ISchema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaType> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<SchemaCompatibility> = None;
    let mut f_6: Option<SchemaValidation> = None;
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = SchemaCompatibility::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = SchemaValidation::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ISchema {
      schema_type: f_1,
      name: f_2,
      cat_name: f_3,
      db_name: f_4,
      compatibility: f_5,
      validation_level: f_6,
      can_evolve: f_7,
      schema_group: f_8,
      description: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ISchema");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schema_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaType", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.compatibility {
      o_prot.write_field_begin(&TFieldIdentifier::new("compatibility", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.validation_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("validationLevel", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.can_evolve {
      o_prot.write_field_begin(&TFieldIdentifier::new("canEvolve", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_group {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaGroup", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ISchema {
  fn default() -> Self {
    ISchema{
      schema_type: None,
      name: Some("".to_owned()),
      cat_name: Some("".to_owned()),
      db_name: Some("".to_owned()),
      compatibility: None,
      validation_level: None,
      can_evolve: Some(false),
      schema_group: Some("".to_owned()),
      description: Some("".to_owned()),
    }
  }
}

//
// ISchemaName
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ISchemaName {
  pub cat_name: Option<String>,
  pub db_name: Option<String>,
  pub schema_name: Option<String>,
}

impl ISchemaName {
  pub fn new<F1, F2, F3>(cat_name: F1, db_name: F2, schema_name: F3) -> ISchemaName where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    ISchemaName {
      cat_name: cat_name.into(),
      db_name: db_name.into(),
      schema_name: schema_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ISchemaName> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ISchemaName {
      cat_name: f_1,
      db_name: f_2,
      schema_name: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ISchemaName");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cat_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ISchemaName {
  fn default() -> Self {
    ISchemaName{
      cat_name: Some("".to_owned()),
      db_name: Some("".to_owned()),
      schema_name: Some("".to_owned()),
    }
  }
}

//
// AlterISchemaRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AlterISchemaRequest {
  pub name: Option<ISchemaName>,
  pub new_schema: Option<ISchema>,
}

impl AlterISchemaRequest {
  pub fn new<F1, F3>(name: F1, new_schema: F3) -> AlterISchemaRequest where F1: Into<Option<ISchemaName>>, F3: Into<Option<ISchema>> {
    AlterISchemaRequest {
      name: name.into(),
      new_schema: new_schema.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AlterISchemaRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    let mut f_3: Option<ISchema> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = ISchema::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AlterISchemaRequest {
      name: f_1,
      new_schema: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AlterISchemaRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.new_schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("newSchema", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AlterISchemaRequest {
  fn default() -> Self {
    AlterISchemaRequest{
      name: None,
      new_schema: None,
    }
  }
}

//
// SchemaVersion
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaVersion {
  pub schema: Option<ISchemaName>,
  pub version: Option<i32>,
  pub created_at: Option<i64>,
  pub cols: Option<Vec<FieldSchema>>,
  pub state: Option<SchemaVersionState>,
  pub description: Option<String>,
  pub schema_text: Option<String>,
  pub fingerprint: Option<String>,
  pub name: Option<String>,
  pub ser_de: Option<SerDeInfo>,
}

impl SchemaVersion {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(schema: F1, version: F2, created_at: F3, cols: F4, state: F5, description: F6, schema_text: F7, fingerprint: F8, name: F9, ser_de: F10) -> SchemaVersion where F1: Into<Option<ISchemaName>>, F2: Into<Option<i32>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<FieldSchema>>>, F5: Into<Option<SchemaVersionState>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<SerDeInfo>> {
    SchemaVersion {
      schema: schema.into(),
      version: version.into(),
      created_at: created_at.into(),
      cols: cols.into(),
      state: state.into(),
      description: description.into(),
      schema_text: schema_text.into(),
      fingerprint: fingerprint.into(),
      name: name.into(),
      ser_de: ser_de.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaVersion> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<Vec<FieldSchema>> = Some(Vec::new());
    let mut f_5: Option<SchemaVersionState> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<SerDeInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_125 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_125);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = SchemaVersionState::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = SerDeInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SchemaVersion {
      schema: f_1,
      version: f_2,
      created_at: f_3,
      cols: f_4,
      state: f_5,
      description: f_6,
      schema_text: f_7,
      fingerprint: f_8,
      name: f_9,
      ser_de: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaVersion");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created_at {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdAt", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("cols", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_text {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaText", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fingerprint {
      o_prot.write_field_begin(&TFieldIdentifier::new("fingerprint", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ser_de {
      o_prot.write_field_begin(&TFieldIdentifier::new("serDe", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SchemaVersion {
  fn default() -> Self {
    SchemaVersion{
      schema: None,
      version: Some(0),
      created_at: Some(0),
      cols: Some(Vec::new()),
      state: None,
      description: Some("".to_owned()),
      schema_text: Some("".to_owned()),
      fingerprint: Some("".to_owned()),
      name: Some("".to_owned()),
      ser_de: None,
    }
  }
}

//
// SchemaVersionDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaVersionDescriptor {
  pub schema: Option<ISchemaName>,
  pub version: Option<i32>,
}

impl SchemaVersionDescriptor {
  pub fn new<F1, F2>(schema: F1, version: F2) -> SchemaVersionDescriptor where F1: Into<Option<ISchemaName>>, F2: Into<Option<i32>> {
    SchemaVersionDescriptor {
      schema: schema.into(),
      version: version.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaVersionDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SchemaVersionDescriptor {
      schema: f_1,
      version: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaVersionDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SchemaVersionDescriptor {
  fn default() -> Self {
    SchemaVersionDescriptor{
      schema: None,
      version: Some(0),
    }
  }
}

//
// FindSchemasByColsRqst
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FindSchemasByColsRqst {
  pub col_name: Option<String>,
  pub col_namespace: Option<String>,
  pub type_: Option<String>,
}

impl FindSchemasByColsRqst {
  pub fn new<F1, F2, F3>(col_name: F1, col_namespace: F2, type_: F3) -> FindSchemasByColsRqst where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    FindSchemasByColsRqst {
      col_name: col_name.into(),
      col_namespace: col_namespace.into(),
      type_: type_.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FindSchemasByColsRqst> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FindSchemasByColsRqst {
      col_name: f_1,
      col_namespace: f_2,
      type_: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FindSchemasByColsRqst");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.col_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("colName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_namespace {
      o_prot.write_field_begin(&TFieldIdentifier::new("colNamespace", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FindSchemasByColsRqst {
  fn default() -> Self {
    FindSchemasByColsRqst{
      col_name: Some("".to_owned()),
      col_namespace: Some("".to_owned()),
      type_: Some("".to_owned()),
    }
  }
}

//
// FindSchemasByColsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FindSchemasByColsResp {
  pub schema_versions: Option<Vec<SchemaVersionDescriptor>>,
}

impl FindSchemasByColsResp {
  pub fn new<F1>(schema_versions: F1) -> FindSchemasByColsResp where F1: Into<Option<Vec<SchemaVersionDescriptor>>> {
    FindSchemasByColsResp {
      schema_versions: schema_versions.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FindSchemasByColsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SchemaVersionDescriptor>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SchemaVersionDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_126 = SchemaVersionDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_126);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FindSchemasByColsResp {
      schema_versions: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FindSchemasByColsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schema_versions {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaVersions", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FindSchemasByColsResp {
  fn default() -> Self {
    FindSchemasByColsResp{
      schema_versions: Some(Vec::new()),
    }
  }
}

//
// MapSchemaVersionToSerdeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MapSchemaVersionToSerdeRequest {
  pub schema_version: Option<SchemaVersionDescriptor>,
  pub serde_name: Option<String>,
}

impl MapSchemaVersionToSerdeRequest {
  pub fn new<F1, F2>(schema_version: F1, serde_name: F2) -> MapSchemaVersionToSerdeRequest where F1: Into<Option<SchemaVersionDescriptor>>, F2: Into<Option<String>> {
    MapSchemaVersionToSerdeRequest {
      schema_version: schema_version.into(),
      serde_name: serde_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MapSchemaVersionToSerdeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaVersionDescriptor> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaVersionDescriptor::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MapSchemaVersionToSerdeRequest {
      schema_version: f_1,
      serde_name: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MapSchemaVersionToSerdeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schema_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaVersion", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serde_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("serdeName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MapSchemaVersionToSerdeRequest {
  fn default() -> Self {
    MapSchemaVersionToSerdeRequest{
      schema_version: None,
      serde_name: Some("".to_owned()),
    }
  }
}

//
// SetSchemaVersionStateRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SetSchemaVersionStateRequest {
  pub schema_version: Option<SchemaVersionDescriptor>,
  pub state: Option<SchemaVersionState>,
}

impl SetSchemaVersionStateRequest {
  pub fn new<F1, F2>(schema_version: F1, state: F2) -> SetSchemaVersionStateRequest where F1: Into<Option<SchemaVersionDescriptor>>, F2: Into<Option<SchemaVersionState>> {
    SetSchemaVersionStateRequest {
      schema_version: schema_version.into(),
      state: state.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SetSchemaVersionStateRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaVersionDescriptor> = None;
    let mut f_2: Option<SchemaVersionState> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaVersionDescriptor::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = SchemaVersionState::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetSchemaVersionStateRequest {
      schema_version: f_1,
      state: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetSchemaVersionStateRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schema_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaVersion", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SetSchemaVersionStateRequest {
  fn default() -> Self {
    SetSchemaVersionStateRequest{
      schema_version: None,
      state: None,
    }
  }
}

//
// GetSerdeRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetSerdeRequest {
  pub serde_name: Option<String>,
}

impl GetSerdeRequest {
  pub fn new<F1>(serde_name: F1) -> GetSerdeRequest where F1: Into<Option<String>> {
    GetSerdeRequest {
      serde_name: serde_name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetSerdeRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetSerdeRequest {
      serde_name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSerdeRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.serde_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("serdeName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetSerdeRequest {
  fn default() -> Self {
    GetSerdeRequest{
      serde_name: Some("".to_owned()),
    }
  }
}

//
// RuntimeStat
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuntimeStat {
  pub create_time: Option<i32>,
  pub weight: i32,
  pub payload: Vec<u8>,
}

impl RuntimeStat {
  pub fn new<F1>(create_time: F1, weight: i32, payload: Vec<u8>) -> RuntimeStat where F1: Into<Option<i32>> {
    RuntimeStat {
      create_time: create_time.into(),
      weight,
      payload,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RuntimeStat> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RuntimeStat.weight", &f_2)?;
    verify_required_field_exists("RuntimeStat.payload", &f_3)?;
    let ret = RuntimeStat {
      create_time: f_1,
      weight: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payload: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuntimeStat");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.create_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createTime", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("weight", TType::I32, 2))?;
    o_prot.write_i32(self.weight)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payload", TType::String, 3))?;
    o_prot.write_bytes(&self.payload)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetRuntimeStatsRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetRuntimeStatsRequest {
  pub max_weight: i32,
  pub max_create_time: i32,
}

impl GetRuntimeStatsRequest {
  pub fn new(max_weight: i32, max_create_time: i32) -> GetRuntimeStatsRequest {
    GetRuntimeStatsRequest {
      max_weight,
      max_create_time,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetRuntimeStatsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetRuntimeStatsRequest.max_weight", &f_1)?;
    verify_required_field_exists("GetRuntimeStatsRequest.max_create_time", &f_2)?;
    let ret = GetRuntimeStatsRequest {
      max_weight: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_create_time: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetRuntimeStatsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxWeight", TType::I32, 1))?;
    o_prot.write_i32(self.max_weight)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxCreateTime", TType::I32, 2))?;
    o_prot.write_i32(self.max_create_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MetaException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MetaException {
  pub message: Option<String>,
}

impl MetaException {
  pub fn new<F1>(message: F1) -> MetaException where F1: Into<Option<String>> {
    MetaException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MetaException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MetaException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MetaException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MetaException {
  fn default() -> Self {
    MetaException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for MetaException {}

impl From<MetaException> for thrift::Error {
  fn from(e: MetaException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for MetaException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw MetaException")
  }
}

//
// UnknownTableException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UnknownTableException {
  pub message: Option<String>,
}

impl UnknownTableException {
  pub fn new<F1>(message: F1) -> UnknownTableException where F1: Into<Option<String>> {
    UnknownTableException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UnknownTableException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UnknownTableException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UnknownTableException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UnknownTableException {
  fn default() -> Self {
    UnknownTableException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for UnknownTableException {}

impl From<UnknownTableException> for thrift::Error {
  fn from(e: UnknownTableException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for UnknownTableException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw UnknownTableException")
  }
}

//
// UnknownDBException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UnknownDBException {
  pub message: Option<String>,
}

impl UnknownDBException {
  pub fn new<F1>(message: F1) -> UnknownDBException where F1: Into<Option<String>> {
    UnknownDBException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UnknownDBException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UnknownDBException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UnknownDBException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UnknownDBException {
  fn default() -> Self {
    UnknownDBException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for UnknownDBException {}

impl From<UnknownDBException> for thrift::Error {
  fn from(e: UnknownDBException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for UnknownDBException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw UnknownDBException")
  }
}

//
// AlreadyExistsException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AlreadyExistsException {
  pub message: Option<String>,
}

impl AlreadyExistsException {
  pub fn new<F1>(message: F1) -> AlreadyExistsException where F1: Into<Option<String>> {
    AlreadyExistsException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AlreadyExistsException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AlreadyExistsException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AlreadyExistsException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AlreadyExistsException {
  fn default() -> Self {
    AlreadyExistsException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for AlreadyExistsException {}

impl From<AlreadyExistsException> for thrift::Error {
  fn from(e: AlreadyExistsException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for AlreadyExistsException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw AlreadyExistsException")
  }
}

//
// InvalidPartitionException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvalidPartitionException {
  pub message: Option<String>,
}

impl InvalidPartitionException {
  pub fn new<F1>(message: F1) -> InvalidPartitionException where F1: Into<Option<String>> {
    InvalidPartitionException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvalidPartitionException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InvalidPartitionException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InvalidPartitionException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InvalidPartitionException {
  fn default() -> Self {
    InvalidPartitionException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for InvalidPartitionException {}

impl From<InvalidPartitionException> for thrift::Error {
  fn from(e: InvalidPartitionException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for InvalidPartitionException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw InvalidPartitionException")
  }
}

//
// UnknownPartitionException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UnknownPartitionException {
  pub message: Option<String>,
}

impl UnknownPartitionException {
  pub fn new<F1>(message: F1) -> UnknownPartitionException where F1: Into<Option<String>> {
    UnknownPartitionException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UnknownPartitionException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UnknownPartitionException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UnknownPartitionException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UnknownPartitionException {
  fn default() -> Self {
    UnknownPartitionException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for UnknownPartitionException {}

impl From<UnknownPartitionException> for thrift::Error {
  fn from(e: UnknownPartitionException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for UnknownPartitionException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw UnknownPartitionException")
  }
}

//
// InvalidObjectException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvalidObjectException {
  pub message: Option<String>,
}

impl InvalidObjectException {
  pub fn new<F1>(message: F1) -> InvalidObjectException where F1: Into<Option<String>> {
    InvalidObjectException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvalidObjectException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InvalidObjectException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InvalidObjectException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InvalidObjectException {
  fn default() -> Self {
    InvalidObjectException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for InvalidObjectException {}

impl From<InvalidObjectException> for thrift::Error {
  fn from(e: InvalidObjectException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for InvalidObjectException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw InvalidObjectException")
  }
}

//
// NoSuchObjectException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoSuchObjectException {
  pub message: Option<String>,
}

impl NoSuchObjectException {
  pub fn new<F1>(message: F1) -> NoSuchObjectException where F1: Into<Option<String>> {
    NoSuchObjectException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoSuchObjectException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoSuchObjectException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoSuchObjectException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NoSuchObjectException {
  fn default() -> Self {
    NoSuchObjectException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for NoSuchObjectException {}

impl From<NoSuchObjectException> for thrift::Error {
  fn from(e: NoSuchObjectException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for NoSuchObjectException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw NoSuchObjectException")
  }
}

//
// InvalidOperationException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvalidOperationException {
  pub message: Option<String>,
}

impl InvalidOperationException {
  pub fn new<F1>(message: F1) -> InvalidOperationException where F1: Into<Option<String>> {
    InvalidOperationException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvalidOperationException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InvalidOperationException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InvalidOperationException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InvalidOperationException {
  fn default() -> Self {
    InvalidOperationException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for InvalidOperationException {}

impl From<InvalidOperationException> for thrift::Error {
  fn from(e: InvalidOperationException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for InvalidOperationException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw InvalidOperationException")
  }
}

//
// ConfigValSecurityException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ConfigValSecurityException {
  pub message: Option<String>,
}

impl ConfigValSecurityException {
  pub fn new<F1>(message: F1) -> ConfigValSecurityException where F1: Into<Option<String>> {
    ConfigValSecurityException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ConfigValSecurityException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ConfigValSecurityException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConfigValSecurityException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ConfigValSecurityException {
  fn default() -> Self {
    ConfigValSecurityException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for ConfigValSecurityException {}

impl From<ConfigValSecurityException> for thrift::Error {
  fn from(e: ConfigValSecurityException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ConfigValSecurityException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw ConfigValSecurityException")
  }
}

//
// InvalidInputException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InvalidInputException {
  pub message: Option<String>,
}

impl InvalidInputException {
  pub fn new<F1>(message: F1) -> InvalidInputException where F1: Into<Option<String>> {
    InvalidInputException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InvalidInputException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InvalidInputException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InvalidInputException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InvalidInputException {
  fn default() -> Self {
    InvalidInputException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for InvalidInputException {}

impl From<InvalidInputException> for thrift::Error {
  fn from(e: InvalidInputException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for InvalidInputException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw InvalidInputException")
  }
}

//
// NoSuchTxnException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoSuchTxnException {
  pub message: Option<String>,
}

impl NoSuchTxnException {
  pub fn new<F1>(message: F1) -> NoSuchTxnException where F1: Into<Option<String>> {
    NoSuchTxnException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoSuchTxnException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoSuchTxnException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoSuchTxnException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NoSuchTxnException {
  fn default() -> Self {
    NoSuchTxnException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for NoSuchTxnException {}

impl From<NoSuchTxnException> for thrift::Error {
  fn from(e: NoSuchTxnException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for NoSuchTxnException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw NoSuchTxnException")
  }
}

//
// TxnAbortedException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TxnAbortedException {
  pub message: Option<String>,
}

impl TxnAbortedException {
  pub fn new<F1>(message: F1) -> TxnAbortedException where F1: Into<Option<String>> {
    TxnAbortedException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TxnAbortedException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TxnAbortedException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TxnAbortedException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TxnAbortedException {
  fn default() -> Self {
    TxnAbortedException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for TxnAbortedException {}

impl From<TxnAbortedException> for thrift::Error {
  fn from(e: TxnAbortedException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TxnAbortedException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw TxnAbortedException")
  }
}

//
// TxnOpenException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TxnOpenException {
  pub message: Option<String>,
}

impl TxnOpenException {
  pub fn new<F1>(message: F1) -> TxnOpenException where F1: Into<Option<String>> {
    TxnOpenException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TxnOpenException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TxnOpenException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TxnOpenException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TxnOpenException {
  fn default() -> Self {
    TxnOpenException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for TxnOpenException {}

impl From<TxnOpenException> for thrift::Error {
  fn from(e: TxnOpenException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TxnOpenException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw TxnOpenException")
  }
}

//
// NoSuchLockException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NoSuchLockException {
  pub message: Option<String>,
}

impl NoSuchLockException {
  pub fn new<F1>(message: F1) -> NoSuchLockException where F1: Into<Option<String>> {
    NoSuchLockException {
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NoSuchLockException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NoSuchLockException {
      message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NoSuchLockException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NoSuchLockException {
  fn default() -> Self {
    NoSuchLockException{
      message: Some("".to_owned()),
    }
  }
}

impl Error for NoSuchLockException {}

impl From<NoSuchLockException> for thrift::Error {
  fn from(e: NoSuchLockException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for NoSuchLockException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw NoSuchLockException")
  }
}

pub const DDL_TIME: &str = "transient_lastDdlTime";

pub const HIVE_FILTER_FIELD_OWNER: &str = "hive_filter_field_owner__";

pub const HIVE_FILTER_FIELD_PARAMS: &str = "hive_filter_field_params__";

pub const HIVE_FILTER_FIELD_LAST_ACCESS: &str = "hive_filter_field_last_access__";

pub const IS_ARCHIVED: &str = "is_archived";

pub const ORIGINAL_LOCATION: &str = "original_location";

pub const IS_IMMUTABLE: &str = "immutable";

pub const META_TABLE_COLUMNS: &str = "columns";

pub const META_TABLE_COLUMN_TYPES: &str = "columns.types";

pub const BUCKET_FIELD_NAME: &str = "bucket_field_name";

pub const BUCKET_COUNT: &str = "bucket_count";

pub const FIELD_TO_DIMENSION: &str = "field_to_dimension";

pub const META_TABLE_NAME: &str = "name";

pub const META_TABLE_DB: &str = "db";

pub const META_TABLE_LOCATION: &str = "location";

pub const META_TABLE_SERDE: &str = "serde";

pub const META_TABLE_PARTITION_COLUMNS: &str = "partition_columns";

pub const META_TABLE_PARTITION_COLUMN_TYPES: &str = "partition_columns.types";

pub const FILE_INPUT_FORMAT: &str = "file.inputformat";

pub const FILE_OUTPUT_FORMAT: &str = "file.outputformat";

pub const META_TABLE_STORAGE: &str = "storage_handler";

pub const TABLE_IS_TRANSACTIONAL: &str = "transactional";

pub const TABLE_NO_AUTO_COMPACT: &str = "no_auto_compaction";

pub const TABLE_TRANSACTIONAL_PROPERTIES: &str = "transactional_properties";

pub const TABLE_BUCKETING_VERSION: &str = "bucketing_version";

//
// ThriftHiveMetastore service client
//

/// This interface is live.
pub trait TThriftHiveMetastoreSyncClient : fb303::TFacebookServiceSyncClient {
  fn get_meta_conf(&mut self, key: String) -> thrift::Result<String>;
  fn set_meta_conf(&mut self, key: String, value: String) -> thrift::Result<()>;
  fn create_catalog(&mut self, catalog: CreateCatalogRequest) -> thrift::Result<()>;
  fn alter_catalog(&mut self, rqst: AlterCatalogRequest) -> thrift::Result<()>;
  fn get_catalog(&mut self, cat_name: GetCatalogRequest) -> thrift::Result<GetCatalogResponse>;
  fn get_catalogs(&mut self) -> thrift::Result<GetCatalogsResponse>;
  fn drop_catalog(&mut self, cat_name: DropCatalogRequest) -> thrift::Result<()>;
  fn create_database(&mut self, database: Database) -> thrift::Result<()>;
  fn get_database(&mut self, name: String) -> thrift::Result<Database>;
  fn drop_database(&mut self, name: String, delete_data: bool, cascade: bool) -> thrift::Result<()>;
  fn get_databases(&mut self, pattern: String) -> thrift::Result<Vec<String>>;
  fn get_all_databases(&mut self) -> thrift::Result<Vec<String>>;
  fn alter_database(&mut self, dbname: String, db: Database) -> thrift::Result<()>;
  fn get_type(&mut self, name: String) -> thrift::Result<Type>;
  fn create_type(&mut self, type_: Type) -> thrift::Result<bool>;
  fn drop_type(&mut self, type_: String) -> thrift::Result<bool>;
  fn get_type_all(&mut self, name: String) -> thrift::Result<BTreeMap<String, Type>>;
  fn get_fields(&mut self, db_name: String, table_name: String) -> thrift::Result<Vec<FieldSchema>>;
  fn get_fields_with_environment_context(&mut self, db_name: String, table_name: String, environment_context: EnvironmentContext) -> thrift::Result<Vec<FieldSchema>>;
  fn get_schema(&mut self, db_name: String, table_name: String) -> thrift::Result<Vec<FieldSchema>>;
  fn get_schema_with_environment_context(&mut self, db_name: String, table_name: String, environment_context: EnvironmentContext) -> thrift::Result<Vec<FieldSchema>>;
  fn create_table(&mut self, tbl: Table) -> thrift::Result<()>;
  fn create_table_with_environment_context(&mut self, tbl: Table, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn create_table_with_constraints(&mut self, tbl: Table, primary_keys: Vec<SQLPrimaryKey>, foreign_keys: Vec<SQLForeignKey>, unique_constraints: Vec<SQLUniqueConstraint>, not_null_constraints: Vec<SQLNotNullConstraint>, default_constraints: Vec<SQLDefaultConstraint>, check_constraints: Vec<SQLCheckConstraint>) -> thrift::Result<()>;
  fn drop_constraint(&mut self, req: DropConstraintRequest) -> thrift::Result<()>;
  fn add_primary_key(&mut self, req: AddPrimaryKeyRequest) -> thrift::Result<()>;
  fn add_foreign_key(&mut self, req: AddForeignKeyRequest) -> thrift::Result<()>;
  fn add_unique_constraint(&mut self, req: AddUniqueConstraintRequest) -> thrift::Result<()>;
  fn add_not_null_constraint(&mut self, req: AddNotNullConstraintRequest) -> thrift::Result<()>;
  fn add_default_constraint(&mut self, req: AddDefaultConstraintRequest) -> thrift::Result<()>;
  fn add_check_constraint(&mut self, req: AddCheckConstraintRequest) -> thrift::Result<()>;
  fn drop_table(&mut self, dbname: String, name: String, delete_data: bool) -> thrift::Result<()>;
  fn drop_table_with_environment_context(&mut self, dbname: String, name: String, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn truncate_table(&mut self, db_name: String, table_name: String, part_names: Vec<String>) -> thrift::Result<()>;
  fn get_tables(&mut self, db_name: String, pattern: String) -> thrift::Result<Vec<String>>;
  fn get_tables_by_type(&mut self, db_name: String, pattern: String, table_type: String) -> thrift::Result<Vec<String>>;
  fn get_materialized_views_for_rewriting(&mut self, db_name: String) -> thrift::Result<Vec<String>>;
  fn get_table_meta(&mut self, db_patterns: String, tbl_patterns: String, tbl_types: Vec<String>) -> thrift::Result<Vec<TableMeta>>;
  fn get_all_tables(&mut self, db_name: String) -> thrift::Result<Vec<String>>;
  fn get_table(&mut self, dbname: String, tbl_name: String) -> thrift::Result<Table>;
  fn get_table_objects_by_name(&mut self, dbname: String, tbl_names: Vec<String>) -> thrift::Result<Vec<Table>>;
  fn get_table_req(&mut self, req: GetTableRequest) -> thrift::Result<GetTableResult>;
  fn get_table_objects_by_name_req(&mut self, req: GetTablesRequest) -> thrift::Result<GetTablesResult>;
  fn get_materialization_invalidation_info(&mut self, creation_metadata: CreationMetadata, valid_txn_list: String) -> thrift::Result<Materialization>;
  fn update_creation_metadata(&mut self, cat_name: String, dbname: String, tbl_name: String, creation_metadata: CreationMetadata) -> thrift::Result<()>;
  fn get_table_names_by_filter(&mut self, dbname: String, filter: String, max_tables: i16) -> thrift::Result<Vec<String>>;
  fn alter_table(&mut self, dbname: String, tbl_name: String, new_tbl: Table) -> thrift::Result<()>;
  fn alter_table_with_environment_context(&mut self, dbname: String, tbl_name: String, new_tbl: Table, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn alter_table_with_cascade(&mut self, dbname: String, tbl_name: String, new_tbl: Table, cascade: bool) -> thrift::Result<()>;
  fn add_partition(&mut self, new_part: Partition) -> thrift::Result<Partition>;
  fn add_partition_with_environment_context(&mut self, new_part: Partition, environment_context: EnvironmentContext) -> thrift::Result<Partition>;
  fn add_partitions(&mut self, new_parts: Vec<Partition>) -> thrift::Result<i32>;
  fn add_partitions_pspec(&mut self, new_parts: Vec<PartitionSpec>) -> thrift::Result<i32>;
  fn append_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>) -> thrift::Result<Partition>;
  fn add_partitions_req(&mut self, request: AddPartitionsRequest) -> thrift::Result<AddPartitionsResult>;
  fn append_partition_with_environment_context(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, environment_context: EnvironmentContext) -> thrift::Result<Partition>;
  fn append_partition_by_name(&mut self, db_name: String, tbl_name: String, part_name: String) -> thrift::Result<Partition>;
  fn append_partition_by_name_with_environment_context(&mut self, db_name: String, tbl_name: String, part_name: String, environment_context: EnvironmentContext) -> thrift::Result<Partition>;
  fn drop_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, delete_data: bool) -> thrift::Result<bool>;
  fn drop_partition_with_environment_context(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<bool>;
  fn drop_partition_by_name(&mut self, db_name: String, tbl_name: String, part_name: String, delete_data: bool) -> thrift::Result<bool>;
  fn drop_partition_by_name_with_environment_context(&mut self, db_name: String, tbl_name: String, part_name: String, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<bool>;
  fn drop_partitions_req(&mut self, req: DropPartitionsRequest) -> thrift::Result<DropPartitionsResult>;
  fn get_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>) -> thrift::Result<Partition>;
  fn exchange_partition(&mut self, partition_specs: BTreeMap<String, String>, source_db: String, source_table_name: String, dest_db: String, dest_table_name: String) -> thrift::Result<Partition>;
  fn exchange_partitions(&mut self, partition_specs: BTreeMap<String, String>, source_db: String, source_table_name: String, dest_db: String, dest_table_name: String) -> thrift::Result<Vec<Partition>>;
  fn get_partition_with_auth(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, user_name: String, group_names: Vec<String>) -> thrift::Result<Partition>;
  fn get_partition_by_name(&mut self, db_name: String, tbl_name: String, part_name: String) -> thrift::Result<Partition>;
  fn get_partitions(&mut self, db_name: String, tbl_name: String, max_parts: i16) -> thrift::Result<Vec<Partition>>;
  fn get_partitions_with_auth(&mut self, db_name: String, tbl_name: String, max_parts: i16, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<Partition>>;
  fn get_partitions_pspec(&mut self, db_name: String, tbl_name: String, max_parts: i32) -> thrift::Result<Vec<PartitionSpec>>;
  fn get_partition_names(&mut self, db_name: String, tbl_name: String, max_parts: i16) -> thrift::Result<Vec<String>>;
  fn get_partition_values(&mut self, request: PartitionValuesRequest) -> thrift::Result<PartitionValuesResponse>;
  fn get_partitions_ps(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16) -> thrift::Result<Vec<Partition>>;
  fn get_partitions_ps_with_auth(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<Partition>>;
  fn get_partition_names_ps(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16) -> thrift::Result<Vec<String>>;
  fn get_partitions_by_filter(&mut self, db_name: String, tbl_name: String, filter: String, max_parts: i16) -> thrift::Result<Vec<Partition>>;
  fn get_part_specs_by_filter(&mut self, db_name: String, tbl_name: String, filter: String, max_parts: i32) -> thrift::Result<Vec<PartitionSpec>>;
  fn get_partitions_by_expr(&mut self, req: PartitionsByExprRequest) -> thrift::Result<PartitionsByExprResult>;
  fn get_num_partitions_by_filter(&mut self, db_name: String, tbl_name: String, filter: String) -> thrift::Result<i32>;
  fn get_partitions_by_names(&mut self, db_name: String, tbl_name: String, names: Vec<String>) -> thrift::Result<Vec<Partition>>;
  fn alter_partition(&mut self, db_name: String, tbl_name: String, new_part: Partition) -> thrift::Result<()>;
  fn alter_partitions(&mut self, db_name: String, tbl_name: String, new_parts: Vec<Partition>) -> thrift::Result<()>;
  fn alter_partitions_with_environment_context(&mut self, db_name: String, tbl_name: String, new_parts: Vec<Partition>, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn alter_partition_with_environment_context(&mut self, db_name: String, tbl_name: String, new_part: Partition, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn rename_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, new_part: Partition) -> thrift::Result<()>;
  fn partition_name_has_valid_characters(&mut self, part_vals: Vec<String>, throw_exception: bool) -> thrift::Result<bool>;
  fn get_config_value(&mut self, name: String, default_value: String) -> thrift::Result<String>;
  fn partition_name_to_vals(&mut self, part_name: String) -> thrift::Result<Vec<String>>;
  fn partition_name_to_spec(&mut self, part_name: String) -> thrift::Result<BTreeMap<String, String>>;
  fn mark_partition_for_event(&mut self, db_name: String, tbl_name: String, part_vals: BTreeMap<String, String>, event_type: PartitionEventType) -> thrift::Result<()>;
  fn is_partition_marked_for_event(&mut self, db_name: String, tbl_name: String, part_vals: BTreeMap<String, String>, event_type: PartitionEventType) -> thrift::Result<bool>;
  fn get_primary_keys(&mut self, request: PrimaryKeysRequest) -> thrift::Result<PrimaryKeysResponse>;
  fn get_foreign_keys(&mut self, request: ForeignKeysRequest) -> thrift::Result<ForeignKeysResponse>;
  fn get_unique_constraints(&mut self, request: UniqueConstraintsRequest) -> thrift::Result<UniqueConstraintsResponse>;
  fn get_not_null_constraints(&mut self, request: NotNullConstraintsRequest) -> thrift::Result<NotNullConstraintsResponse>;
  fn get_default_constraints(&mut self, request: DefaultConstraintsRequest) -> thrift::Result<DefaultConstraintsResponse>;
  fn get_check_constraints(&mut self, request: CheckConstraintsRequest) -> thrift::Result<CheckConstraintsResponse>;
  fn update_table_column_statistics(&mut self, stats_obj: ColumnStatistics) -> thrift::Result<bool>;
  fn update_partition_column_statistics(&mut self, stats_obj: ColumnStatistics) -> thrift::Result<bool>;
  fn get_table_column_statistics(&mut self, db_name: String, tbl_name: String, col_name: String) -> thrift::Result<ColumnStatistics>;
  fn get_partition_column_statistics(&mut self, db_name: String, tbl_name: String, part_name: String, col_name: String) -> thrift::Result<ColumnStatistics>;
  fn get_table_statistics_req(&mut self, request: TableStatsRequest) -> thrift::Result<TableStatsResult>;
  fn get_partitions_statistics_req(&mut self, request: PartitionsStatsRequest) -> thrift::Result<PartitionsStatsResult>;
  fn get_aggr_stats_for(&mut self, request: PartitionsStatsRequest) -> thrift::Result<AggrStats>;
  fn set_aggr_stats_for(&mut self, request: SetPartitionsStatsRequest) -> thrift::Result<bool>;
  fn delete_partition_column_statistics(&mut self, db_name: String, tbl_name: String, part_name: String, col_name: String) -> thrift::Result<bool>;
  fn delete_table_column_statistics(&mut self, db_name: String, tbl_name: String, col_name: String) -> thrift::Result<bool>;
  fn create_function(&mut self, func: Function) -> thrift::Result<()>;
  fn drop_function(&mut self, db_name: String, func_name: String) -> thrift::Result<()>;
  fn alter_function(&mut self, db_name: String, func_name: String, new_func: Function) -> thrift::Result<()>;
  fn get_functions(&mut self, db_name: String, pattern: String) -> thrift::Result<Vec<String>>;
  fn get_function(&mut self, db_name: String, func_name: String) -> thrift::Result<Function>;
  fn get_all_functions(&mut self) -> thrift::Result<GetAllFunctionsResponse>;
  fn create_role(&mut self, role: Role) -> thrift::Result<bool>;
  fn drop_role(&mut self, role_name: String) -> thrift::Result<bool>;
  fn get_role_names(&mut self) -> thrift::Result<Vec<String>>;
  fn grant_role(&mut self, role_name: String, principal_name: String, principal_type: PrincipalType, grantor: String, grantor_type: PrincipalType, grant_option: bool) -> thrift::Result<bool>;
  fn revoke_role(&mut self, role_name: String, principal_name: String, principal_type: PrincipalType) -> thrift::Result<bool>;
  fn list_roles(&mut self, principal_name: String, principal_type: PrincipalType) -> thrift::Result<Vec<Role>>;
  fn grant_revoke_role(&mut self, request: GrantRevokeRoleRequest) -> thrift::Result<GrantRevokeRoleResponse>;
  fn get_principals_in_role(&mut self, request: GetPrincipalsInRoleRequest) -> thrift::Result<GetPrincipalsInRoleResponse>;
  fn get_role_grants_for_principal(&mut self, request: GetRoleGrantsForPrincipalRequest) -> thrift::Result<GetRoleGrantsForPrincipalResponse>;
  fn get_privilege_set(&mut self, hive_object: HiveObjectRef, user_name: String, group_names: Vec<String>) -> thrift::Result<PrincipalPrivilegeSet>;
  fn list_privileges(&mut self, principal_name: String, principal_type: PrincipalType, hive_object: HiveObjectRef) -> thrift::Result<Vec<HiveObjectPrivilege>>;
  fn grant_privileges(&mut self, privileges: PrivilegeBag) -> thrift::Result<bool>;
  fn revoke_privileges(&mut self, privileges: PrivilegeBag) -> thrift::Result<bool>;
  fn grant_revoke_privileges(&mut self, request: GrantRevokePrivilegeRequest) -> thrift::Result<GrantRevokePrivilegeResponse>;
  fn refresh_privileges(&mut self, obj_to_refresh: HiveObjectRef, authorizer: String, grant_request: GrantRevokePrivilegeRequest) -> thrift::Result<GrantRevokePrivilegeResponse>;
  fn set_ugi(&mut self, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<String>>;
  fn get_delegation_token(&mut self, token_owner: String, renewer_kerberos_principal_name: String) -> thrift::Result<String>;
  fn renew_delegation_token(&mut self, token_str_form: String) -> thrift::Result<i64>;
  fn cancel_delegation_token(&mut self, token_str_form: String) -> thrift::Result<()>;
  fn add_token(&mut self, token_identifier: String, delegation_token: String) -> thrift::Result<bool>;
  fn remove_token(&mut self, token_identifier: String) -> thrift::Result<bool>;
  fn get_token(&mut self, token_identifier: String) -> thrift::Result<String>;
  fn get_all_token_identifiers(&mut self) -> thrift::Result<Vec<String>>;
  fn add_master_key(&mut self, key: String) -> thrift::Result<i32>;
  fn update_master_key(&mut self, seq_number: i32, key: String) -> thrift::Result<()>;
  fn remove_master_key(&mut self, key_seq: i32) -> thrift::Result<bool>;
  fn get_master_keys(&mut self) -> thrift::Result<Vec<String>>;
  fn get_open_txns(&mut self) -> thrift::Result<GetOpenTxnsResponse>;
  fn get_open_txns_info(&mut self) -> thrift::Result<GetOpenTxnsInfoResponse>;
  fn open_txns(&mut self, rqst: OpenTxnRequest) -> thrift::Result<OpenTxnsResponse>;
  fn abort_txn(&mut self, rqst: AbortTxnRequest) -> thrift::Result<()>;
  fn abort_txns(&mut self, rqst: AbortTxnsRequest) -> thrift::Result<()>;
  fn commit_txn(&mut self, rqst: CommitTxnRequest) -> thrift::Result<()>;
  fn repl_tbl_writeid_state(&mut self, rqst: ReplTblWriteIdStateRequest) -> thrift::Result<()>;
  fn get_valid_write_ids(&mut self, rqst: GetValidWriteIdsRequest) -> thrift::Result<GetValidWriteIdsResponse>;
  fn allocate_table_write_ids(&mut self, rqst: AllocateTableWriteIdsRequest) -> thrift::Result<AllocateTableWriteIdsResponse>;
  fn lock(&mut self, rqst: LockRequest) -> thrift::Result<LockResponse>;
  fn check_lock(&mut self, rqst: CheckLockRequest) -> thrift::Result<LockResponse>;
  fn unlock(&mut self, rqst: UnlockRequest) -> thrift::Result<()>;
  fn show_locks(&mut self, rqst: ShowLocksRequest) -> thrift::Result<ShowLocksResponse>;
  fn heartbeat(&mut self, ids: HeartbeatRequest) -> thrift::Result<()>;
  fn heartbeat_txn_range(&mut self, txns: HeartbeatTxnRangeRequest) -> thrift::Result<HeartbeatTxnRangeResponse>;
  fn compact(&mut self, rqst: CompactionRequest) -> thrift::Result<()>;
  fn compact2(&mut self, rqst: CompactionRequest) -> thrift::Result<CompactionResponse>;
  fn show_compact(&mut self, rqst: ShowCompactRequest) -> thrift::Result<ShowCompactResponse>;
  fn add_dynamic_partitions(&mut self, rqst: AddDynamicPartitions) -> thrift::Result<()>;
  fn get_next_notification(&mut self, rqst: NotificationEventRequest) -> thrift::Result<NotificationEventResponse>;
  fn get_current_notification_event_id(&mut self) -> thrift::Result<CurrentNotificationEventId>;
  fn get_notification_events_count(&mut self, rqst: NotificationEventsCountRequest) -> thrift::Result<NotificationEventsCountResponse>;
  fn fire_listener_event(&mut self, rqst: FireEventRequest) -> thrift::Result<FireEventResponse>;
  fn flush_cache(&mut self) -> thrift::Result<()>;
  fn cm_recycle(&mut self, request: CmRecycleRequest) -> thrift::Result<CmRecycleResponse>;
  fn get_file_metadata_by_expr(&mut self, req: GetFileMetadataByExprRequest) -> thrift::Result<GetFileMetadataByExprResult>;
  fn get_file_metadata(&mut self, req: GetFileMetadataRequest) -> thrift::Result<GetFileMetadataResult>;
  fn put_file_metadata(&mut self, req: PutFileMetadataRequest) -> thrift::Result<PutFileMetadataResult>;
  fn clear_file_metadata(&mut self, req: ClearFileMetadataRequest) -> thrift::Result<ClearFileMetadataResult>;
  fn cache_file_metadata(&mut self, req: CacheFileMetadataRequest) -> thrift::Result<CacheFileMetadataResult>;
  fn get_metastore_db_uuid(&mut self) -> thrift::Result<String>;
  fn create_resource_plan(&mut self, request: WMCreateResourcePlanRequest) -> thrift::Result<WMCreateResourcePlanResponse>;
  fn get_resource_plan(&mut self, request: WMGetResourcePlanRequest) -> thrift::Result<WMGetResourcePlanResponse>;
  fn get_active_resource_plan(&mut self, request: WMGetActiveResourcePlanRequest) -> thrift::Result<WMGetActiveResourcePlanResponse>;
  fn get_all_resource_plans(&mut self, request: WMGetAllResourcePlanRequest) -> thrift::Result<WMGetAllResourcePlanResponse>;
  fn alter_resource_plan(&mut self, request: WMAlterResourcePlanRequest) -> thrift::Result<WMAlterResourcePlanResponse>;
  fn validate_resource_plan(&mut self, request: WMValidateResourcePlanRequest) -> thrift::Result<WMValidateResourcePlanResponse>;
  fn drop_resource_plan(&mut self, request: WMDropResourcePlanRequest) -> thrift::Result<WMDropResourcePlanResponse>;
  fn create_wm_trigger(&mut self, request: WMCreateTriggerRequest) -> thrift::Result<WMCreateTriggerResponse>;
  fn alter_wm_trigger(&mut self, request: WMAlterTriggerRequest) -> thrift::Result<WMAlterTriggerResponse>;
  fn drop_wm_trigger(&mut self, request: WMDropTriggerRequest) -> thrift::Result<WMDropTriggerResponse>;
  fn get_triggers_for_resourceplan(&mut self, request: WMGetTriggersForResourePlanRequest) -> thrift::Result<WMGetTriggersForResourePlanResponse>;
  fn create_wm_pool(&mut self, request: WMCreatePoolRequest) -> thrift::Result<WMCreatePoolResponse>;
  fn alter_wm_pool(&mut self, request: WMAlterPoolRequest) -> thrift::Result<WMAlterPoolResponse>;
  fn drop_wm_pool(&mut self, request: WMDropPoolRequest) -> thrift::Result<WMDropPoolResponse>;
  fn create_or_update_wm_mapping(&mut self, request: WMCreateOrUpdateMappingRequest) -> thrift::Result<WMCreateOrUpdateMappingResponse>;
  fn drop_wm_mapping(&mut self, request: WMDropMappingRequest) -> thrift::Result<WMDropMappingResponse>;
  fn create_or_drop_wm_trigger_to_pool_mapping(&mut self, request: WMCreateOrDropTriggerToPoolMappingRequest) -> thrift::Result<WMCreateOrDropTriggerToPoolMappingResponse>;
  fn create_ischema(&mut self, schema: ISchema) -> thrift::Result<()>;
  fn alter_ischema(&mut self, rqst: AlterISchemaRequest) -> thrift::Result<()>;
  fn get_ischema(&mut self, name: ISchemaName) -> thrift::Result<ISchema>;
  fn drop_ischema(&mut self, name: ISchemaName) -> thrift::Result<()>;
  fn add_schema_version(&mut self, schema_version: SchemaVersion) -> thrift::Result<()>;
  fn get_schema_version(&mut self, schema_version: SchemaVersionDescriptor) -> thrift::Result<SchemaVersion>;
  fn get_schema_latest_version(&mut self, schema_name: ISchemaName) -> thrift::Result<SchemaVersion>;
  fn get_schema_all_versions(&mut self, schema_name: ISchemaName) -> thrift::Result<Vec<SchemaVersion>>;
  fn drop_schema_version(&mut self, schema_version: SchemaVersionDescriptor) -> thrift::Result<()>;
  fn get_schemas_by_cols(&mut self, rqst: FindSchemasByColsRqst) -> thrift::Result<FindSchemasByColsResp>;
  fn map_schema_version_to_serde(&mut self, rqst: MapSchemaVersionToSerdeRequest) -> thrift::Result<()>;
  fn set_schema_version_state(&mut self, rqst: SetSchemaVersionStateRequest) -> thrift::Result<()>;
  fn add_serde(&mut self, serde: SerDeInfo) -> thrift::Result<()>;
  fn get_serde(&mut self, rqst: GetSerdeRequest) -> thrift::Result<SerDeInfo>;
  fn get_lock_materialization_rebuild(&mut self, db_name: String, table_name: String, txn_id: i64) -> thrift::Result<LockResponse>;
  fn heartbeat_lock_materialization_rebuild(&mut self, db_name: String, table_name: String, txn_id: i64) -> thrift::Result<bool>;
  fn add_runtime_stats(&mut self, stat: RuntimeStat) -> thrift::Result<()>;
  fn get_runtime_stats(&mut self, rqst: GetRuntimeStatsRequest) -> thrift::Result<Vec<RuntimeStat>>;
}

pub trait TThriftHiveMetastoreSyncClientMarker {}

pub struct ThriftHiveMetastoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ThriftHiveMetastoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ThriftHiveMetastoreSyncClient<IP, OP> {
    ThriftHiveMetastoreSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ThriftHiveMetastoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TThriftHiveMetastoreSyncClientMarker for ThriftHiveMetastoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}
impl <IP, OP> fb303::TFacebookServiceSyncClientMarker for ThriftHiveMetastoreSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TThriftHiveMetastoreSyncClientMarker + fb303::TFacebookServiceSyncClientMarker> TThriftHiveMetastoreSyncClient for C {
  fn get_meta_conf(&mut self, key: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getMetaConf", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetMetaConfArgs { key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getMetaConf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetMetaConfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_meta_conf(&mut self, key: String, value: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setMetaConf", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreSetMetaConfArgs { key, value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setMetaConf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreSetMetaConfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_catalog(&mut self, catalog: CreateCatalogRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateCatalogArgs { catalog };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_catalog", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateCatalogResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_catalog(&mut self, rqst: AlterCatalogRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterCatalogArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_catalog", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterCatalogResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_catalog(&mut self, cat_name: GetCatalogRequest) -> thrift::Result<GetCatalogResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetCatalogArgs { cat_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_catalog", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetCatalogResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_catalogs(&mut self) -> thrift::Result<GetCatalogsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_catalogs", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetCatalogsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_catalogs", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetCatalogsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_catalog(&mut self, cat_name: DropCatalogRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropCatalogArgs { cat_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_catalog", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropCatalogResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_database(&mut self, database: Database) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_database", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateDatabaseArgs { database };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_database(&mut self, name: String) -> thrift::Result<Database> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_database", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetDatabaseArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_database(&mut self, name: String, delete_data: bool, cascade: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropDatabaseArgs { name, delete_data, cascade };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_databases(&mut self, pattern: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetDatabasesArgs { pattern };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_databases", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetDatabasesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_databases(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_databases", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetAllDatabasesArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_databases", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetAllDatabasesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_database(&mut self, dbname: String, db: Database) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterDatabaseArgs { dbname, db };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_database", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterDatabaseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_type(&mut self, name: String) -> thrift::Result<Type> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_type", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTypeArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_type", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTypeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_type(&mut self, type_: Type) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_type", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateTypeArgs { type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_type", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateTypeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_type(&mut self, type_: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropTypeArgs { type_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_type", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropTypeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_type_all(&mut self, name: String) -> thrift::Result<BTreeMap<String, Type>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_type_all", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTypeAllArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_type_all", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTypeAllResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_fields(&mut self, db_name: String, table_name: String) -> thrift::Result<Vec<FieldSchema>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetFieldsArgs { db_name, table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_fields", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetFieldsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_fields_with_environment_context(&mut self, db_name: String, table_name: String, environment_context: EnvironmentContext) -> thrift::Result<Vec<FieldSchema>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs { db_name, table_name, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_fields_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schema(&mut self, db_name: String, table_name: String) -> thrift::Result<Vec<FieldSchema>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSchemaArgs { db_name, table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_schema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSchemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schema_with_environment_context(&mut self, db_name: String, table_name: String, environment_context: EnvironmentContext) -> thrift::Result<Vec<FieldSchema>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs { db_name, table_name, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_schema_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_table(&mut self, tbl: Table) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateTableArgs { tbl };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_table_with_environment_context(&mut self, tbl: Table, environment_context: EnvironmentContext) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs { tbl, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_table_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_table_with_constraints(&mut self, tbl: Table, primary_keys: Vec<SQLPrimaryKey>, foreign_keys: Vec<SQLForeignKey>, unique_constraints: Vec<SQLUniqueConstraint>, not_null_constraints: Vec<SQLNotNullConstraint>, default_constraints: Vec<SQLDefaultConstraint>, check_constraints: Vec<SQLCheckConstraint>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateTableWithConstraintsArgs { tbl, primary_keys, foreign_keys, unique_constraints, not_null_constraints, default_constraints, check_constraints };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_table_with_constraints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateTableWithConstraintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_constraint(&mut self, req: DropConstraintRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropConstraintArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_constraint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropConstraintResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_primary_key(&mut self, req: AddPrimaryKeyRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddPrimaryKeyArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_primary_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddPrimaryKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_foreign_key(&mut self, req: AddForeignKeyRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddForeignKeyArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_foreign_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddForeignKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_unique_constraint(&mut self, req: AddUniqueConstraintRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddUniqueConstraintArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_unique_constraint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddUniqueConstraintResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_not_null_constraint(&mut self, req: AddNotNullConstraintRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddNotNullConstraintArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_not_null_constraint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddNotNullConstraintResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_default_constraint(&mut self, req: AddDefaultConstraintRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddDefaultConstraintArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_default_constraint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddDefaultConstraintResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_check_constraint(&mut self, req: AddCheckConstraintRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddCheckConstraintArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_check_constraint", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddCheckConstraintResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_table(&mut self, dbname: String, name: String, delete_data: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropTableArgs { dbname, name, delete_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_table_with_environment_context(&mut self, dbname: String, name: String, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropTableWithEnvironmentContextArgs { dbname, name, delete_data, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_table_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropTableWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn truncate_table(&mut self, db_name: String, table_name: String, part_names: Vec<String>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("truncate_table", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreTruncateTableArgs { db_name, table_name, part_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("truncate_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreTruncateTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables(&mut self, db_name: String, pattern: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTablesArgs { db_name, pattern };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_tables_by_type(&mut self, db_name: String, pattern: String, table_type: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_tables_by_type", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTablesByTypeArgs { db_name, pattern, table_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_tables_by_type", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTablesByTypeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_materialized_views_for_rewriting(&mut self, db_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_materialized_views_for_rewriting", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs { db_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_materialized_views_for_rewriting", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetMaterializedViewsForRewritingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_meta(&mut self, db_patterns: String, tbl_patterns: String, tbl_types: Vec<String>) -> thrift::Result<Vec<TableMeta>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_meta", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableMetaArgs { db_patterns, tbl_patterns, tbl_types };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_meta", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableMetaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_tables(&mut self, db_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_tables", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetAllTablesArgs { db_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_tables", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetAllTablesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table(&mut self, dbname: String, tbl_name: String) -> thrift::Result<Table> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableArgs { dbname, tbl_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_objects_by_name(&mut self, dbname: String, tbl_names: Vec<String>) -> thrift::Result<Vec<Table>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_objects_by_name", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableObjectsByNameArgs { dbname, tbl_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_objects_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableObjectsByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_req(&mut self, req: GetTableRequest) -> thrift::Result<GetTableResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableReqArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_req", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableReqResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_objects_by_name_req(&mut self, req: GetTablesRequest) -> thrift::Result<GetTablesResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableObjectsByNameReqArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_objects_by_name_req", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableObjectsByNameReqResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_materialization_invalidation_info(&mut self, creation_metadata: CreationMetadata, valid_txn_list: String) -> thrift::Result<Materialization> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs { creation_metadata, valid_txn_list };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_materialization_invalidation_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetMaterializationInvalidationInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_creation_metadata(&mut self, cat_name: String, dbname: String, tbl_name: String, creation_metadata: CreationMetadata) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreUpdateCreationMetadataArgs { cat_name, dbname, tbl_name, creation_metadata };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_creation_metadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreUpdateCreationMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_names_by_filter(&mut self, dbname: String, filter: String, max_tables: i16) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableNamesByFilterArgs { dbname, filter, max_tables };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_names_by_filter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableNamesByFilterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_table(&mut self, dbname: String, tbl_name: String, new_tbl: Table) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterTableArgs { dbname, tbl_name, new_tbl };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_table", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterTableResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_table_with_environment_context(&mut self, dbname: String, tbl_name: String, new_tbl: Table, environment_context: EnvironmentContext) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs { dbname, tbl_name, new_tbl, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_table_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterTableWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_table_with_cascade(&mut self, dbname: String, tbl_name: String, new_tbl: Table, cascade: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterTableWithCascadeArgs { dbname, tbl_name, new_tbl, cascade };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_table_with_cascade", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterTableWithCascadeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_partition(&mut self, new_part: Partition) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddPartitionArgs { new_part };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddPartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_partition_with_environment_context(&mut self, new_part: Partition, environment_context: EnvironmentContext) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs { new_part, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_partition_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_partitions(&mut self, new_parts: Vec<Partition>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddPartitionsArgs { new_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_partitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddPartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_partitions_pspec(&mut self, new_parts: Vec<PartitionSpec>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddPartitionsPspecArgs { new_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_partitions_pspec", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddPartitionsPspecResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn append_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAppendPartitionArgs { db_name, tbl_name, part_vals };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("append_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAppendPartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_partitions_req(&mut self, request: AddPartitionsRequest) -> thrift::Result<AddPartitionsResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddPartitionsReqArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_partitions_req", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddPartitionsReqResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn append_partition_with_environment_context(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, environment_context: EnvironmentContext) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs { db_name, tbl_name, part_vals, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("append_partition_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn append_partition_by_name(&mut self, db_name: String, tbl_name: String, part_name: String) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAppendPartitionByNameArgs { db_name, tbl_name, part_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("append_partition_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAppendPartitionByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn append_partition_by_name_with_environment_context(&mut self, db_name: String, tbl_name: String, part_name: String, environment_context: EnvironmentContext) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs { db_name, tbl_name, part_name, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("append_partition_by_name_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, delete_data: bool) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropPartitionArgs { db_name, tbl_name, part_vals, delete_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropPartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_partition_with_environment_context(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs { db_name, tbl_name, part_vals, delete_data, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_partition_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_partition_by_name(&mut self, db_name: String, tbl_name: String, part_name: String, delete_data: bool) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropPartitionByNameArgs { db_name, tbl_name, part_name, delete_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_partition_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropPartitionByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_partition_by_name_with_environment_context(&mut self, db_name: String, tbl_name: String, part_name: String, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs { db_name, tbl_name, part_name, delete_data, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_partition_by_name_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_partitions_req(&mut self, req: DropPartitionsRequest) -> thrift::Result<DropPartitionsResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropPartitionsReqArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_partitions_req", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropPartitionsReqResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionArgs { db_name, tbl_name, part_vals };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn exchange_partition(&mut self, partition_specs: BTreeMap<String, String>, source_db: String, source_table_name: String, dest_db: String, dest_table_name: String) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreExchangePartitionArgs { partition_specs, source_db, source_table_name, dest_db, dest_table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("exchange_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreExchangePartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn exchange_partitions(&mut self, partition_specs: BTreeMap<String, String>, source_db: String, source_table_name: String, dest_db: String, dest_table_name: String) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreExchangePartitionsArgs { partition_specs, source_db, source_table_name, dest_db, dest_table_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("exchange_partitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreExchangePartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition_with_auth(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, user_name: String, group_names: Vec<String>) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionWithAuthArgs { db_name, tbl_name, part_vals, user_name, group_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition_with_auth", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionWithAuthResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition_by_name(&mut self, db_name: String, tbl_name: String, part_name: String) -> thrift::Result<Partition> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionByNameArgs { db_name, tbl_name, part_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition_by_name", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionByNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions(&mut self, db_name: String, tbl_name: String, max_parts: i16) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsArgs { db_name, tbl_name, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_with_auth(&mut self, db_name: String, tbl_name: String, max_parts: i16, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsWithAuthArgs { db_name, tbl_name, max_parts, user_name, group_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_with_auth", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsWithAuthResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_pspec(&mut self, db_name: String, tbl_name: String, max_parts: i32) -> thrift::Result<Vec<PartitionSpec>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsPspecArgs { db_name, tbl_name, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_pspec", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsPspecResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition_names(&mut self, db_name: String, tbl_name: String, max_parts: i16) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionNamesArgs { db_name, tbl_name, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition_names", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionNamesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition_values(&mut self, request: PartitionValuesRequest) -> thrift::Result<PartitionValuesResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionValuesArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition_values", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionValuesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_ps(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsPsArgs { db_name, tbl_name, part_vals, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_ps", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsPsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_ps_with_auth(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsPsWithAuthArgs { db_name, tbl_name, part_vals, max_parts, user_name, group_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_ps_with_auth", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsPsWithAuthResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition_names_ps(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionNamesPsArgs { db_name, tbl_name, part_vals, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition_names_ps", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionNamesPsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_by_filter(&mut self, db_name: String, tbl_name: String, filter: String, max_parts: i16) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsByFilterArgs { db_name, tbl_name, filter, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_by_filter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsByFilterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_part_specs_by_filter(&mut self, db_name: String, tbl_name: String, filter: String, max_parts: i32) -> thrift::Result<Vec<PartitionSpec>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartSpecsByFilterArgs { db_name, tbl_name, filter, max_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_part_specs_by_filter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartSpecsByFilterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_by_expr(&mut self, req: PartitionsByExprRequest) -> thrift::Result<PartitionsByExprResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsByExprArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_by_expr", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsByExprResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_num_partitions_by_filter(&mut self, db_name: String, tbl_name: String, filter: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetNumPartitionsByFilterArgs { db_name, tbl_name, filter };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_num_partitions_by_filter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetNumPartitionsByFilterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_by_names(&mut self, db_name: String, tbl_name: String, names: Vec<String>) -> thrift::Result<Vec<Partition>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsByNamesArgs { db_name, tbl_name, names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_by_names", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsByNamesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_partition(&mut self, db_name: String, tbl_name: String, new_part: Partition) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterPartitionArgs { db_name, tbl_name, new_part };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterPartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_partitions(&mut self, db_name: String, tbl_name: String, new_parts: Vec<Partition>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterPartitionsArgs { db_name, tbl_name, new_parts };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_partitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterPartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_partitions_with_environment_context(&mut self, db_name: String, tbl_name: String, new_parts: Vec<Partition>, environment_context: EnvironmentContext) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs { db_name, tbl_name, new_parts, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_partitions_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_partition_with_environment_context(&mut self, db_name: String, tbl_name: String, new_part: Partition, environment_context: EnvironmentContext) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs { db_name, tbl_name, new_part, environment_context };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_partition_with_environment_context", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn rename_partition(&mut self, db_name: String, tbl_name: String, part_vals: Vec<String>, new_part: Partition) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRenamePartitionArgs { db_name, tbl_name, part_vals, new_part };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("rename_partition", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRenamePartitionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn partition_name_has_valid_characters(&mut self, part_vals: Vec<String>, throw_exception: bool) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("partition_name_has_valid_characters", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastorePartitionNameHasValidCharactersArgs { part_vals, throw_exception };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("partition_name_has_valid_characters", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastorePartitionNameHasValidCharactersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_config_value(&mut self, name: String, default_value: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_config_value", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetConfigValueArgs { name, default_value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_config_value", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetConfigValueResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn partition_name_to_vals(&mut self, part_name: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("partition_name_to_vals", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastorePartitionNameToValsArgs { part_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("partition_name_to_vals", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastorePartitionNameToValsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn partition_name_to_spec(&mut self, part_name: String) -> thrift::Result<BTreeMap<String, String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("partition_name_to_spec", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastorePartitionNameToSpecArgs { part_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("partition_name_to_spec", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastorePartitionNameToSpecResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mark_partition_for_event(&mut self, db_name: String, tbl_name: String, part_vals: BTreeMap<String, String>, event_type: PartitionEventType) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreMarkPartitionForEventArgs { db_name, tbl_name, part_vals, event_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("markPartitionForEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreMarkPartitionForEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_partition_marked_for_event(&mut self, db_name: String, tbl_name: String, part_vals: BTreeMap<String, String>, event_type: PartitionEventType) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreIsPartitionMarkedForEventArgs { db_name, tbl_name, part_vals, event_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("isPartitionMarkedForEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreIsPartitionMarkedForEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_primary_keys(&mut self, request: PrimaryKeysRequest) -> thrift::Result<PrimaryKeysResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPrimaryKeysArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_primary_keys", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPrimaryKeysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_foreign_keys(&mut self, request: ForeignKeysRequest) -> thrift::Result<ForeignKeysResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetForeignKeysArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_foreign_keys", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetForeignKeysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_unique_constraints(&mut self, request: UniqueConstraintsRequest) -> thrift::Result<UniqueConstraintsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetUniqueConstraintsArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_unique_constraints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetUniqueConstraintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_not_null_constraints(&mut self, request: NotNullConstraintsRequest) -> thrift::Result<NotNullConstraintsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetNotNullConstraintsArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_not_null_constraints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetNotNullConstraintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_default_constraints(&mut self, request: DefaultConstraintsRequest) -> thrift::Result<DefaultConstraintsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetDefaultConstraintsArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_default_constraints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetDefaultConstraintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_check_constraints(&mut self, request: CheckConstraintsRequest) -> thrift::Result<CheckConstraintsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetCheckConstraintsArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_check_constraints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetCheckConstraintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_table_column_statistics(&mut self, stats_obj: ColumnStatistics) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreUpdateTableColumnStatisticsArgs { stats_obj };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_table_column_statistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreUpdateTableColumnStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_partition_column_statistics(&mut self, stats_obj: ColumnStatistics) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs { stats_obj };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_partition_column_statistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_column_statistics(&mut self, db_name: String, tbl_name: String, col_name: String) -> thrift::Result<ColumnStatistics> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableColumnStatisticsArgs { db_name, tbl_name, col_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_column_statistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableColumnStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partition_column_statistics(&mut self, db_name: String, tbl_name: String, part_name: String, col_name: String) -> thrift::Result<ColumnStatistics> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionColumnStatisticsArgs { db_name, tbl_name, part_name, col_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partition_column_statistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionColumnStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_statistics_req(&mut self, request: TableStatsRequest) -> thrift::Result<TableStatsResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTableStatisticsReqArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_statistics_req", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTableStatisticsReqResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_partitions_statistics_req(&mut self, request: PartitionsStatsRequest) -> thrift::Result<PartitionsStatsResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPartitionsStatisticsReqArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_partitions_statistics_req", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPartitionsStatisticsReqResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_aggr_stats_for(&mut self, request: PartitionsStatsRequest) -> thrift::Result<AggrStats> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetAggrStatsForArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_aggr_stats_for", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetAggrStatsForResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_aggr_stats_for(&mut self, request: SetPartitionsStatsRequest) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreSetAggrStatsForArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_aggr_stats_for", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreSetAggrStatsForResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_partition_column_statistics(&mut self, db_name: String, tbl_name: String, part_name: String, col_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs { db_name, tbl_name, part_name, col_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_partition_column_statistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_table_column_statistics(&mut self, db_name: String, tbl_name: String, col_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDeleteTableColumnStatisticsArgs { db_name, tbl_name, col_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("delete_table_column_statistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDeleteTableColumnStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_function(&mut self, func: Function) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_function", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateFunctionArgs { func };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_function", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateFunctionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_function(&mut self, db_name: String, func_name: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropFunctionArgs { db_name, func_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_function", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropFunctionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_function(&mut self, db_name: String, func_name: String, new_func: Function) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterFunctionArgs { db_name, func_name, new_func };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_function", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterFunctionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_functions(&mut self, db_name: String, pattern: String) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_functions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetFunctionsArgs { db_name, pattern };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_functions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetFunctionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_function(&mut self, db_name: String, func_name: String) -> thrift::Result<Function> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_function", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetFunctionArgs { db_name, func_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_function", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetFunctionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_functions(&mut self) -> thrift::Result<GetAllFunctionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_functions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetAllFunctionsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_functions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetAllFunctionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_role(&mut self, role: Role) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_role", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateRoleArgs { role };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_role(&mut self, role_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_role", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropRoleArgs { role_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_role_names(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_role_names", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetRoleNamesArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_role_names", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetRoleNamesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn grant_role(&mut self, role_name: String, principal_name: String, principal_type: PrincipalType, grantor: String, grantor_type: PrincipalType, grant_option: bool) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("grant_role", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGrantRoleArgs { role_name, principal_name, principal_type, grantor, grantor_type, grant_option };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("grant_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGrantRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn revoke_role(&mut self, role_name: String, principal_name: String, principal_type: PrincipalType) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("revoke_role", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRevokeRoleArgs { role_name, principal_name, principal_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("revoke_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRevokeRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_roles(&mut self, principal_name: String, principal_type: PrincipalType) -> thrift::Result<Vec<Role>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("list_roles", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreListRolesArgs { principal_name, principal_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("list_roles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreListRolesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn grant_revoke_role(&mut self, request: GrantRevokeRoleRequest) -> thrift::Result<GrantRevokeRoleResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("grant_revoke_role", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGrantRevokeRoleArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("grant_revoke_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGrantRevokeRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_principals_in_role(&mut self, request: GetPrincipalsInRoleRequest) -> thrift::Result<GetPrincipalsInRoleResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_principals_in_role", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPrincipalsInRoleArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_principals_in_role", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPrincipalsInRoleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_role_grants_for_principal(&mut self, request: GetRoleGrantsForPrincipalRequest) -> thrift::Result<GetRoleGrantsForPrincipalResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_role_grants_for_principal", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_role_grants_for_principal", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetRoleGrantsForPrincipalResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_privilege_set(&mut self, hive_object: HiveObjectRef, user_name: String, group_names: Vec<String>) -> thrift::Result<PrincipalPrivilegeSet> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_privilege_set", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetPrivilegeSetArgs { hive_object, user_name, group_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_privilege_set", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetPrivilegeSetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_privileges(&mut self, principal_name: String, principal_type: PrincipalType, hive_object: HiveObjectRef) -> thrift::Result<Vec<HiveObjectPrivilege>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("list_privileges", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreListPrivilegesArgs { principal_name, principal_type, hive_object };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("list_privileges", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreListPrivilegesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn grant_privileges(&mut self, privileges: PrivilegeBag) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("grant_privileges", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGrantPrivilegesArgs { privileges };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("grant_privileges", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGrantPrivilegesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn revoke_privileges(&mut self, privileges: PrivilegeBag) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("revoke_privileges", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRevokePrivilegesArgs { privileges };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("revoke_privileges", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRevokePrivilegesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn grant_revoke_privileges(&mut self, request: GrantRevokePrivilegeRequest) -> thrift::Result<GrantRevokePrivilegeResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("grant_revoke_privileges", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGrantRevokePrivilegesArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("grant_revoke_privileges", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGrantRevokePrivilegesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn refresh_privileges(&mut self, obj_to_refresh: HiveObjectRef, authorizer: String, grant_request: GrantRevokePrivilegeRequest) -> thrift::Result<GrantRevokePrivilegeResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("refresh_privileges", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRefreshPrivilegesArgs { obj_to_refresh, authorizer, grant_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("refresh_privileges", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRefreshPrivilegesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_ugi(&mut self, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_ugi", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreSetUgiArgs { user_name, group_names };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_ugi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreSetUgiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_delegation_token(&mut self, token_owner: String, renewer_kerberos_principal_name: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_delegation_token", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetDelegationTokenArgs { token_owner, renewer_kerberos_principal_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_delegation_token", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetDelegationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn renew_delegation_token(&mut self, token_str_form: String) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("renew_delegation_token", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRenewDelegationTokenArgs { token_str_form };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("renew_delegation_token", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRenewDelegationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_delegation_token(&mut self, token_str_form: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cancel_delegation_token", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCancelDelegationTokenArgs { token_str_form };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cancel_delegation_token", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCancelDelegationTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_token(&mut self, token_identifier: String, delegation_token: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_token", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddTokenArgs { token_identifier, delegation_token };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_token", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_token(&mut self, token_identifier: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("remove_token", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRemoveTokenArgs { token_identifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("remove_token", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRemoveTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_token(&mut self, token_identifier: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_token", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTokenArgs { token_identifier };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_token", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_token_identifiers(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_token_identifiers", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetAllTokenIdentifiersArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_token_identifiers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetAllTokenIdentifiersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_master_key(&mut self, key: String) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_master_key", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddMasterKeyArgs { key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_master_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddMasterKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_master_key(&mut self, seq_number: i32, key: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreUpdateMasterKeyArgs { seq_number, key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_master_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreUpdateMasterKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_master_key(&mut self, key_seq: i32) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("remove_master_key", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreRemoveMasterKeyArgs { key_seq };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("remove_master_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreRemoveMasterKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_master_keys(&mut self) -> thrift::Result<Vec<String>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_master_keys", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetMasterKeysArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_master_keys", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetMasterKeysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_open_txns(&mut self) -> thrift::Result<GetOpenTxnsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_open_txns", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetOpenTxnsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_open_txns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetOpenTxnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_open_txns_info(&mut self) -> thrift::Result<GetOpenTxnsInfoResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_open_txns_info", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetOpenTxnsInfoArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_open_txns_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetOpenTxnsInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn open_txns(&mut self, rqst: OpenTxnRequest) -> thrift::Result<OpenTxnsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("open_txns", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreOpenTxnsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("open_txns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreOpenTxnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn abort_txn(&mut self, rqst: AbortTxnRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("abort_txn", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAbortTxnArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("abort_txn", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAbortTxnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn abort_txns(&mut self, rqst: AbortTxnsRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("abort_txns", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAbortTxnsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("abort_txns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAbortTxnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn commit_txn(&mut self, rqst: CommitTxnRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCommitTxnArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("commit_txn", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCommitTxnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn repl_tbl_writeid_state(&mut self, rqst: ReplTblWriteIdStateRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("repl_tbl_writeid_state", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreReplTblWriteidStateArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("repl_tbl_writeid_state", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreReplTblWriteidStateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_valid_write_ids(&mut self, rqst: GetValidWriteIdsRequest) -> thrift::Result<GetValidWriteIdsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetValidWriteIdsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_valid_write_ids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetValidWriteIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn allocate_table_write_ids(&mut self, rqst: AllocateTableWriteIdsRequest) -> thrift::Result<AllocateTableWriteIdsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAllocateTableWriteIdsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("allocate_table_write_ids", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAllocateTableWriteIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lock(&mut self, rqst: LockRequest) -> thrift::Result<LockResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("lock", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreLockArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("lock", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreLockResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_lock(&mut self, rqst: CheckLockRequest) -> thrift::Result<LockResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCheckLockArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("check_lock", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCheckLockResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unlock(&mut self, rqst: UnlockRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unlock", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreUnlockArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unlock", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreUnlockResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn show_locks(&mut self, rqst: ShowLocksRequest) -> thrift::Result<ShowLocksResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("show_locks", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreShowLocksArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("show_locks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreShowLocksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn heartbeat(&mut self, ids: HeartbeatRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreHeartbeatArgs { ids };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("heartbeat", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreHeartbeatResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn heartbeat_txn_range(&mut self, txns: HeartbeatTxnRangeRequest) -> thrift::Result<HeartbeatTxnRangeResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("heartbeat_txn_range", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreHeartbeatTxnRangeArgs { txns };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("heartbeat_txn_range", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreHeartbeatTxnRangeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn compact(&mut self, rqst: CompactionRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("compact", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCompactArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("compact", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCompactResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn compact2(&mut self, rqst: CompactionRequest) -> thrift::Result<CompactionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("compact2", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCompact2Args { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("compact2", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCompact2Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn show_compact(&mut self, rqst: ShowCompactRequest) -> thrift::Result<ShowCompactResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("show_compact", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreShowCompactArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("show_compact", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreShowCompactResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_dynamic_partitions(&mut self, rqst: AddDynamicPartitions) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddDynamicPartitionsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_dynamic_partitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddDynamicPartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_next_notification(&mut self, rqst: NotificationEventRequest) -> thrift::Result<NotificationEventResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_next_notification", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetNextNotificationArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_next_notification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetNextNotificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_current_notification_event_id(&mut self) -> thrift::Result<CurrentNotificationEventId> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_current_notificationEventId", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetCurrentNotificationEventIdArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_current_notificationEventId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetCurrentNotificationEventIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_notification_events_count(&mut self, rqst: NotificationEventsCountRequest) -> thrift::Result<NotificationEventsCountResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_notification_events_count", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetNotificationEventsCountArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_notification_events_count", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetNotificationEventsCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fire_listener_event(&mut self, rqst: FireEventRequest) -> thrift::Result<FireEventResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fire_listener_event", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreFireListenerEventArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fire_listener_event", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreFireListenerEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn flush_cache(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("flushCache", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreFlushCacheArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("flushCache", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreFlushCacheResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cm_recycle(&mut self, request: CmRecycleRequest) -> thrift::Result<CmRecycleResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cm_recycle", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCmRecycleArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cm_recycle", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCmRecycleResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_file_metadata_by_expr(&mut self, req: GetFileMetadataByExprRequest) -> thrift::Result<GetFileMetadataByExprResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_file_metadata_by_expr", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetFileMetadataByExprArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_file_metadata_by_expr", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetFileMetadataByExprResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_file_metadata(&mut self, req: GetFileMetadataRequest) -> thrift::Result<GetFileMetadataResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_file_metadata", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetFileMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_file_metadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetFileMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn put_file_metadata(&mut self, req: PutFileMetadataRequest) -> thrift::Result<PutFileMetadataResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("put_file_metadata", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastorePutFileMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("put_file_metadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastorePutFileMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn clear_file_metadata(&mut self, req: ClearFileMetadataRequest) -> thrift::Result<ClearFileMetadataResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("clear_file_metadata", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreClearFileMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("clear_file_metadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreClearFileMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cache_file_metadata(&mut self, req: CacheFileMetadataRequest) -> thrift::Result<CacheFileMetadataResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cache_file_metadata", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCacheFileMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cache_file_metadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCacheFileMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_metastore_db_uuid(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_metastore_db_uuid", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetMetastoreDbUuidArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_metastore_db_uuid", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetMetastoreDbUuidResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_resource_plan(&mut self, request: WMCreateResourcePlanRequest) -> thrift::Result<WMCreateResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateResourcePlanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_resource_plan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateResourcePlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_plan(&mut self, request: WMGetResourcePlanRequest) -> thrift::Result<WMGetResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetResourcePlanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_resource_plan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetResourcePlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_resource_plan(&mut self, request: WMGetActiveResourcePlanRequest) -> thrift::Result<WMGetActiveResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_active_resource_plan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetActiveResourcePlanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_active_resource_plan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetActiveResourcePlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_all_resource_plans(&mut self, request: WMGetAllResourcePlanRequest) -> thrift::Result<WMGetAllResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_all_resource_plans", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetAllResourcePlansArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_all_resource_plans", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetAllResourcePlansResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_resource_plan(&mut self, request: WMAlterResourcePlanRequest) -> thrift::Result<WMAlterResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterResourcePlanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_resource_plan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterResourcePlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn validate_resource_plan(&mut self, request: WMValidateResourcePlanRequest) -> thrift::Result<WMValidateResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreValidateResourcePlanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("validate_resource_plan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreValidateResourcePlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_resource_plan(&mut self, request: WMDropResourcePlanRequest) -> thrift::Result<WMDropResourcePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropResourcePlanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_resource_plan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropResourcePlanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_wm_trigger(&mut self, request: WMCreateTriggerRequest) -> thrift::Result<WMCreateTriggerResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateWmTriggerArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_wm_trigger", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateWmTriggerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_wm_trigger(&mut self, request: WMAlterTriggerRequest) -> thrift::Result<WMAlterTriggerResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterWmTriggerArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_wm_trigger", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterWmTriggerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_wm_trigger(&mut self, request: WMDropTriggerRequest) -> thrift::Result<WMDropTriggerResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropWmTriggerArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_wm_trigger", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropWmTriggerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_triggers_for_resourceplan(&mut self, request: WMGetTriggersForResourePlanRequest) -> thrift::Result<WMGetTriggersForResourePlanResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetTriggersForResourceplanArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_triggers_for_resourceplan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetTriggersForResourceplanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_wm_pool(&mut self, request: WMCreatePoolRequest) -> thrift::Result<WMCreatePoolResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateWmPoolArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_wm_pool", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateWmPoolResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_wm_pool(&mut self, request: WMAlterPoolRequest) -> thrift::Result<WMAlterPoolResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterWmPoolArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_wm_pool", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterWmPoolResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_wm_pool(&mut self, request: WMDropPoolRequest) -> thrift::Result<WMDropPoolResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropWmPoolArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_wm_pool", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropWmPoolResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_or_update_wm_mapping(&mut self, request: WMCreateOrUpdateMappingRequest) -> thrift::Result<WMCreateOrUpdateMappingResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateOrUpdateWmMappingArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_or_update_wm_mapping", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateOrUpdateWmMappingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_wm_mapping(&mut self, request: WMDropMappingRequest) -> thrift::Result<WMDropMappingResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropWmMappingArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_wm_mapping", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropWmMappingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_or_drop_wm_trigger_to_pool_mapping(&mut self, request: WMCreateOrDropTriggerToPoolMappingRequest) -> thrift::Result<WMCreateOrDropTriggerToPoolMappingResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_or_drop_wm_trigger_to_pool_mapping", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_ischema(&mut self, schema: ISchema) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreCreateIschemaArgs { schema };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_ischema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreCreateIschemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alter_ischema(&mut self, rqst: AlterISchemaRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAlterIschemaArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alter_ischema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAlterIschemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_ischema(&mut self, name: ISchemaName) -> thrift::Result<ISchema> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetIschemaArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_ischema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetIschemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_ischema(&mut self, name: ISchemaName) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropIschemaArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_ischema", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropIschemaResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_schema_version(&mut self, schema_version: SchemaVersion) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddSchemaVersionArgs { schema_version };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_schema_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddSchemaVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schema_version(&mut self, schema_version: SchemaVersionDescriptor) -> thrift::Result<SchemaVersion> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSchemaVersionArgs { schema_version };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_schema_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSchemaVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schema_latest_version(&mut self, schema_name: ISchemaName) -> thrift::Result<SchemaVersion> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSchemaLatestVersionArgs { schema_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_schema_latest_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSchemaLatestVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schema_all_versions(&mut self, schema_name: ISchemaName) -> thrift::Result<Vec<SchemaVersion>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSchemaAllVersionsArgs { schema_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_schema_all_versions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSchemaAllVersionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_schema_version(&mut self, schema_version: SchemaVersionDescriptor) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreDropSchemaVersionArgs { schema_version };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("drop_schema_version", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreDropSchemaVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_schemas_by_cols(&mut self, rqst: FindSchemasByColsRqst) -> thrift::Result<FindSchemasByColsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_schemas_by_cols", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSchemasByColsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_schemas_by_cols", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSchemasByColsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn map_schema_version_to_serde(&mut self, rqst: MapSchemaVersionToSerdeRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreMapSchemaVersionToSerdeArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("map_schema_version_to_serde", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreMapSchemaVersionToSerdeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_schema_version_state(&mut self, rqst: SetSchemaVersionStateRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreSetSchemaVersionStateArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_schema_version_state", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreSetSchemaVersionStateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_serde(&mut self, serde: SerDeInfo) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddSerdeArgs { serde };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_serde", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddSerdeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_serde(&mut self, rqst: GetSerdeRequest) -> thrift::Result<SerDeInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetSerdeArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_serde", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetSerdeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_lock_materialization_rebuild(&mut self, db_name: String, table_name: String, txn_id: i64) -> thrift::Result<LockResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_lock_materialization_rebuild", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetLockMaterializationRebuildArgs { db_name, table_name, txn_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_lock_materialization_rebuild", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetLockMaterializationRebuildResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn heartbeat_lock_materialization_rebuild(&mut self, db_name: String, table_name: String, txn_id: i64) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("heartbeat_lock_materialization_rebuild", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs { db_name, table_name, txn_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("heartbeat_lock_materialization_rebuild", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn add_runtime_stats(&mut self, stat: RuntimeStat) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("add_runtime_stats", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreAddRuntimeStatsArgs { stat };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("add_runtime_stats", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreAddRuntimeStatsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_runtime_stats(&mut self, rqst: GetRuntimeStatsRequest) -> thrift::Result<Vec<RuntimeStat>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_runtime_stats", TMessageType::Call, self.sequence_number());
        let call_args = ThriftHiveMetastoreGetRuntimeStatsArgs { rqst };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_runtime_stats", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ThriftHiveMetastoreGetRuntimeStatsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ThriftHiveMetastore service processor
//

/// This interface is live.
pub trait ThriftHiveMetastoreSyncHandler : fb303::FacebookServiceSyncHandler {
  fn handle_get_meta_conf(&self, key: String) -> thrift::Result<String>;
  fn handle_set_meta_conf(&self, key: String, value: String) -> thrift::Result<()>;
  fn handle_create_catalog(&self, catalog: CreateCatalogRequest) -> thrift::Result<()>;
  fn handle_alter_catalog(&self, rqst: AlterCatalogRequest) -> thrift::Result<()>;
  fn handle_get_catalog(&self, cat_name: GetCatalogRequest) -> thrift::Result<GetCatalogResponse>;
  fn handle_get_catalogs(&self) -> thrift::Result<GetCatalogsResponse>;
  fn handle_drop_catalog(&self, cat_name: DropCatalogRequest) -> thrift::Result<()>;
  fn handle_create_database(&self, database: Database) -> thrift::Result<()>;
  fn handle_get_database(&self, name: String) -> thrift::Result<Database>;
  fn handle_drop_database(&self, name: String, delete_data: bool, cascade: bool) -> thrift::Result<()>;
  fn handle_get_databases(&self, pattern: String) -> thrift::Result<Vec<String>>;
  fn handle_get_all_databases(&self) -> thrift::Result<Vec<String>>;
  fn handle_alter_database(&self, dbname: String, db: Database) -> thrift::Result<()>;
  fn handle_get_type(&self, name: String) -> thrift::Result<Type>;
  fn handle_create_type(&self, type_: Type) -> thrift::Result<bool>;
  fn handle_drop_type(&self, type_: String) -> thrift::Result<bool>;
  fn handle_get_type_all(&self, name: String) -> thrift::Result<BTreeMap<String, Type>>;
  fn handle_get_fields(&self, db_name: String, table_name: String) -> thrift::Result<Vec<FieldSchema>>;
  fn handle_get_fields_with_environment_context(&self, db_name: String, table_name: String, environment_context: EnvironmentContext) -> thrift::Result<Vec<FieldSchema>>;
  fn handle_get_schema(&self, db_name: String, table_name: String) -> thrift::Result<Vec<FieldSchema>>;
  fn handle_get_schema_with_environment_context(&self, db_name: String, table_name: String, environment_context: EnvironmentContext) -> thrift::Result<Vec<FieldSchema>>;
  fn handle_create_table(&self, tbl: Table) -> thrift::Result<()>;
  fn handle_create_table_with_environment_context(&self, tbl: Table, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn handle_create_table_with_constraints(&self, tbl: Table, primary_keys: Vec<SQLPrimaryKey>, foreign_keys: Vec<SQLForeignKey>, unique_constraints: Vec<SQLUniqueConstraint>, not_null_constraints: Vec<SQLNotNullConstraint>, default_constraints: Vec<SQLDefaultConstraint>, check_constraints: Vec<SQLCheckConstraint>) -> thrift::Result<()>;
  fn handle_drop_constraint(&self, req: DropConstraintRequest) -> thrift::Result<()>;
  fn handle_add_primary_key(&self, req: AddPrimaryKeyRequest) -> thrift::Result<()>;
  fn handle_add_foreign_key(&self, req: AddForeignKeyRequest) -> thrift::Result<()>;
  fn handle_add_unique_constraint(&self, req: AddUniqueConstraintRequest) -> thrift::Result<()>;
  fn handle_add_not_null_constraint(&self, req: AddNotNullConstraintRequest) -> thrift::Result<()>;
  fn handle_add_default_constraint(&self, req: AddDefaultConstraintRequest) -> thrift::Result<()>;
  fn handle_add_check_constraint(&self, req: AddCheckConstraintRequest) -> thrift::Result<()>;
  fn handle_drop_table(&self, dbname: String, name: String, delete_data: bool) -> thrift::Result<()>;
  fn handle_drop_table_with_environment_context(&self, dbname: String, name: String, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn handle_truncate_table(&self, db_name: String, table_name: String, part_names: Vec<String>) -> thrift::Result<()>;
  fn handle_get_tables(&self, db_name: String, pattern: String) -> thrift::Result<Vec<String>>;
  fn handle_get_tables_by_type(&self, db_name: String, pattern: String, table_type: String) -> thrift::Result<Vec<String>>;
  fn handle_get_materialized_views_for_rewriting(&self, db_name: String) -> thrift::Result<Vec<String>>;
  fn handle_get_table_meta(&self, db_patterns: String, tbl_patterns: String, tbl_types: Vec<String>) -> thrift::Result<Vec<TableMeta>>;
  fn handle_get_all_tables(&self, db_name: String) -> thrift::Result<Vec<String>>;
  fn handle_get_table(&self, dbname: String, tbl_name: String) -> thrift::Result<Table>;
  fn handle_get_table_objects_by_name(&self, dbname: String, tbl_names: Vec<String>) -> thrift::Result<Vec<Table>>;
  fn handle_get_table_req(&self, req: GetTableRequest) -> thrift::Result<GetTableResult>;
  fn handle_get_table_objects_by_name_req(&self, req: GetTablesRequest) -> thrift::Result<GetTablesResult>;
  fn handle_get_materialization_invalidation_info(&self, creation_metadata: CreationMetadata, valid_txn_list: String) -> thrift::Result<Materialization>;
  fn handle_update_creation_metadata(&self, cat_name: String, dbname: String, tbl_name: String, creation_metadata: CreationMetadata) -> thrift::Result<()>;
  fn handle_get_table_names_by_filter(&self, dbname: String, filter: String, max_tables: i16) -> thrift::Result<Vec<String>>;
  fn handle_alter_table(&self, dbname: String, tbl_name: String, new_tbl: Table) -> thrift::Result<()>;
  fn handle_alter_table_with_environment_context(&self, dbname: String, tbl_name: String, new_tbl: Table, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn handle_alter_table_with_cascade(&self, dbname: String, tbl_name: String, new_tbl: Table, cascade: bool) -> thrift::Result<()>;
  fn handle_add_partition(&self, new_part: Partition) -> thrift::Result<Partition>;
  fn handle_add_partition_with_environment_context(&self, new_part: Partition, environment_context: EnvironmentContext) -> thrift::Result<Partition>;
  fn handle_add_partitions(&self, new_parts: Vec<Partition>) -> thrift::Result<i32>;
  fn handle_add_partitions_pspec(&self, new_parts: Vec<PartitionSpec>) -> thrift::Result<i32>;
  fn handle_append_partition(&self, db_name: String, tbl_name: String, part_vals: Vec<String>) -> thrift::Result<Partition>;
  fn handle_add_partitions_req(&self, request: AddPartitionsRequest) -> thrift::Result<AddPartitionsResult>;
  fn handle_append_partition_with_environment_context(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, environment_context: EnvironmentContext) -> thrift::Result<Partition>;
  fn handle_append_partition_by_name(&self, db_name: String, tbl_name: String, part_name: String) -> thrift::Result<Partition>;
  fn handle_append_partition_by_name_with_environment_context(&self, db_name: String, tbl_name: String, part_name: String, environment_context: EnvironmentContext) -> thrift::Result<Partition>;
  fn handle_drop_partition(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, delete_data: bool) -> thrift::Result<bool>;
  fn handle_drop_partition_with_environment_context(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<bool>;
  fn handle_drop_partition_by_name(&self, db_name: String, tbl_name: String, part_name: String, delete_data: bool) -> thrift::Result<bool>;
  fn handle_drop_partition_by_name_with_environment_context(&self, db_name: String, tbl_name: String, part_name: String, delete_data: bool, environment_context: EnvironmentContext) -> thrift::Result<bool>;
  fn handle_drop_partitions_req(&self, req: DropPartitionsRequest) -> thrift::Result<DropPartitionsResult>;
  fn handle_get_partition(&self, db_name: String, tbl_name: String, part_vals: Vec<String>) -> thrift::Result<Partition>;
  fn handle_exchange_partition(&self, partition_specs: BTreeMap<String, String>, source_db: String, source_table_name: String, dest_db: String, dest_table_name: String) -> thrift::Result<Partition>;
  fn handle_exchange_partitions(&self, partition_specs: BTreeMap<String, String>, source_db: String, source_table_name: String, dest_db: String, dest_table_name: String) -> thrift::Result<Vec<Partition>>;
  fn handle_get_partition_with_auth(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, user_name: String, group_names: Vec<String>) -> thrift::Result<Partition>;
  fn handle_get_partition_by_name(&self, db_name: String, tbl_name: String, part_name: String) -> thrift::Result<Partition>;
  fn handle_get_partitions(&self, db_name: String, tbl_name: String, max_parts: i16) -> thrift::Result<Vec<Partition>>;
  fn handle_get_partitions_with_auth(&self, db_name: String, tbl_name: String, max_parts: i16, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<Partition>>;
  fn handle_get_partitions_pspec(&self, db_name: String, tbl_name: String, max_parts: i32) -> thrift::Result<Vec<PartitionSpec>>;
  fn handle_get_partition_names(&self, db_name: String, tbl_name: String, max_parts: i16) -> thrift::Result<Vec<String>>;
  fn handle_get_partition_values(&self, request: PartitionValuesRequest) -> thrift::Result<PartitionValuesResponse>;
  fn handle_get_partitions_ps(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16) -> thrift::Result<Vec<Partition>>;
  fn handle_get_partitions_ps_with_auth(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<Partition>>;
  fn handle_get_partition_names_ps(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, max_parts: i16) -> thrift::Result<Vec<String>>;
  fn handle_get_partitions_by_filter(&self, db_name: String, tbl_name: String, filter: String, max_parts: i16) -> thrift::Result<Vec<Partition>>;
  fn handle_get_part_specs_by_filter(&self, db_name: String, tbl_name: String, filter: String, max_parts: i32) -> thrift::Result<Vec<PartitionSpec>>;
  fn handle_get_partitions_by_expr(&self, req: PartitionsByExprRequest) -> thrift::Result<PartitionsByExprResult>;
  fn handle_get_num_partitions_by_filter(&self, db_name: String, tbl_name: String, filter: String) -> thrift::Result<i32>;
  fn handle_get_partitions_by_names(&self, db_name: String, tbl_name: String, names: Vec<String>) -> thrift::Result<Vec<Partition>>;
  fn handle_alter_partition(&self, db_name: String, tbl_name: String, new_part: Partition) -> thrift::Result<()>;
  fn handle_alter_partitions(&self, db_name: String, tbl_name: String, new_parts: Vec<Partition>) -> thrift::Result<()>;
  fn handle_alter_partitions_with_environment_context(&self, db_name: String, tbl_name: String, new_parts: Vec<Partition>, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn handle_alter_partition_with_environment_context(&self, db_name: String, tbl_name: String, new_part: Partition, environment_context: EnvironmentContext) -> thrift::Result<()>;
  fn handle_rename_partition(&self, db_name: String, tbl_name: String, part_vals: Vec<String>, new_part: Partition) -> thrift::Result<()>;
  fn handle_partition_name_has_valid_characters(&self, part_vals: Vec<String>, throw_exception: bool) -> thrift::Result<bool>;
  fn handle_get_config_value(&self, name: String, default_value: String) -> thrift::Result<String>;
  fn handle_partition_name_to_vals(&self, part_name: String) -> thrift::Result<Vec<String>>;
  fn handle_partition_name_to_spec(&self, part_name: String) -> thrift::Result<BTreeMap<String, String>>;
  fn handle_mark_partition_for_event(&self, db_name: String, tbl_name: String, part_vals: BTreeMap<String, String>, event_type: PartitionEventType) -> thrift::Result<()>;
  fn handle_is_partition_marked_for_event(&self, db_name: String, tbl_name: String, part_vals: BTreeMap<String, String>, event_type: PartitionEventType) -> thrift::Result<bool>;
  fn handle_get_primary_keys(&self, request: PrimaryKeysRequest) -> thrift::Result<PrimaryKeysResponse>;
  fn handle_get_foreign_keys(&self, request: ForeignKeysRequest) -> thrift::Result<ForeignKeysResponse>;
  fn handle_get_unique_constraints(&self, request: UniqueConstraintsRequest) -> thrift::Result<UniqueConstraintsResponse>;
  fn handle_get_not_null_constraints(&self, request: NotNullConstraintsRequest) -> thrift::Result<NotNullConstraintsResponse>;
  fn handle_get_default_constraints(&self, request: DefaultConstraintsRequest) -> thrift::Result<DefaultConstraintsResponse>;
  fn handle_get_check_constraints(&self, request: CheckConstraintsRequest) -> thrift::Result<CheckConstraintsResponse>;
  fn handle_update_table_column_statistics(&self, stats_obj: ColumnStatistics) -> thrift::Result<bool>;
  fn handle_update_partition_column_statistics(&self, stats_obj: ColumnStatistics) -> thrift::Result<bool>;
  fn handle_get_table_column_statistics(&self, db_name: String, tbl_name: String, col_name: String) -> thrift::Result<ColumnStatistics>;
  fn handle_get_partition_column_statistics(&self, db_name: String, tbl_name: String, part_name: String, col_name: String) -> thrift::Result<ColumnStatistics>;
  fn handle_get_table_statistics_req(&self, request: TableStatsRequest) -> thrift::Result<TableStatsResult>;
  fn handle_get_partitions_statistics_req(&self, request: PartitionsStatsRequest) -> thrift::Result<PartitionsStatsResult>;
  fn handle_get_aggr_stats_for(&self, request: PartitionsStatsRequest) -> thrift::Result<AggrStats>;
  fn handle_set_aggr_stats_for(&self, request: SetPartitionsStatsRequest) -> thrift::Result<bool>;
  fn handle_delete_partition_column_statistics(&self, db_name: String, tbl_name: String, part_name: String, col_name: String) -> thrift::Result<bool>;
  fn handle_delete_table_column_statistics(&self, db_name: String, tbl_name: String, col_name: String) -> thrift::Result<bool>;
  fn handle_create_function(&self, func: Function) -> thrift::Result<()>;
  fn handle_drop_function(&self, db_name: String, func_name: String) -> thrift::Result<()>;
  fn handle_alter_function(&self, db_name: String, func_name: String, new_func: Function) -> thrift::Result<()>;
  fn handle_get_functions(&self, db_name: String, pattern: String) -> thrift::Result<Vec<String>>;
  fn handle_get_function(&self, db_name: String, func_name: String) -> thrift::Result<Function>;
  fn handle_get_all_functions(&self) -> thrift::Result<GetAllFunctionsResponse>;
  fn handle_create_role(&self, role: Role) -> thrift::Result<bool>;
  fn handle_drop_role(&self, role_name: String) -> thrift::Result<bool>;
  fn handle_get_role_names(&self) -> thrift::Result<Vec<String>>;
  fn handle_grant_role(&self, role_name: String, principal_name: String, principal_type: PrincipalType, grantor: String, grantor_type: PrincipalType, grant_option: bool) -> thrift::Result<bool>;
  fn handle_revoke_role(&self, role_name: String, principal_name: String, principal_type: PrincipalType) -> thrift::Result<bool>;
  fn handle_list_roles(&self, principal_name: String, principal_type: PrincipalType) -> thrift::Result<Vec<Role>>;
  fn handle_grant_revoke_role(&self, request: GrantRevokeRoleRequest) -> thrift::Result<GrantRevokeRoleResponse>;
  fn handle_get_principals_in_role(&self, request: GetPrincipalsInRoleRequest) -> thrift::Result<GetPrincipalsInRoleResponse>;
  fn handle_get_role_grants_for_principal(&self, request: GetRoleGrantsForPrincipalRequest) -> thrift::Result<GetRoleGrantsForPrincipalResponse>;
  fn handle_get_privilege_set(&self, hive_object: HiveObjectRef, user_name: String, group_names: Vec<String>) -> thrift::Result<PrincipalPrivilegeSet>;
  fn handle_list_privileges(&self, principal_name: String, principal_type: PrincipalType, hive_object: HiveObjectRef) -> thrift::Result<Vec<HiveObjectPrivilege>>;
  fn handle_grant_privileges(&self, privileges: PrivilegeBag) -> thrift::Result<bool>;
  fn handle_revoke_privileges(&self, privileges: PrivilegeBag) -> thrift::Result<bool>;
  fn handle_grant_revoke_privileges(&self, request: GrantRevokePrivilegeRequest) -> thrift::Result<GrantRevokePrivilegeResponse>;
  fn handle_refresh_privileges(&self, obj_to_refresh: HiveObjectRef, authorizer: String, grant_request: GrantRevokePrivilegeRequest) -> thrift::Result<GrantRevokePrivilegeResponse>;
  fn handle_set_ugi(&self, user_name: String, group_names: Vec<String>) -> thrift::Result<Vec<String>>;
  fn handle_get_delegation_token(&self, token_owner: String, renewer_kerberos_principal_name: String) -> thrift::Result<String>;
  fn handle_renew_delegation_token(&self, token_str_form: String) -> thrift::Result<i64>;
  fn handle_cancel_delegation_token(&self, token_str_form: String) -> thrift::Result<()>;
  fn handle_add_token(&self, token_identifier: String, delegation_token: String) -> thrift::Result<bool>;
  fn handle_remove_token(&self, token_identifier: String) -> thrift::Result<bool>;
  fn handle_get_token(&self, token_identifier: String) -> thrift::Result<String>;
  fn handle_get_all_token_identifiers(&self) -> thrift::Result<Vec<String>>;
  fn handle_add_master_key(&self, key: String) -> thrift::Result<i32>;
  fn handle_update_master_key(&self, seq_number: i32, key: String) -> thrift::Result<()>;
  fn handle_remove_master_key(&self, key_seq: i32) -> thrift::Result<bool>;
  fn handle_get_master_keys(&self) -> thrift::Result<Vec<String>>;
  fn handle_get_open_txns(&self) -> thrift::Result<GetOpenTxnsResponse>;
  fn handle_get_open_txns_info(&self) -> thrift::Result<GetOpenTxnsInfoResponse>;
  fn handle_open_txns(&self, rqst: OpenTxnRequest) -> thrift::Result<OpenTxnsResponse>;
  fn handle_abort_txn(&self, rqst: AbortTxnRequest) -> thrift::Result<()>;
  fn handle_abort_txns(&self, rqst: AbortTxnsRequest) -> thrift::Result<()>;
  fn handle_commit_txn(&self, rqst: CommitTxnRequest) -> thrift::Result<()>;
  fn handle_repl_tbl_writeid_state(&self, rqst: ReplTblWriteIdStateRequest) -> thrift::Result<()>;
  fn handle_get_valid_write_ids(&self, rqst: GetValidWriteIdsRequest) -> thrift::Result<GetValidWriteIdsResponse>;
  fn handle_allocate_table_write_ids(&self, rqst: AllocateTableWriteIdsRequest) -> thrift::Result<AllocateTableWriteIdsResponse>;
  fn handle_lock(&self, rqst: LockRequest) -> thrift::Result<LockResponse>;
  fn handle_check_lock(&self, rqst: CheckLockRequest) -> thrift::Result<LockResponse>;
  fn handle_unlock(&self, rqst: UnlockRequest) -> thrift::Result<()>;
  fn handle_show_locks(&self, rqst: ShowLocksRequest) -> thrift::Result<ShowLocksResponse>;
  fn handle_heartbeat(&self, ids: HeartbeatRequest) -> thrift::Result<()>;
  fn handle_heartbeat_txn_range(&self, txns: HeartbeatTxnRangeRequest) -> thrift::Result<HeartbeatTxnRangeResponse>;
  fn handle_compact(&self, rqst: CompactionRequest) -> thrift::Result<()>;
  fn handle_compact2(&self, rqst: CompactionRequest) -> thrift::Result<CompactionResponse>;
  fn handle_show_compact(&self, rqst: ShowCompactRequest) -> thrift::Result<ShowCompactResponse>;
  fn handle_add_dynamic_partitions(&self, rqst: AddDynamicPartitions) -> thrift::Result<()>;
  fn handle_get_next_notification(&self, rqst: NotificationEventRequest) -> thrift::Result<NotificationEventResponse>;
  fn handle_get_current_notification_event_id(&self) -> thrift::Result<CurrentNotificationEventId>;
  fn handle_get_notification_events_count(&self, rqst: NotificationEventsCountRequest) -> thrift::Result<NotificationEventsCountResponse>;
  fn handle_fire_listener_event(&self, rqst: FireEventRequest) -> thrift::Result<FireEventResponse>;
  fn handle_flush_cache(&self) -> thrift::Result<()>;
  fn handle_cm_recycle(&self, request: CmRecycleRequest) -> thrift::Result<CmRecycleResponse>;
  fn handle_get_file_metadata_by_expr(&self, req: GetFileMetadataByExprRequest) -> thrift::Result<GetFileMetadataByExprResult>;
  fn handle_get_file_metadata(&self, req: GetFileMetadataRequest) -> thrift::Result<GetFileMetadataResult>;
  fn handle_put_file_metadata(&self, req: PutFileMetadataRequest) -> thrift::Result<PutFileMetadataResult>;
  fn handle_clear_file_metadata(&self, req: ClearFileMetadataRequest) -> thrift::Result<ClearFileMetadataResult>;
  fn handle_cache_file_metadata(&self, req: CacheFileMetadataRequest) -> thrift::Result<CacheFileMetadataResult>;
  fn handle_get_metastore_db_uuid(&self) -> thrift::Result<String>;
  fn handle_create_resource_plan(&self, request: WMCreateResourcePlanRequest) -> thrift::Result<WMCreateResourcePlanResponse>;
  fn handle_get_resource_plan(&self, request: WMGetResourcePlanRequest) -> thrift::Result<WMGetResourcePlanResponse>;
  fn handle_get_active_resource_plan(&self, request: WMGetActiveResourcePlanRequest) -> thrift::Result<WMGetActiveResourcePlanResponse>;
  fn handle_get_all_resource_plans(&self, request: WMGetAllResourcePlanRequest) -> thrift::Result<WMGetAllResourcePlanResponse>;
  fn handle_alter_resource_plan(&self, request: WMAlterResourcePlanRequest) -> thrift::Result<WMAlterResourcePlanResponse>;
  fn handle_validate_resource_plan(&self, request: WMValidateResourcePlanRequest) -> thrift::Result<WMValidateResourcePlanResponse>;
  fn handle_drop_resource_plan(&self, request: WMDropResourcePlanRequest) -> thrift::Result<WMDropResourcePlanResponse>;
  fn handle_create_wm_trigger(&self, request: WMCreateTriggerRequest) -> thrift::Result<WMCreateTriggerResponse>;
  fn handle_alter_wm_trigger(&self, request: WMAlterTriggerRequest) -> thrift::Result<WMAlterTriggerResponse>;
  fn handle_drop_wm_trigger(&self, request: WMDropTriggerRequest) -> thrift::Result<WMDropTriggerResponse>;
  fn handle_get_triggers_for_resourceplan(&self, request: WMGetTriggersForResourePlanRequest) -> thrift::Result<WMGetTriggersForResourePlanResponse>;
  fn handle_create_wm_pool(&self, request: WMCreatePoolRequest) -> thrift::Result<WMCreatePoolResponse>;
  fn handle_alter_wm_pool(&self, request: WMAlterPoolRequest) -> thrift::Result<WMAlterPoolResponse>;
  fn handle_drop_wm_pool(&self, request: WMDropPoolRequest) -> thrift::Result<WMDropPoolResponse>;
  fn handle_create_or_update_wm_mapping(&self, request: WMCreateOrUpdateMappingRequest) -> thrift::Result<WMCreateOrUpdateMappingResponse>;
  fn handle_drop_wm_mapping(&self, request: WMDropMappingRequest) -> thrift::Result<WMDropMappingResponse>;
  fn handle_create_or_drop_wm_trigger_to_pool_mapping(&self, request: WMCreateOrDropTriggerToPoolMappingRequest) -> thrift::Result<WMCreateOrDropTriggerToPoolMappingResponse>;
  fn handle_create_ischema(&self, schema: ISchema) -> thrift::Result<()>;
  fn handle_alter_ischema(&self, rqst: AlterISchemaRequest) -> thrift::Result<()>;
  fn handle_get_ischema(&self, name: ISchemaName) -> thrift::Result<ISchema>;
  fn handle_drop_ischema(&self, name: ISchemaName) -> thrift::Result<()>;
  fn handle_add_schema_version(&self, schema_version: SchemaVersion) -> thrift::Result<()>;
  fn handle_get_schema_version(&self, schema_version: SchemaVersionDescriptor) -> thrift::Result<SchemaVersion>;
  fn handle_get_schema_latest_version(&self, schema_name: ISchemaName) -> thrift::Result<SchemaVersion>;
  fn handle_get_schema_all_versions(&self, schema_name: ISchemaName) -> thrift::Result<Vec<SchemaVersion>>;
  fn handle_drop_schema_version(&self, schema_version: SchemaVersionDescriptor) -> thrift::Result<()>;
  fn handle_get_schemas_by_cols(&self, rqst: FindSchemasByColsRqst) -> thrift::Result<FindSchemasByColsResp>;
  fn handle_map_schema_version_to_serde(&self, rqst: MapSchemaVersionToSerdeRequest) -> thrift::Result<()>;
  fn handle_set_schema_version_state(&self, rqst: SetSchemaVersionStateRequest) -> thrift::Result<()>;
  fn handle_add_serde(&self, serde: SerDeInfo) -> thrift::Result<()>;
  fn handle_get_serde(&self, rqst: GetSerdeRequest) -> thrift::Result<SerDeInfo>;
  fn handle_get_lock_materialization_rebuild(&self, db_name: String, table_name: String, txn_id: i64) -> thrift::Result<LockResponse>;
  fn handle_heartbeat_lock_materialization_rebuild(&self, db_name: String, table_name: String, txn_id: i64) -> thrift::Result<bool>;
  fn handle_add_runtime_stats(&self, stat: RuntimeStat) -> thrift::Result<()>;
  fn handle_get_runtime_stats(&self, rqst: GetRuntimeStatsRequest) -> thrift::Result<Vec<RuntimeStat>>;
}

pub struct ThriftHiveMetastoreSyncProcessor<H: ThriftHiveMetastoreSyncHandler> {
  handler: H,
}

impl <H: ThriftHiveMetastoreSyncHandler> ThriftHiveMetastoreSyncProcessor<H> {
  pub fn new(handler: H) -> ThriftHiveMetastoreSyncProcessor<H> {
    ThriftHiveMetastoreSyncProcessor {
      handler,
    }
  }
  fn process_get_meta_conf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_meta_conf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_meta_conf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_set_meta_conf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_catalog(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_catalog(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_catalog(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_catalog(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_catalog(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_catalog(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_catalogs(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_catalogs(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_catalog(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_catalog(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_databases(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_databases(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_databases(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_all_databases(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_database(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_database(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_type(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_type(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_type(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_type(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_type(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_type(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_type_all(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_type_all(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_fields(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_fields(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_fields_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_fields_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_schema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schema_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_schema_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_table_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_table_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_table_with_constraints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_table_with_constraints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_constraint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_constraint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_primary_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_primary_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_foreign_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_foreign_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_unique_constraint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_unique_constraint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_not_null_constraint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_not_null_constraint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_default_constraint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_default_constraint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_check_constraint(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_check_constraint(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_table_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_table_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_truncate_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_truncate_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_tables_by_type(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_tables_by_type(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_materialized_views_for_rewriting(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_materialized_views_for_rewriting(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_meta(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_meta(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_tables(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_all_tables(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_objects_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_objects_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_req(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_req(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_objects_by_name_req(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_objects_by_name_req(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_materialization_invalidation_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_materialization_invalidation_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_creation_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_update_creation_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_names_by_filter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_names_by_filter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_table(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_table(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_table_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_table_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_table_with_cascade(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_table_with_cascade(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_partition_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_partition_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_partitions_pspec(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_partitions_pspec(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_append_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_append_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_partitions_req(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_partitions_req(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_append_partition_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_append_partition_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_append_partition_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_append_partition_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_append_partition_by_name_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_append_partition_by_name_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_partition_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_partition_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_partition_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_partition_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_partition_by_name_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_partition_by_name_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_partitions_req(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_partitions_req(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_exchange_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_exchange_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_exchange_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_exchange_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition_with_auth(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition_with_auth(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition_by_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition_by_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_with_auth(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_with_auth(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_pspec(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_pspec(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition_names(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition_names(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition_values(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition_values(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_ps(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_ps(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_ps_with_auth(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_ps_with_auth(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition_names_ps(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition_names_ps(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_by_filter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_by_filter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_part_specs_by_filter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_part_specs_by_filter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_by_expr(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_by_expr(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_num_partitions_by_filter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_num_partitions_by_filter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_by_names(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_by_names(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_partitions_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_partitions_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_partition_with_environment_context(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_partition_with_environment_context(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_rename_partition(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_rename_partition(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_partition_name_has_valid_characters(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_partition_name_has_valid_characters(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_config_value(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_config_value(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_partition_name_to_vals(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_partition_name_to_vals(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_partition_name_to_spec(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_partition_name_to_spec(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mark_partition_for_event(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_mark_partition_for_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_partition_marked_for_event(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_is_partition_marked_for_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_primary_keys(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_primary_keys(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_foreign_keys(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_foreign_keys(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_unique_constraints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_unique_constraints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_not_null_constraints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_not_null_constraints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_default_constraints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_default_constraints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_check_constraints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_check_constraints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_table_column_statistics(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_update_table_column_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_partition_column_statistics(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_update_partition_column_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_column_statistics(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_column_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partition_column_statistics(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partition_column_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_statistics_req(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_table_statistics_req(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_partitions_statistics_req(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_partitions_statistics_req(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_aggr_stats_for(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_aggr_stats_for(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_aggr_stats_for(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_set_aggr_stats_for(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_partition_column_statistics(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_delete_partition_column_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_table_column_statistics(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_delete_table_column_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_function(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_function(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_function(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_function(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_function(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_function(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_functions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_functions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_function(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_function(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_functions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_all_functions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_role_names(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_role_names(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_grant_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_grant_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_revoke_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_revoke_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_roles(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_list_roles(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_grant_revoke_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_grant_revoke_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_principals_in_role(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_principals_in_role(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_role_grants_for_principal(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_role_grants_for_principal(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_privilege_set(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_privilege_set(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_privileges(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_list_privileges(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_grant_privileges(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_grant_privileges(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_revoke_privileges(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_revoke_privileges(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_grant_revoke_privileges(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_grant_revoke_privileges(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_refresh_privileges(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_refresh_privileges(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_ugi(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_set_ugi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_delegation_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_delegation_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_renew_delegation_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_renew_delegation_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_delegation_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_cancel_delegation_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_remove_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_token(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_token_identifiers(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_all_token_identifiers(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_master_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_master_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_master_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_update_master_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_master_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_remove_master_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_master_keys(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_master_keys(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_open_txns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_open_txns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_open_txns_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_open_txns_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_open_txns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_open_txns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_abort_txn(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_abort_txn(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_abort_txns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_abort_txns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_commit_txn(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_commit_txn(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_repl_tbl_writeid_state(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_repl_tbl_writeid_state(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_valid_write_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_valid_write_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_allocate_table_write_ids(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_allocate_table_write_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lock(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_lock(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_lock(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_check_lock(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unlock(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_unlock(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_show_locks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_show_locks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_heartbeat(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_heartbeat(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_heartbeat_txn_range(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_heartbeat_txn_range(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_compact(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_compact(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_compact2(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_compact2(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_show_compact(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_show_compact(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_dynamic_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_dynamic_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_next_notification(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_next_notification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_current_notification_event_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_current_notification_event_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_notification_events_count(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_notification_events_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fire_listener_event(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_fire_listener_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_flush_cache(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_flush_cache(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cm_recycle(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_cm_recycle(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_file_metadata_by_expr(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_file_metadata_by_expr(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_file_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_file_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_put_file_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_put_file_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_clear_file_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_clear_file_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cache_file_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_cache_file_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_metastore_db_uuid(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_metastore_db_uuid(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_resource_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_resource_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_resource_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_resource_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_active_resource_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_all_resource_plans(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_all_resource_plans(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_resource_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_resource_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_validate_resource_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_validate_resource_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_resource_plan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_resource_plan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_wm_trigger(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_wm_trigger(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_wm_trigger(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_wm_trigger(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_wm_trigger(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_wm_trigger(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_triggers_for_resourceplan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_triggers_for_resourceplan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_wm_pool(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_wm_pool(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_wm_pool(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_wm_pool(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_wm_pool(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_wm_pool(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_or_update_wm_mapping(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_or_update_wm_mapping(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_wm_mapping(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_wm_mapping(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_or_drop_wm_trigger_to_pool_mapping(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_or_drop_wm_trigger_to_pool_mapping(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_ischema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_create_ischema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alter_ischema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_alter_ischema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_ischema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_ischema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_ischema(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_ischema(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_schema_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_schema_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schema_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_schema_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schema_latest_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_schema_latest_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schema_all_versions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_schema_all_versions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_schema_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_drop_schema_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_schemas_by_cols(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_schemas_by_cols(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_map_schema_version_to_serde(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_map_schema_version_to_serde(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_schema_version_state(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_set_schema_version_state(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_serde(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_serde(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_serde(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_serde(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_lock_materialization_rebuild(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_lock_materialization_rebuild(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_heartbeat_lock_materialization_rebuild(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_heartbeat_lock_materialization_rebuild(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_add_runtime_stats(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_add_runtime_stats(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_runtime_stats(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TThriftHiveMetastoreProcessFunctions::process_get_runtime_stats(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_name(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_version(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_status(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_status_details(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_status_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_counters(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_counters(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_counter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_counter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_option(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_set_option(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_option(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_option(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_options(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_options(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_cpu_profile(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_get_cpu_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alive_since(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_alive_since(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reinitialize(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_reinitialize(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shutdown(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    fb303::TFacebookServiceProcessFunctions::process_shutdown(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TThriftHiveMetastoreProcessFunctions;

impl TThriftHiveMetastoreProcessFunctions {
  pub fn process_get_meta_conf<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetMetaConfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_meta_conf(args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getMetaConf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetMetaConfResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetMetaConfResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("getMetaConf", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("getMetaConf", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getMetaConf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getMetaConf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_meta_conf<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreSetMetaConfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_meta_conf(args.key, args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("setMetaConf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreSetMetaConfResult { o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetMetaConfResult{ o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("setMetaConf", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("setMetaConf", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setMetaConf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setMetaConf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_catalog<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateCatalogArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_catalog(args.catalog) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateCatalogResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateCatalogResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateCatalogResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateCatalogResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_catalog<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterCatalogArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_catalog(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterCatalogResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterCatalogResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterCatalogResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterCatalogResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_catalog<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetCatalogArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_catalog(args.cat_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetCatalogResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetCatalogResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetCatalogResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_catalogs<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetCatalogsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_catalogs() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_catalogs", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetCatalogsResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetCatalogsResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_catalogs", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_catalogs", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_catalogs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_catalogs", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_catalog<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropCatalogArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_catalog(args.cat_name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropCatalogResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropCatalogResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropCatalogResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropCatalogResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_catalog", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_database<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_database(args.database) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateDatabaseResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateDatabaseResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("create_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateDatabaseResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("create_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateDatabaseResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_database<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_database(args.name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetDatabaseResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetDatabaseResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetDatabaseResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_database<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_database(args.name, args.delete_data, args.cascade) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropDatabaseResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropDatabaseResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropDatabaseResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropDatabaseResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_databases<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetDatabasesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_databases(args.pattern) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetDatabasesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetDatabasesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_databases<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetAllDatabasesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_databases() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_databases", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetAllDatabasesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetAllDatabasesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_databases", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_databases", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_databases", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_database<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterDatabaseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_database(args.dbname, args.db) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterDatabaseResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterDatabaseResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterDatabaseResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_database", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_type<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTypeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_type(args.name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_type", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTypeResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTypeResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTypeResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_type", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_type<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateTypeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_type(args.type_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_type", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateTypeResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTypeResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("create_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTypeResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("create_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTypeResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_type", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_type<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropTypeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_type(args.type_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropTypeResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropTypeResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropTypeResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_type_all<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTypeAllArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_type_all(args.name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_type_all", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTypeAllResult { result_value: Some(handler_return), o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTypeAllResult{ result_value: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_type_all", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_type_all", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_type_all", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_type_all", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_fields<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetFieldsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_fields(args.db_name, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetFieldsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFieldsResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownTableException>().is_some() {
              let err = usr_err.downcast::<UnknownTableException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFieldsResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFieldsResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_fields", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_fields_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_fields_with_environment_context(args.db_name, args.table_name, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownTableException>().is_some() {
              let err = usr_err.downcast::<UnknownTableException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_fields_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schema<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSchemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schema(args.db_name, args.table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSchemaResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownTableException>().is_some() {
              let err = usr_err.downcast::<UnknownTableException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_schema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schema_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schema_with_environment_context(args.db_name, args.table_name, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownTableException>().is_some() {
              let err = usr_err.downcast::<UnknownTableException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_schema_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_table<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_table(args.tbl) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateTableResult { o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableResult{ o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableResult{ o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableResult{ o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableResult{ o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_table_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_table_with_environment_context(args.tbl, args.environment_context) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult { o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult{ o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult{ o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult{ o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult{ o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_table_with_constraints<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateTableWithConstraintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_table_with_constraints(args.tbl, args.primary_keys, args.foreign_keys, args.unique_constraints, args.not_null_constraints, args.default_constraints, args.check_constraints) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateTableWithConstraintsResult { o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithConstraintsResult{ o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithConstraintsResult{ o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithConstraintsResult{ o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateTableWithConstraintsResult{ o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_table_with_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_constraint<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropConstraintArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_constraint(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropConstraintResult { o1: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropConstraintResult{ o1: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropConstraintResult{ o1: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_primary_key<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddPrimaryKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_primary_key(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddPrimaryKeyResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPrimaryKeyResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPrimaryKeyResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_primary_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_foreign_key<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddForeignKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_foreign_key(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddForeignKeyResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddForeignKeyResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddForeignKeyResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_foreign_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_unique_constraint<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddUniqueConstraintArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_unique_constraint(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddUniqueConstraintResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddUniqueConstraintResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddUniqueConstraintResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_unique_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_not_null_constraint<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddNotNullConstraintArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_not_null_constraint(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddNotNullConstraintResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddNotNullConstraintResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddNotNullConstraintResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_not_null_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_default_constraint<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddDefaultConstraintArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_default_constraint(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddDefaultConstraintResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddDefaultConstraintResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddDefaultConstraintResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_default_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_check_constraint<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddCheckConstraintArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_check_constraint(args.req) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddCheckConstraintResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddCheckConstraintResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddCheckConstraintResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_check_constraint", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_table<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_table(args.dbname, args.name, args.delete_data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropTableResult { o1: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropTableResult{ o1: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropTableResult{ o1: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_table_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropTableWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_table_with_environment_context(args.dbname, args.name, args.delete_data, args.environment_context) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropTableWithEnvironmentContextResult { o1: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropTableWithEnvironmentContextResult{ o1: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropTableWithEnvironmentContextResult{ o1: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_truncate_table<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreTruncateTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_truncate_table(args.db_name, args.table_name, args.part_names) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("truncate_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreTruncateTableResult { o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreTruncateTableResult{ o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("truncate_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("truncate_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("truncate_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("truncate_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables(args.db_name, args.pattern) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTablesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTablesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_tables_by_type<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTablesByTypeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_tables_by_type(args.db_name, args.pattern, args.table_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_tables_by_type", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTablesByTypeResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTablesByTypeResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_tables_by_type", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_tables_by_type", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_tables_by_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_tables_by_type", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_materialized_views_for_rewriting<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_materialized_views_for_rewriting(args.db_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_materialized_views_for_rewriting", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetMaterializedViewsForRewritingResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetMaterializedViewsForRewritingResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_materialized_views_for_rewriting", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_materialized_views_for_rewriting", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_materialized_views_for_rewriting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_materialized_views_for_rewriting", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_meta<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableMetaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_meta(args.db_patterns, args.tbl_patterns, args.tbl_types) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_meta", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableMetaResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableMetaResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_meta", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_meta", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_meta", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_tables<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetAllTablesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_tables(args.db_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_tables", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetAllTablesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetAllTablesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_tables", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_tables", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_tables", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table(args.dbname, args.tbl_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_objects_by_name<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableObjectsByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_objects_by_name(args.dbname, args.tbl_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_objects_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableObjectsByNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_objects_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_objects_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_req<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableReqArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_req(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableReqResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableReqResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableReqResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_objects_by_name_req<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableObjectsByNameReqArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_objects_by_name_req(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableObjectsByNameReqResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableObjectsByNameReqResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableObjectsByNameReqResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableObjectsByNameReqResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_objects_by_name_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_materialization_invalidation_info<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_materialization_invalidation_info(args.creation_metadata, args.valid_txn_list) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetMaterializationInvalidationInfoResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetMaterializationInvalidationInfoResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetMaterializationInvalidationInfoResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetMaterializationInvalidationInfoResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_materialization_invalidation_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_creation_metadata<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreUpdateCreationMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_creation_metadata(args.cat_name, args.dbname, args.tbl_name, args.creation_metadata) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreUpdateCreationMetadataResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateCreationMetadataResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateCreationMetadataResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateCreationMetadataResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_creation_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_names_by_filter<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableNamesByFilterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_names_by_filter(args.dbname, args.filter, args.max_tables) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableNamesByFilterResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableNamesByFilterResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableNamesByFilterResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableNamesByFilterResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_names_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_table<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterTableArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_table(args.dbname, args.tbl_name, args.new_tbl) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterTableResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterTableResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterTableResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_table", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_table_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterTableWithEnvironmentContextResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterTableWithEnvironmentContextResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterTableWithEnvironmentContextResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_table_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_table_with_cascade<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterTableWithCascadeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_table_with_cascade(args.dbname, args.tbl_name, args.new_tbl, args.cascade) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterTableWithCascadeResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterTableWithCascadeResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterTableWithCascadeResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_table_with_cascade", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddPartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_partition(args.new_part) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddPartitionResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_partition_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_partition_with_environment_context(args.new_part, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_partitions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddPartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_partitions(args.new_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddPartitionsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_partitions_pspec<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddPartitionsPspecArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_partitions_pspec(args.new_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddPartitionsPspecResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsPspecResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsPspecResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsPspecResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_partitions_pspec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_append_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAppendPartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_append_partition(args.db_name, args.tbl_name, args.part_vals) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAppendPartitionResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("append_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_partitions_req<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddPartitionsReqArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_partitions_req(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddPartitionsReqResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsReqResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsReqResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddPartitionsReqResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_partitions_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_append_partition_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_append_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("append_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_append_partition_by_name<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAppendPartitionByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_append_partition_by_name(args.db_name, args.tbl_name, args.part_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAppendPartitionByNameResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionByNameResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionByNameResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionByNameResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("append_partition_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_append_partition_by_name_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_append_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("append_partition_by_name_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropPartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_partition(args.db_name, args.tbl_name, args.part_vals, args.delete_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropPartitionResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_partition_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.delete_data, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_partition_by_name<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropPartitionByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.delete_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropPartitionByNameResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionByNameResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionByNameResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_partition_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_partition_by_name_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.delete_data, args.environment_context) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_partition_by_name_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_partitions_req<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropPartitionsReqArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_partitions_req(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropPartitionsReqResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionsReqResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropPartitionsReqResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_partitions_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition(args.db_name, args.tbl_name, args.part_vals) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_exchange_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreExchangePartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_exchange_partition(args.partition_specs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreExchangePartitionResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("exchange_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_exchange_partitions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreExchangePartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_exchange_partitions(args.partition_specs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreExchangePartitionsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreExchangePartitionsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("exchange_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition_with_auth<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionWithAuthArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionWithAuthResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionWithAuthResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionWithAuthResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition_with_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition_by_name<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionByNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition_by_name(args.db_name, args.tbl_name, args.part_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionByNameResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionByNameResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionByNameResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition_by_name", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions(args.db_name, args.tbl_name, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_with_auth<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsWithAuthArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsWithAuthResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsWithAuthResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsWithAuthResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_with_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_pspec<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsPspecArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_pspec(args.db_name, args.tbl_name, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsPspecResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsPspecResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsPspecResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_pspec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition_names<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionNamesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition_names(args.db_name, args.tbl_name, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionNamesResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionNamesResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionNamesResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition_values<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionValuesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition_values(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionValuesResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionValuesResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionValuesResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition_values", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_ps<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsPsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsPsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsPsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsPsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_ps", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_ps_with_auth<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsPsWithAuthArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsPsWithAuthResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsPsWithAuthResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsPsWithAuthResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_ps_with_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition_names_ps<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionNamesPsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionNamesPsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionNamesPsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionNamesPsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition_names_ps", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_by_filter<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsByFilterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsByFilterResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsByFilterResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsByFilterResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_part_specs_by_filter<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartSpecsByFilterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_part_specs_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartSpecsByFilterResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartSpecsByFilterResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartSpecsByFilterResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_part_specs_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_by_expr<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsByExprArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_by_expr(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsByExprResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsByExprResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsByExprResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_by_expr", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_num_partitions_by_filter<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetNumPartitionsByFilterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_num_partitions_by_filter(args.db_name, args.tbl_name, args.filter) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetNumPartitionsByFilterResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetNumPartitionsByFilterResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetNumPartitionsByFilterResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_num_partitions_by_filter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_by_names<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsByNamesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_by_names(args.db_name, args.tbl_name, args.names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsByNamesResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsByNamesResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsByNamesResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_by_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterPartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_partition(args.db_name, args.tbl_name, args.new_part) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterPartitionResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_partitions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterPartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_partitions(args.db_name, args.tbl_name, args.new_parts) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterPartitionsResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionsResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionsResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_partitions_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_partitions_with_environment_context(args.db_name, args.tbl_name, args.new_parts, args.environment_context) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_partitions_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_partition_with_environment_context<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_partition_with_environment_context(args.db_name, args.tbl_name, args.new_part, args.environment_context) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_partition_with_environment_context", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_rename_partition<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRenamePartitionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRenamePartitionResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreRenamePartitionResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreRenamePartitionResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("rename_partition", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_partition_name_has_valid_characters<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastorePartitionNameHasValidCharactersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_partition_name_has_valid_characters(args.part_vals, args.throw_exception) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("partition_name_has_valid_characters", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastorePartitionNameHasValidCharactersResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastorePartitionNameHasValidCharactersResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("partition_name_has_valid_characters", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("partition_name_has_valid_characters", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("partition_name_has_valid_characters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("partition_name_has_valid_characters", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_config_value<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetConfigValueArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_config_value(args.name, args.default_value) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_config_value", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetConfigValueResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<ConfigValSecurityException>().is_some() {
              let err = usr_err.downcast::<ConfigValSecurityException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetConfigValueResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_config_value", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_config_value", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_config_value", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_config_value", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_partition_name_to_vals<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastorePartitionNameToValsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_partition_name_to_vals(args.part_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("partition_name_to_vals", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastorePartitionNameToValsResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastorePartitionNameToValsResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("partition_name_to_vals", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("partition_name_to_vals", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("partition_name_to_vals", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("partition_name_to_vals", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_partition_name_to_spec<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastorePartitionNameToSpecArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_partition_name_to_spec(args.part_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("partition_name_to_spec", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastorePartitionNameToSpecResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastorePartitionNameToSpecResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("partition_name_to_spec", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("partition_name_to_spec", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("partition_name_to_spec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("partition_name_to_spec", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mark_partition_for_event<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreMarkPartitionForEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mark_partition_for_event(args.db_name, args.tbl_name, args.part_vals, args.event_type) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreMarkPartitionForEventResult { o1: None, o2: None, o3: None, o4: None, o5: None, o6: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMarkPartitionForEventResult{ o1: Some(*err), o2: None, o3: None, o4: None, o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMarkPartitionForEventResult{ o1: None, o2: Some(*err), o3: None, o4: None, o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMarkPartitionForEventResult{ o1: None, o2: None, o3: Some(*err), o4: None, o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownTableException>().is_some() {
              let err = usr_err.downcast::<UnknownTableException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMarkPartitionForEventResult{ o1: None, o2: None, o3: None, o4: Some(*err), o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownPartitionException>().is_some() {
              let err = usr_err.downcast::<UnknownPartitionException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMarkPartitionForEventResult{ o1: None, o2: None, o3: None, o4: None, o5: Some(*err), o6: None };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidPartitionException>().is_some() {
              let err = usr_err.downcast::<InvalidPartitionException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMarkPartitionForEventResult{ o1: None, o2: None, o3: None, o4: None, o5: None, o6: Some(*err) };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("markPartitionForEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_partition_marked_for_event<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreIsPartitionMarkedForEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_partition_marked_for_event(args.db_name, args.tbl_name, args.part_vals, args.event_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreIsPartitionMarkedForEventResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None, o5: None, o6: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreIsPartitionMarkedForEventResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None, o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreIsPartitionMarkedForEventResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None, o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownDBException>().is_some() {
              let err = usr_err.downcast::<UnknownDBException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreIsPartitionMarkedForEventResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None, o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownTableException>().is_some() {
              let err = usr_err.downcast::<UnknownTableException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreIsPartitionMarkedForEventResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err), o5: None, o6: None };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<UnknownPartitionException>().is_some() {
              let err = usr_err.downcast::<UnknownPartitionException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreIsPartitionMarkedForEventResult{ result_value: None, o1: None, o2: None, o3: None, o4: None, o5: Some(*err), o6: None };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidPartitionException>().is_some() {
              let err = usr_err.downcast::<InvalidPartitionException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreIsPartitionMarkedForEventResult{ result_value: None, o1: None, o2: None, o3: None, o4: None, o5: None, o6: Some(*err) };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("isPartitionMarkedForEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_primary_keys<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPrimaryKeysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_primary_keys(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPrimaryKeysResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPrimaryKeysResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPrimaryKeysResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_primary_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_foreign_keys<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetForeignKeysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_foreign_keys(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetForeignKeysResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetForeignKeysResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetForeignKeysResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_foreign_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_unique_constraints<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetUniqueConstraintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_unique_constraints(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetUniqueConstraintsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetUniqueConstraintsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetUniqueConstraintsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_unique_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_not_null_constraints<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetNotNullConstraintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_not_null_constraints(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetNotNullConstraintsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetNotNullConstraintsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetNotNullConstraintsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_not_null_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_default_constraints<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetDefaultConstraintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_default_constraints(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetDefaultConstraintsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetDefaultConstraintsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetDefaultConstraintsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_default_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_check_constraints<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetCheckConstraintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_check_constraints(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetCheckConstraintsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetCheckConstraintsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetCheckConstraintsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_check_constraints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_table_column_statistics<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreUpdateTableColumnStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_table_column_statistics(args.stats_obj) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreUpdateTableColumnStatisticsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateTableColumnStatisticsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateTableColumnStatisticsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateTableColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateTableColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_partition_column_statistics<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_partition_column_statistics(args.stats_obj) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_column_statistics<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableColumnStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_column_statistics(args.db_name, args.tbl_name, args.col_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableColumnStatisticsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableColumnStatisticsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableColumnStatisticsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partition_column_statistics<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionColumnStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionColumnStatisticsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionColumnStatisticsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionColumnStatisticsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_statistics_req<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTableStatisticsReqArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_statistics_req(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTableStatisticsReqResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableStatisticsReqResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTableStatisticsReqResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_statistics_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_partitions_statistics_req<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPartitionsStatisticsReqArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_partitions_statistics_req(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPartitionsStatisticsReqResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsStatisticsReqResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPartitionsStatisticsReqResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_partitions_statistics_req", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_aggr_stats_for<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetAggrStatsForArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_aggr_stats_for(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetAggrStatsForResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetAggrStatsForResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetAggrStatsForResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_aggr_stats_for", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_aggr_stats_for<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreSetAggrStatsForArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_aggr_stats_for(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreSetAggrStatsForResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetAggrStatsForResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetAggrStatsForResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetAggrStatsForResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetAggrStatsForResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_aggr_stats_for", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_partition_column_statistics<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_partition_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_table_column_statistics<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDeleteTableColumnStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDeleteTableColumnStatisticsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeleteTableColumnStatisticsResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeleteTableColumnStatisticsResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeleteTableColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidInputException>().is_some() {
              let err = usr_err.downcast::<InvalidInputException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDeleteTableColumnStatisticsResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("delete_table_column_statistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_function<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateFunctionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_function(args.func) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_function", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateFunctionResult { o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateFunctionResult{ o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateFunctionResult{ o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateFunctionResult{ o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateFunctionResult{ o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_function", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_function<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropFunctionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_function(args.db_name, args.func_name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropFunctionResult { o1: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropFunctionResult{ o1: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropFunctionResult{ o1: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_function<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterFunctionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_function(args.db_name, args.func_name, args.new_func) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterFunctionResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterFunctionResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterFunctionResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_functions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetFunctionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_functions(args.db_name, args.pattern) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_functions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetFunctionsResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFunctionsResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_functions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_functions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_function<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetFunctionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_function(args.db_name, args.func_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_function", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetFunctionResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFunctionResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetFunctionResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_function", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_function", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_function", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_functions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetAllFunctionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_functions() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_functions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetAllFunctionsResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetAllFunctionsResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_functions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_functions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_functions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_role<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_role(args.role) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateRoleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateRoleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_role<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_role(args.role_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropRoleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropRoleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_role_names<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetRoleNamesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_role_names() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_role_names", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetRoleNamesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetRoleNamesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_role_names", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_role_names", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_role_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_role_names", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_grant_role<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGrantRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantor_type, args.grant_option) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("grant_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGrantRoleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGrantRoleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("grant_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("grant_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("grant_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("grant_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_revoke_role<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRevokeRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_revoke_role(args.role_name, args.principal_name, args.principal_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("revoke_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRevokeRoleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreRevokeRoleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("revoke_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("revoke_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("revoke_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("revoke_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_roles<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreListRolesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_roles(args.principal_name, args.principal_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("list_roles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreListRolesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreListRolesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("list_roles", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("list_roles", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("list_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("list_roles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_grant_revoke_role<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGrantRevokeRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_grant_revoke_role(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("grant_revoke_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGrantRevokeRoleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGrantRevokeRoleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("grant_revoke_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("grant_revoke_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("grant_revoke_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("grant_revoke_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_principals_in_role<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPrincipalsInRoleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_principals_in_role(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_principals_in_role", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPrincipalsInRoleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPrincipalsInRoleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_principals_in_role", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_principals_in_role", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_principals_in_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_principals_in_role", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_role_grants_for_principal<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_role_grants_for_principal(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_role_grants_for_principal", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetRoleGrantsForPrincipalResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetRoleGrantsForPrincipalResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_role_grants_for_principal", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_role_grants_for_principal", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_role_grants_for_principal", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_role_grants_for_principal", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_privilege_set<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetPrivilegeSetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_privilege_set(args.hive_object, args.user_name, args.group_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_privilege_set", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetPrivilegeSetResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetPrivilegeSetResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_privilege_set", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_privilege_set", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_privilege_set", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_privilege_set", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_privileges<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreListPrivilegesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_privileges(args.principal_name, args.principal_type, args.hive_object) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("list_privileges", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreListPrivilegesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreListPrivilegesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("list_privileges", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("list_privileges", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("list_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("list_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_grant_privileges<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGrantPrivilegesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_grant_privileges(args.privileges) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("grant_privileges", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGrantPrivilegesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGrantPrivilegesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("grant_privileges", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("grant_privileges", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("grant_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("grant_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_revoke_privileges<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRevokePrivilegesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_revoke_privileges(args.privileges) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("revoke_privileges", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRevokePrivilegesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreRevokePrivilegesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("revoke_privileges", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("revoke_privileges", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("revoke_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("revoke_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_grant_revoke_privileges<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGrantRevokePrivilegesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_grant_revoke_privileges(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("grant_revoke_privileges", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGrantRevokePrivilegesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGrantRevokePrivilegesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("grant_revoke_privileges", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("grant_revoke_privileges", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("grant_revoke_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("grant_revoke_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_refresh_privileges<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRefreshPrivilegesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_refresh_privileges(args.obj_to_refresh, args.authorizer, args.grant_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("refresh_privileges", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRefreshPrivilegesResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreRefreshPrivilegesResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("refresh_privileges", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("refresh_privileges", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("refresh_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("refresh_privileges", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_ugi<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreSetUgiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_ugi(args.user_name, args.group_names) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_ugi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreSetUgiResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetUgiResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_ugi", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_ugi", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_ugi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_ugi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_delegation_token<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetDelegationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_delegation_token", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetDelegationTokenResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetDelegationTokenResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_delegation_token", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_delegation_token", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_delegation_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_delegation_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_renew_delegation_token<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRenewDelegationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_renew_delegation_token(args.token_str_form) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("renew_delegation_token", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRenewDelegationTokenResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreRenewDelegationTokenResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("renew_delegation_token", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("renew_delegation_token", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("renew_delegation_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("renew_delegation_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_delegation_token<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCancelDelegationTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_delegation_token(args.token_str_form) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("cancel_delegation_token", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCancelDelegationTokenResult { o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCancelDelegationTokenResult{ o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("cancel_delegation_token", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("cancel_delegation_token", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cancel_delegation_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("cancel_delegation_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_token<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_token(args.token_identifier, args.delegation_token) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_token", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_token<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRemoveTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_token(args.token_identifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("remove_token", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRemoveTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("remove_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("remove_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_token<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_token(args.token_identifier) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_token", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_token", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_token_identifiers<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetAllTokenIdentifiersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_token_identifiers() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_token_identifiers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetAllTokenIdentifiersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_token_identifiers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_token_identifiers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_master_key<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddMasterKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_master_key(args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("add_master_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddMasterKeyResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddMasterKeyResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_master_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_master_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_master_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_master_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_master_key<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreUpdateMasterKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_master_key(args.seq_number, args.key) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreUpdateMasterKeyResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateMasterKeyResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUpdateMasterKeyResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_master_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_master_key<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreRemoveMasterKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_master_key(args.key_seq) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("remove_master_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreRemoveMasterKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("remove_master_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("remove_master_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_master_keys<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetMasterKeysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_master_keys() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_master_keys", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetMasterKeysResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_master_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_master_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_open_txns<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetOpenTxnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_open_txns() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_open_txns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetOpenTxnsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_open_txns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_open_txns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_open_txns_info<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetOpenTxnsInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_open_txns_info() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_open_txns_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetOpenTxnsInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_open_txns_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_open_txns_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_open_txns<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreOpenTxnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_open_txns(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("open_txns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreOpenTxnsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("open_txns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("open_txns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_abort_txn<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAbortTxnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_abort_txn(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("abort_txn", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAbortTxnResult { o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAbortTxnResult{ o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("abort_txn", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("abort_txn", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("abort_txn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("abort_txn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_abort_txns<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAbortTxnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_abort_txns(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("abort_txns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAbortTxnsResult { o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAbortTxnsResult{ o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("abort_txns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("abort_txns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("abort_txns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("abort_txns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_commit_txn<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCommitTxnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_commit_txn(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCommitTxnResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCommitTxnResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnAbortedException>().is_some() {
              let err = usr_err.downcast::<TxnAbortedException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCommitTxnResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("commit_txn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_repl_tbl_writeid_state<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreReplTblWriteidStateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_repl_tbl_writeid_state(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("repl_tbl_writeid_state", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreReplTblWriteidStateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("repl_tbl_writeid_state", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("repl_tbl_writeid_state", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_valid_write_ids<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetValidWriteIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_valid_write_ids(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetValidWriteIdsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetValidWriteIdsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetValidWriteIdsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_valid_write_ids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_allocate_table_write_ids<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAllocateTableWriteIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_allocate_table_write_ids(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAllocateTableWriteIdsResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAllocateTableWriteIdsResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnAbortedException>().is_some() {
              let err = usr_err.downcast::<TxnAbortedException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAllocateTableWriteIdsResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAllocateTableWriteIdsResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("allocate_table_write_ids", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lock<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreLockArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lock(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("lock", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreLockResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreLockResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("lock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnAbortedException>().is_some() {
              let err = usr_err.downcast::<TxnAbortedException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreLockResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("lock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("lock", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("lock", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("lock", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_lock<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCheckLockArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_lock(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCheckLockResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCheckLockResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnAbortedException>().is_some() {
              let err = usr_err.downcast::<TxnAbortedException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCheckLockResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchLockException>().is_some() {
              let err = usr_err.downcast::<NoSuchLockException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCheckLockResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("check_lock", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unlock<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreUnlockArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unlock(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("unlock", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreUnlockResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchLockException>().is_some() {
              let err = usr_err.downcast::<NoSuchLockException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUnlockResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("unlock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnOpenException>().is_some() {
              let err = usr_err.downcast::<TxnOpenException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreUnlockResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("unlock", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("unlock", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unlock", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unlock", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_show_locks<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreShowLocksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_show_locks(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("show_locks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreShowLocksResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("show_locks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("show_locks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_heartbeat<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreHeartbeatArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_heartbeat(args.ids) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreHeartbeatResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchLockException>().is_some() {
              let err = usr_err.downcast::<NoSuchLockException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreHeartbeatResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreHeartbeatResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnAbortedException>().is_some() {
              let err = usr_err.downcast::<TxnAbortedException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreHeartbeatResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("heartbeat", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_heartbeat_txn_range<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreHeartbeatTxnRangeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_heartbeat_txn_range(args.txns) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("heartbeat_txn_range", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreHeartbeatTxnRangeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("heartbeat_txn_range", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("heartbeat_txn_range", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_compact<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCompactArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_compact(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("compact", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCompactResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("compact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("compact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_compact2<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCompact2Args::read_from_in_protocol(i_prot)?;
    match handler.handle_compact2(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("compact2", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCompact2Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("compact2", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("compact2", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_show_compact<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreShowCompactArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_show_compact(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("show_compact", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreShowCompactResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("show_compact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("show_compact", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_dynamic_partitions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddDynamicPartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_dynamic_partitions(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddDynamicPartitionsResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchTxnException>().is_some() {
              let err = usr_err.downcast::<NoSuchTxnException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddDynamicPartitionsResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<TxnAbortedException>().is_some() {
              let err = usr_err.downcast::<TxnAbortedException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddDynamicPartitionsResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_dynamic_partitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_next_notification<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetNextNotificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_next_notification(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_next_notification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetNextNotificationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_next_notification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_next_notification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_current_notification_event_id<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetCurrentNotificationEventIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_current_notification_event_id() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_current_notificationEventId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetCurrentNotificationEventIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_current_notificationEventId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_current_notificationEventId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_notification_events_count<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetNotificationEventsCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_notification_events_count(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_notification_events_count", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetNotificationEventsCountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_notification_events_count", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_notification_events_count", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fire_listener_event<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreFireListenerEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fire_listener_event(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fire_listener_event", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreFireListenerEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fire_listener_event", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("fire_listener_event", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_flush_cache<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreFlushCacheArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_flush_cache() {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("flushCache", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreFlushCacheResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("flushCache", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("flushCache", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cm_recycle<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCmRecycleArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cm_recycle(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("cm_recycle", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCmRecycleResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCmRecycleResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("cm_recycle", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("cm_recycle", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cm_recycle", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("cm_recycle", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_file_metadata_by_expr<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetFileMetadataByExprArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_file_metadata_by_expr(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_file_metadata_by_expr", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetFileMetadataByExprResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_file_metadata_by_expr", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_file_metadata_by_expr", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_file_metadata<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetFileMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_file_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_file_metadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetFileMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_put_file_metadata<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastorePutFileMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_put_file_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("put_file_metadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastorePutFileMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("put_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("put_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_clear_file_metadata<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreClearFileMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_clear_file_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("clear_file_metadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreClearFileMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("clear_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("clear_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cache_file_metadata<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCacheFileMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cache_file_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("cache_file_metadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCacheFileMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cache_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("cache_file_metadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_metastore_db_uuid<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ThriftHiveMetastoreGetMetastoreDbUuidArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_metastore_db_uuid() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_metastore_db_uuid", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetMetastoreDbUuidResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetMetastoreDbUuidResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_metastore_db_uuid", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_metastore_db_uuid", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_metastore_db_uuid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_metastore_db_uuid", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_resource_plan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateResourcePlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_resource_plan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateResourcePlanResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateResourcePlanResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateResourcePlanResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateResourcePlanResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_plan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetResourcePlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_plan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetResourcePlanResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetResourcePlanResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetResourcePlanResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_resource_plan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetActiveResourcePlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_resource_plan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_active_resource_plan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetActiveResourcePlanResult { result_value: Some(handler_return), o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetActiveResourcePlanResult{ result_value: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_active_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_active_resource_plan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_active_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_active_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_all_resource_plans<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetAllResourcePlansArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_all_resource_plans(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_all_resource_plans", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetAllResourcePlansResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetAllResourcePlansResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_all_resource_plans", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_all_resource_plans", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_all_resource_plans", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_all_resource_plans", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_resource_plan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterResourcePlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_resource_plan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterResourcePlanResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterResourcePlanResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterResourcePlanResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterResourcePlanResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_validate_resource_plan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreValidateResourcePlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_validate_resource_plan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreValidateResourcePlanResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreValidateResourcePlanResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreValidateResourcePlanResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("validate_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_resource_plan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropResourcePlanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_resource_plan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropResourcePlanResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropResourcePlanResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropResourcePlanResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropResourcePlanResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_resource_plan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_wm_trigger<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateWmTriggerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_wm_trigger(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateWmTriggerResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmTriggerResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmTriggerResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmTriggerResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmTriggerResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_wm_trigger", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_wm_trigger<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterWmTriggerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_wm_trigger(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterWmTriggerResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmTriggerResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmTriggerResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmTriggerResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_wm_trigger", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_wm_trigger<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropWmTriggerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_wm_trigger(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropWmTriggerResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmTriggerResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmTriggerResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmTriggerResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_wm_trigger", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_triggers_for_resourceplan<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetTriggersForResourceplanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_triggers_for_resourceplan(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetTriggersForResourceplanResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTriggersForResourceplanResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetTriggersForResourceplanResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_triggers_for_resourceplan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_wm_pool<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateWmPoolArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_wm_pool(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateWmPoolResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmPoolResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmPoolResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmPoolResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateWmPoolResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_wm_pool", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_wm_pool<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterWmPoolArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_wm_pool(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterWmPoolResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmPoolResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmPoolResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmPoolResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterWmPoolResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_wm_pool", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_wm_pool<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropWmPoolArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_wm_pool(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropWmPoolResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmPoolResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmPoolResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmPoolResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_wm_pool", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_or_update_wm_mapping<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateOrUpdateWmMappingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_or_update_wm_mapping(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateOrUpdateWmMappingResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrUpdateWmMappingResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrUpdateWmMappingResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrUpdateWmMappingResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrUpdateWmMappingResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_or_update_wm_mapping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_wm_mapping<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropWmMappingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_wm_mapping(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropWmMappingResult { result_value: Some(handler_return), o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmMappingResult{ result_value: None, o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmMappingResult{ result_value: None, o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropWmMappingResult{ result_value: None, o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_wm_mapping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_or_drop_wm_trigger_to_pool_mapping<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_or_drop_wm_trigger_to_pool_mapping(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult { result_value: Some(handler_return), o1: None, o2: None, o3: None, o4: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult{ result_value: None, o1: Some(*err), o2: None, o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult{ result_value: None, o1: None, o2: Some(*err), o3: None, o4: None };
              let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidObjectException>().is_some() {
              let err = usr_err.downcast::<InvalidObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult{ result_value: None, o1: None, o2: None, o3: Some(*err), o4: None };
              let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult{ result_value: None, o1: None, o2: None, o3: None, o4: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_ischema<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreCreateIschemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_ischema(args.schema) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreCreateIschemaResult { o2: None, o1: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateIschemaResult{ o2: Some(*err), o1: None, o3: None };
              let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateIschemaResult{ o2: None, o1: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreCreateIschemaResult{ o2: None, o1: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alter_ischema<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAlterIschemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alter_ischema(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAlterIschemaResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterIschemaResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAlterIschemaResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alter_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_ischema<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetIschemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_ischema(args.name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetIschemaResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetIschemaResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetIschemaResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_ischema<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropIschemaArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_ischema(args.name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropIschemaResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropIschemaResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropIschemaResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropIschemaResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_ischema", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_schema_version<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddSchemaVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_schema_version(args.schema_version) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddSchemaVersionResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddSchemaVersionResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddSchemaVersionResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddSchemaVersionResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_schema_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schema_version<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSchemaVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schema_version(args.schema_version) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSchemaVersionResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaVersionResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaVersionResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_schema_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schema_latest_version<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSchemaLatestVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schema_latest_version(args.schema_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSchemaLatestVersionResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaLatestVersionResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaLatestVersionResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_schema_latest_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schema_all_versions<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSchemaAllVersionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schema_all_versions(args.schema_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSchemaAllVersionsResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaAllVersionsResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemaAllVersionsResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_schema_all_versions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_schema_version<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreDropSchemaVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_schema_version(args.schema_version) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreDropSchemaVersionResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropSchemaVersionResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreDropSchemaVersionResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("drop_schema_version", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_schemas_by_cols<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSchemasByColsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_schemas_by_cols(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_schemas_by_cols", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSchemasByColsResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSchemasByColsResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_schemas_by_cols", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_schemas_by_cols", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_schemas_by_cols", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_schemas_by_cols", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_map_schema_version_to_serde<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreMapSchemaVersionToSerdeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_map_schema_version_to_serde(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreMapSchemaVersionToSerdeResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMapSchemaVersionToSerdeResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreMapSchemaVersionToSerdeResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("map_schema_version_to_serde", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_schema_version_state<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreSetSchemaVersionStateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_schema_version_state(args.rqst) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreSetSchemaVersionStateResult { o1: None, o2: None, o3: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetSchemaVersionStateResult{ o1: Some(*err), o2: None, o3: None };
              let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<InvalidOperationException>().is_some() {
              let err = usr_err.downcast::<InvalidOperationException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetSchemaVersionStateResult{ o1: None, o2: Some(*err), o3: None };
              let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreSetSchemaVersionStateResult{ o1: None, o2: None, o3: Some(*err) };
              let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_schema_version_state", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_serde<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddSerdeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_serde(args.serde) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddSerdeResult { o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<AlreadyExistsException>().is_some() {
              let err = usr_err.downcast::<AlreadyExistsException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddSerdeResult{ o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddSerdeResult{ o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_serde", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_serde<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetSerdeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_serde(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetSerdeResult { result_value: Some(handler_return), o1: None, o2: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<NoSuchObjectException>().is_some() {
              let err = usr_err.downcast::<NoSuchObjectException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSerdeResult{ result_value: None, o1: Some(*err), o2: None };
              let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetSerdeResult{ result_value: None, o1: None, o2: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_serde", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_lock_materialization_rebuild<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetLockMaterializationRebuildArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_lock_materialization_rebuild(args.db_name, args.table_name, args.txn_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_lock_materialization_rebuild", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetLockMaterializationRebuildResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_lock_materialization_rebuild", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_lock_materialization_rebuild", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_heartbeat_lock_materialization_rebuild<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_heartbeat_lock_materialization_rebuild(args.db_name, args.table_name, args.txn_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("heartbeat_lock_materialization_rebuild", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("heartbeat_lock_materialization_rebuild", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("heartbeat_lock_materialization_rebuild", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_add_runtime_stats<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreAddRuntimeStatsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_add_runtime_stats(args.stat) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("add_runtime_stats", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreAddRuntimeStatsResult { o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreAddRuntimeStatsResult{ o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("add_runtime_stats", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("add_runtime_stats", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("add_runtime_stats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("add_runtime_stats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_runtime_stats<H: ThriftHiveMetastoreSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ThriftHiveMetastoreGetRuntimeStatsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_runtime_stats(args.rqst) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_runtime_stats", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ThriftHiveMetastoreGetRuntimeStatsResult { result_value: Some(handler_return), o1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<MetaException>().is_some() {
              let err = usr_err.downcast::<MetaException>().expect("downcast already checked");
              let ret_err = ThriftHiveMetastoreGetRuntimeStatsResult{ result_value: None, o1: Some(*err) };
              let message_ident = TMessageIdentifier::new("get_runtime_stats", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("get_runtime_stats", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_runtime_stats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_runtime_stats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ThriftHiveMetastoreSyncHandler> TProcessor for ThriftHiveMetastoreSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "getMetaConf" => {
        self.process_get_meta_conf(message_ident.sequence_number, i_prot, o_prot)
      },
      "setMetaConf" => {
        self.process_set_meta_conf(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_catalog" => {
        self.process_create_catalog(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_catalog" => {
        self.process_alter_catalog(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_catalog" => {
        self.process_get_catalog(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_catalogs" => {
        self.process_get_catalogs(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_catalog" => {
        self.process_drop_catalog(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_database" => {
        self.process_create_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_database" => {
        self.process_get_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_database" => {
        self.process_drop_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_databases" => {
        self.process_get_databases(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_databases" => {
        self.process_get_all_databases(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_database" => {
        self.process_alter_database(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_type" => {
        self.process_get_type(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_type" => {
        self.process_create_type(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_type" => {
        self.process_drop_type(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_type_all" => {
        self.process_get_type_all(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_fields" => {
        self.process_get_fields(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_fields_with_environment_context" => {
        self.process_get_fields_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_schema" => {
        self.process_get_schema(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_schema_with_environment_context" => {
        self.process_get_schema_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_table" => {
        self.process_create_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_table_with_environment_context" => {
        self.process_create_table_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_table_with_constraints" => {
        self.process_create_table_with_constraints(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_constraint" => {
        self.process_drop_constraint(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_primary_key" => {
        self.process_add_primary_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_foreign_key" => {
        self.process_add_foreign_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_unique_constraint" => {
        self.process_add_unique_constraint(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_not_null_constraint" => {
        self.process_add_not_null_constraint(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_default_constraint" => {
        self.process_add_default_constraint(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_check_constraint" => {
        self.process_add_check_constraint(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_table" => {
        self.process_drop_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_table_with_environment_context" => {
        self.process_drop_table_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "truncate_table" => {
        self.process_truncate_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables" => {
        self.process_get_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_tables_by_type" => {
        self.process_get_tables_by_type(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_materialized_views_for_rewriting" => {
        self.process_get_materialized_views_for_rewriting(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_meta" => {
        self.process_get_table_meta(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_tables" => {
        self.process_get_all_tables(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table" => {
        self.process_get_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_objects_by_name" => {
        self.process_get_table_objects_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_req" => {
        self.process_get_table_req(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_objects_by_name_req" => {
        self.process_get_table_objects_by_name_req(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_materialization_invalidation_info" => {
        self.process_get_materialization_invalidation_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_creation_metadata" => {
        self.process_update_creation_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_names_by_filter" => {
        self.process_get_table_names_by_filter(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_table" => {
        self.process_alter_table(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_table_with_environment_context" => {
        self.process_alter_table_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_table_with_cascade" => {
        self.process_alter_table_with_cascade(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_partition" => {
        self.process_add_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_partition_with_environment_context" => {
        self.process_add_partition_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_partitions" => {
        self.process_add_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_partitions_pspec" => {
        self.process_add_partitions_pspec(message_ident.sequence_number, i_prot, o_prot)
      },
      "append_partition" => {
        self.process_append_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_partitions_req" => {
        self.process_add_partitions_req(message_ident.sequence_number, i_prot, o_prot)
      },
      "append_partition_with_environment_context" => {
        self.process_append_partition_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "append_partition_by_name" => {
        self.process_append_partition_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "append_partition_by_name_with_environment_context" => {
        self.process_append_partition_by_name_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_partition" => {
        self.process_drop_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_partition_with_environment_context" => {
        self.process_drop_partition_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_partition_by_name" => {
        self.process_drop_partition_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_partition_by_name_with_environment_context" => {
        self.process_drop_partition_by_name_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_partitions_req" => {
        self.process_drop_partitions_req(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition" => {
        self.process_get_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "exchange_partition" => {
        self.process_exchange_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "exchange_partitions" => {
        self.process_exchange_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition_with_auth" => {
        self.process_get_partition_with_auth(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition_by_name" => {
        self.process_get_partition_by_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions" => {
        self.process_get_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_with_auth" => {
        self.process_get_partitions_with_auth(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_pspec" => {
        self.process_get_partitions_pspec(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition_names" => {
        self.process_get_partition_names(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition_values" => {
        self.process_get_partition_values(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_ps" => {
        self.process_get_partitions_ps(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_ps_with_auth" => {
        self.process_get_partitions_ps_with_auth(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition_names_ps" => {
        self.process_get_partition_names_ps(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_by_filter" => {
        self.process_get_partitions_by_filter(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_part_specs_by_filter" => {
        self.process_get_part_specs_by_filter(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_by_expr" => {
        self.process_get_partitions_by_expr(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_num_partitions_by_filter" => {
        self.process_get_num_partitions_by_filter(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_by_names" => {
        self.process_get_partitions_by_names(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_partition" => {
        self.process_alter_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_partitions" => {
        self.process_alter_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_partitions_with_environment_context" => {
        self.process_alter_partitions_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_partition_with_environment_context" => {
        self.process_alter_partition_with_environment_context(message_ident.sequence_number, i_prot, o_prot)
      },
      "rename_partition" => {
        self.process_rename_partition(message_ident.sequence_number, i_prot, o_prot)
      },
      "partition_name_has_valid_characters" => {
        self.process_partition_name_has_valid_characters(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_config_value" => {
        self.process_get_config_value(message_ident.sequence_number, i_prot, o_prot)
      },
      "partition_name_to_vals" => {
        self.process_partition_name_to_vals(message_ident.sequence_number, i_prot, o_prot)
      },
      "partition_name_to_spec" => {
        self.process_partition_name_to_spec(message_ident.sequence_number, i_prot, o_prot)
      },
      "markPartitionForEvent" => {
        self.process_mark_partition_for_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "isPartitionMarkedForEvent" => {
        self.process_is_partition_marked_for_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_primary_keys" => {
        self.process_get_primary_keys(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_foreign_keys" => {
        self.process_get_foreign_keys(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_unique_constraints" => {
        self.process_get_unique_constraints(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_not_null_constraints" => {
        self.process_get_not_null_constraints(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_default_constraints" => {
        self.process_get_default_constraints(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_check_constraints" => {
        self.process_get_check_constraints(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_table_column_statistics" => {
        self.process_update_table_column_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_partition_column_statistics" => {
        self.process_update_partition_column_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_column_statistics" => {
        self.process_get_table_column_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partition_column_statistics" => {
        self.process_get_partition_column_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_statistics_req" => {
        self.process_get_table_statistics_req(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_partitions_statistics_req" => {
        self.process_get_partitions_statistics_req(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_aggr_stats_for" => {
        self.process_get_aggr_stats_for(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_aggr_stats_for" => {
        self.process_set_aggr_stats_for(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_partition_column_statistics" => {
        self.process_delete_partition_column_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "delete_table_column_statistics" => {
        self.process_delete_table_column_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_function" => {
        self.process_create_function(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_function" => {
        self.process_drop_function(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_function" => {
        self.process_alter_function(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_functions" => {
        self.process_get_functions(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_function" => {
        self.process_get_function(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_functions" => {
        self.process_get_all_functions(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_role" => {
        self.process_create_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_role" => {
        self.process_drop_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_role_names" => {
        self.process_get_role_names(message_ident.sequence_number, i_prot, o_prot)
      },
      "grant_role" => {
        self.process_grant_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "revoke_role" => {
        self.process_revoke_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "list_roles" => {
        self.process_list_roles(message_ident.sequence_number, i_prot, o_prot)
      },
      "grant_revoke_role" => {
        self.process_grant_revoke_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_principals_in_role" => {
        self.process_get_principals_in_role(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_role_grants_for_principal" => {
        self.process_get_role_grants_for_principal(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_privilege_set" => {
        self.process_get_privilege_set(message_ident.sequence_number, i_prot, o_prot)
      },
      "list_privileges" => {
        self.process_list_privileges(message_ident.sequence_number, i_prot, o_prot)
      },
      "grant_privileges" => {
        self.process_grant_privileges(message_ident.sequence_number, i_prot, o_prot)
      },
      "revoke_privileges" => {
        self.process_revoke_privileges(message_ident.sequence_number, i_prot, o_prot)
      },
      "grant_revoke_privileges" => {
        self.process_grant_revoke_privileges(message_ident.sequence_number, i_prot, o_prot)
      },
      "refresh_privileges" => {
        self.process_refresh_privileges(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_ugi" => {
        self.process_set_ugi(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_delegation_token" => {
        self.process_get_delegation_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "renew_delegation_token" => {
        self.process_renew_delegation_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "cancel_delegation_token" => {
        self.process_cancel_delegation_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_token" => {
        self.process_add_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "remove_token" => {
        self.process_remove_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_token" => {
        self.process_get_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_token_identifiers" => {
        self.process_get_all_token_identifiers(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_master_key" => {
        self.process_add_master_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_master_key" => {
        self.process_update_master_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "remove_master_key" => {
        self.process_remove_master_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_master_keys" => {
        self.process_get_master_keys(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_open_txns" => {
        self.process_get_open_txns(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_open_txns_info" => {
        self.process_get_open_txns_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "open_txns" => {
        self.process_open_txns(message_ident.sequence_number, i_prot, o_prot)
      },
      "abort_txn" => {
        self.process_abort_txn(message_ident.sequence_number, i_prot, o_prot)
      },
      "abort_txns" => {
        self.process_abort_txns(message_ident.sequence_number, i_prot, o_prot)
      },
      "commit_txn" => {
        self.process_commit_txn(message_ident.sequence_number, i_prot, o_prot)
      },
      "repl_tbl_writeid_state" => {
        self.process_repl_tbl_writeid_state(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_valid_write_ids" => {
        self.process_get_valid_write_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "allocate_table_write_ids" => {
        self.process_allocate_table_write_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "lock" => {
        self.process_lock(message_ident.sequence_number, i_prot, o_prot)
      },
      "check_lock" => {
        self.process_check_lock(message_ident.sequence_number, i_prot, o_prot)
      },
      "unlock" => {
        self.process_unlock(message_ident.sequence_number, i_prot, o_prot)
      },
      "show_locks" => {
        self.process_show_locks(message_ident.sequence_number, i_prot, o_prot)
      },
      "heartbeat" => {
        self.process_heartbeat(message_ident.sequence_number, i_prot, o_prot)
      },
      "heartbeat_txn_range" => {
        self.process_heartbeat_txn_range(message_ident.sequence_number, i_prot, o_prot)
      },
      "compact" => {
        self.process_compact(message_ident.sequence_number, i_prot, o_prot)
      },
      "compact2" => {
        self.process_compact2(message_ident.sequence_number, i_prot, o_prot)
      },
      "show_compact" => {
        self.process_show_compact(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_dynamic_partitions" => {
        self.process_add_dynamic_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_next_notification" => {
        self.process_get_next_notification(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_current_notificationEventId" => {
        self.process_get_current_notification_event_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_notification_events_count" => {
        self.process_get_notification_events_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "fire_listener_event" => {
        self.process_fire_listener_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "flushCache" => {
        self.process_flush_cache(message_ident.sequence_number, i_prot, o_prot)
      },
      "cm_recycle" => {
        self.process_cm_recycle(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_file_metadata_by_expr" => {
        self.process_get_file_metadata_by_expr(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_file_metadata" => {
        self.process_get_file_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "put_file_metadata" => {
        self.process_put_file_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "clear_file_metadata" => {
        self.process_clear_file_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "cache_file_metadata" => {
        self.process_cache_file_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_metastore_db_uuid" => {
        self.process_get_metastore_db_uuid(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_resource_plan" => {
        self.process_create_resource_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_resource_plan" => {
        self.process_get_resource_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_active_resource_plan" => {
        self.process_get_active_resource_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_all_resource_plans" => {
        self.process_get_all_resource_plans(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_resource_plan" => {
        self.process_alter_resource_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "validate_resource_plan" => {
        self.process_validate_resource_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_resource_plan" => {
        self.process_drop_resource_plan(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_wm_trigger" => {
        self.process_create_wm_trigger(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_wm_trigger" => {
        self.process_alter_wm_trigger(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_wm_trigger" => {
        self.process_drop_wm_trigger(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_triggers_for_resourceplan" => {
        self.process_get_triggers_for_resourceplan(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_wm_pool" => {
        self.process_create_wm_pool(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_wm_pool" => {
        self.process_alter_wm_pool(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_wm_pool" => {
        self.process_drop_wm_pool(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_or_update_wm_mapping" => {
        self.process_create_or_update_wm_mapping(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_wm_mapping" => {
        self.process_drop_wm_mapping(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_or_drop_wm_trigger_to_pool_mapping" => {
        self.process_create_or_drop_wm_trigger_to_pool_mapping(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_ischema" => {
        self.process_create_ischema(message_ident.sequence_number, i_prot, o_prot)
      },
      "alter_ischema" => {
        self.process_alter_ischema(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_ischema" => {
        self.process_get_ischema(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_ischema" => {
        self.process_drop_ischema(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_schema_version" => {
        self.process_add_schema_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_schema_version" => {
        self.process_get_schema_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_schema_latest_version" => {
        self.process_get_schema_latest_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_schema_all_versions" => {
        self.process_get_schema_all_versions(message_ident.sequence_number, i_prot, o_prot)
      },
      "drop_schema_version" => {
        self.process_drop_schema_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_schemas_by_cols" => {
        self.process_get_schemas_by_cols(message_ident.sequence_number, i_prot, o_prot)
      },
      "map_schema_version_to_serde" => {
        self.process_map_schema_version_to_serde(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_schema_version_state" => {
        self.process_set_schema_version_state(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_serde" => {
        self.process_add_serde(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_serde" => {
        self.process_get_serde(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_lock_materialization_rebuild" => {
        self.process_get_lock_materialization_rebuild(message_ident.sequence_number, i_prot, o_prot)
      },
      "heartbeat_lock_materialization_rebuild" => {
        self.process_heartbeat_lock_materialization_rebuild(message_ident.sequence_number, i_prot, o_prot)
      },
      "add_runtime_stats" => {
        self.process_add_runtime_stats(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_runtime_stats" => {
        self.process_get_runtime_stats(message_ident.sequence_number, i_prot, o_prot)
      },
      "getName" => {
        self.process_get_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "getVersion" => {
        self.process_get_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "getStatus" => {
        self.process_get_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "getStatusDetails" => {
        self.process_get_status_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCounters" => {
        self.process_get_counters(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCounter" => {
        self.process_get_counter(message_ident.sequence_number, i_prot, o_prot)
      },
      "setOption" => {
        self.process_set_option(message_ident.sequence_number, i_prot, o_prot)
      },
      "getOption" => {
        self.process_get_option(message_ident.sequence_number, i_prot, o_prot)
      },
      "getOptions" => {
        self.process_get_options(message_ident.sequence_number, i_prot, o_prot)
      },
      "getCpuProfile" => {
        self.process_get_cpu_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "aliveSince" => {
        self.process_alive_since(message_ident.sequence_number, i_prot, o_prot)
      },
      "reinitialize" => {
        self.process_reinitialize(message_ident.sequence_number, i_prot, o_prot)
      },
      "shutdown" => {
        self.process_shutdown(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ThriftHiveMetastoreGetMetaConfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMetaConfArgs {
  key: String,
}

impl ThriftHiveMetastoreGetMetaConfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMetaConfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetMetaConfArgs.key", &f_1)?;
    let ret = ThriftHiveMetastoreGetMetaConfArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getMetaConf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetMetaConfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMetaConfResult {
  result_value: Option<String>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetMetaConfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMetaConfResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMetaConfResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetMetaConfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetMetaConf"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreSetMetaConfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetMetaConfArgs {
  key: String,
  value: String,
}

impl ThriftHiveMetastoreSetMetaConfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetMetaConfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreSetMetaConfArgs.key", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreSetMetaConfArgs.value", &f_2)?;
    let ret = ThriftHiveMetastoreSetMetaConfArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setMetaConf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreSetMetaConfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetMetaConfResult {
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreSetMetaConfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetMetaConfResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreSetMetaConfResult {
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreSetMetaConfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreCreateCatalogArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateCatalogArgs {
  catalog: CreateCatalogRequest,
}

impl ThriftHiveMetastoreCreateCatalogArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateCatalogArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CreateCatalogRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CreateCatalogRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateCatalogArgs.catalog", &f_1)?;
    let ret = ThriftHiveMetastoreCreateCatalogArgs {
      catalog: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_catalog_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::Struct, 1))?;
    self.catalog.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateCatalogResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateCatalogResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateCatalogResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateCatalogResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateCatalogResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateCatalogResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterCatalogArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterCatalogArgs {
  rqst: AlterCatalogRequest,
}

impl ThriftHiveMetastoreAlterCatalogArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterCatalogArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlterCatalogRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlterCatalogRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterCatalogArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreAlterCatalogArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_catalog_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterCatalogResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterCatalogResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterCatalogResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterCatalogResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterCatalogResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterCatalogResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetCatalogArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCatalogArgs {
  cat_name: GetCatalogRequest,
}

impl ThriftHiveMetastoreGetCatalogArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCatalogArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetCatalogRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetCatalogRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetCatalogArgs.cat_name", &f_1)?;
    let ret = ThriftHiveMetastoreGetCatalogArgs {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_catalog_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::Struct, 1))?;
    self.cat_name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetCatalogResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCatalogResult {
  result_value: Option<GetCatalogResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetCatalogResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCatalogResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetCatalogResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetCatalogResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetCatalogResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetCatalogResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetCatalogResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetCatalog"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetCatalogsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCatalogsArgs {
}

impl ThriftHiveMetastoreGetCatalogsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCatalogsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetCatalogsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_catalogs_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetCatalogsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCatalogsResult {
  result_value: Option<GetCatalogsResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetCatalogsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCatalogsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetCatalogsResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetCatalogsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetCatalogsResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetCatalogsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetCatalogsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetCatalogs"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropCatalogArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropCatalogArgs {
  cat_name: DropCatalogRequest,
}

impl ThriftHiveMetastoreDropCatalogArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropCatalogArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DropCatalogRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DropCatalogRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropCatalogArgs.cat_name", &f_1)?;
    let ret = ThriftHiveMetastoreDropCatalogArgs {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_catalog_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::Struct, 1))?;
    self.cat_name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropCatalogResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropCatalogResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropCatalogResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropCatalogResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropCatalogResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropCatalogResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreCreateDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateDatabaseArgs {
  database: Database,
}

impl ThriftHiveMetastoreCreateDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Database> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Database::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateDatabaseArgs.database", &f_1)?;
    let ret = ThriftHiveMetastoreCreateDatabaseArgs {
      database: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::Struct, 1))?;
    self.database.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateDatabaseResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateDatabaseResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDatabaseArgs {
  name: String,
}

impl ThriftHiveMetastoreGetDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetDatabaseArgs.name", &f_1)?;
    let ret = ThriftHiveMetastoreGetDatabaseArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDatabaseResult {
  result_value: Option<Database>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Database> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Database::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetDatabaseResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Database> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetDatabase"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropDatabaseArgs {
  name: String,
  delete_data: bool,
  cascade: bool,
}

impl ThriftHiveMetastoreDropDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropDatabaseArgs.name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropDatabaseArgs.delete_data", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropDatabaseArgs.cascade", &f_3)?;
    let ret = ThriftHiveMetastoreDropDatabaseArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      cascade: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 2))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cascade", TType::Bool, 3))?;
    o_prot.write_bool(self.cascade)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropDatabaseResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropDatabaseResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetDatabasesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDatabasesArgs {
  pattern: String,
}

impl ThriftHiveMetastoreGetDatabasesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDatabasesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetDatabasesArgs.pattern", &f_1)?;
    let ret = ThriftHiveMetastoreGetDatabasesArgs {
      pattern: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_databases_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pattern", TType::String, 1))?;
    o_prot.write_string(&self.pattern)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetDatabasesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDatabasesResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetDatabasesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDatabasesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_127 = i_prot.read_string()?;
            val.push(list_elem_127);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetDatabasesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetDatabasesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetDatabases"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetAllDatabasesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllDatabasesArgs {
}

impl ThriftHiveMetastoreGetAllDatabasesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllDatabasesArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllDatabasesArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_databases_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetAllDatabasesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllDatabasesResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetAllDatabasesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllDatabasesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_128 = i_prot.read_string()?;
            val.push(list_elem_128);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllDatabasesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetAllDatabasesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetAllDatabases"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAlterDatabaseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterDatabaseArgs {
  dbname: String,
  db: Database,
}

impl ThriftHiveMetastoreAlterDatabaseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterDatabaseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Database> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Database::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterDatabaseArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterDatabaseArgs.db", &f_2)?;
    let ret = ThriftHiveMetastoreAlterDatabaseArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      db: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_database_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::Struct, 2))?;
    self.db.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterDatabaseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterDatabaseResult {
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreAlterDatabaseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterDatabaseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterDatabaseResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterDatabaseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetTypeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTypeArgs {
  name: String,
}

impl ThriftHiveMetastoreGetTypeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTypeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTypeArgs.name", &f_1)?;
    let ret = ThriftHiveMetastoreGetTypeArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_type_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTypeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTypeResult {
  result_value: Option<Type>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetTypeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTypeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Type> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Type::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTypeResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTypeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Type> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetType"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateTypeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTypeArgs {
  type_: Type,
}

impl ThriftHiveMetastoreCreateTypeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTypeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Type> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Type::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTypeArgs.type_", &f_1)?;
    let ret = ThriftHiveMetastoreCreateTypeArgs {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_type_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::Struct, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateTypeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTypeResult {
  result_value: Option<bool>,
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateTypeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTypeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateTypeResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateTypeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateType"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropTypeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropTypeArgs {
  type_: String,
}

impl ThriftHiveMetastoreDropTypeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropTypeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropTypeArgs.type_", &f_1)?;
    let ret = ThriftHiveMetastoreDropTypeArgs {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_type_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 1))?;
    o_prot.write_string(&self.type_)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropTypeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropTypeResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreDropTypeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropTypeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropTypeResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropTypeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropType"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTypeAllArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTypeAllArgs {
  name: String,
}

impl ThriftHiveMetastoreGetTypeAllArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTypeAllArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTypeAllArgs.name", &f_1)?;
    let ret = ThriftHiveMetastoreGetTypeAllArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_type_all_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTypeAllResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTypeAllResult {
  result_value: Option<BTreeMap<String, Type>>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetTypeAllResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTypeAllResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, Type>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Type> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_129 = i_prot.read_string()?;
            let map_val_130 = Type::read_from_in_protocol(i_prot)?;
            val.insert(map_key_129, map_val_130);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTypeAllResult {
      result_value: f_0,
      o2: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTypeAllResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, Type>> {
    if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTypeAll"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetFieldsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFieldsArgs {
  db_name: String,
  table_name: String,
}

impl ThriftHiveMetastoreGetFieldsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFieldsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetFieldsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetFieldsArgs.table_name", &f_2)?;
    let ret = ThriftHiveMetastoreGetFieldsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_fields_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetFieldsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFieldsResult {
  result_value: Option<Vec<FieldSchema>>,
  o1: Option<MetaException>,
  o2: Option<UnknownTableException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetFieldsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFieldsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<FieldSchema>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<UnknownTableException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_131 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_131);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = UnknownTableException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetFieldsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetFieldsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<FieldSchema>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetFields"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs {
  db_name: String,
  table_name: String,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs.table_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs.environment_context", &f_3)?;
    let ret = ThriftHiveMetastoreGetFieldsWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_fields_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 3))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult {
  result_value: Option<Vec<FieldSchema>>,
  o1: Option<MetaException>,
  o2: Option<UnknownTableException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<FieldSchema>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<UnknownTableException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_132 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_132);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = UnknownTableException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetFieldsWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<FieldSchema>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetFieldsWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetSchemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaArgs {
  db_name: String,
  table_name: String,
}

impl ThriftHiveMetastoreGetSchemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaArgs.table_name", &f_2)?;
    let ret = ThriftHiveMetastoreGetSchemaArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_schema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSchemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaResult {
  result_value: Option<Vec<FieldSchema>>,
  o1: Option<MetaException>,
  o2: Option<UnknownTableException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetSchemaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<FieldSchema>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<UnknownTableException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_133 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_133);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = UnknownTableException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSchemaResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSchemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<FieldSchema>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSchema"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs {
  db_name: String,
  table_name: String,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs.table_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs.environment_context", &f_3)?;
    let ret = ThriftHiveMetastoreGetSchemaWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_schema_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 3))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult {
  result_value: Option<Vec<FieldSchema>>,
  o1: Option<MetaException>,
  o2: Option<UnknownTableException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<FieldSchema>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<UnknownTableException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FieldSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_134 = FieldSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_134);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = UnknownTableException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSchemaWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<FieldSchema>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSchemaWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTableArgs {
  tbl: Table,
}

impl ThriftHiveMetastoreCreateTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Table> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableArgs.tbl", &f_1)?;
    let ret = ThriftHiveMetastoreCreateTableArgs {
      tbl: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl", TType::Struct, 1))?;
    self.tbl.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTableResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreCreateTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateTableResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs {
  tbl: Table,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Table> = None;
    let mut f_2: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs.tbl", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs.environment_context", &f_2)?;
    let ret = ThriftHiveMetastoreCreateTableWithEnvironmentContextArgs {
      tbl: f_1.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_table_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl", TType::Struct, 1))?;
    self.tbl.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 2))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateTableWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTableWithEnvironmentContextResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreCreateTableWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTableWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateTableWithEnvironmentContextResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateTableWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreCreateTableWithConstraintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTableWithConstraintsArgs {
  tbl: Table,
  primary_keys: Vec<SQLPrimaryKey>,
  foreign_keys: Vec<SQLForeignKey>,
  unique_constraints: Vec<SQLUniqueConstraint>,
  not_null_constraints: Vec<SQLNotNullConstraint>,
  default_constraints: Vec<SQLDefaultConstraint>,
  check_constraints: Vec<SQLCheckConstraint>,
}

impl ThriftHiveMetastoreCreateTableWithConstraintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTableWithConstraintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Table> = None;
    let mut f_2: Option<Vec<SQLPrimaryKey>> = None;
    let mut f_3: Option<Vec<SQLForeignKey>> = None;
    let mut f_4: Option<Vec<SQLUniqueConstraint>> = None;
    let mut f_5: Option<Vec<SQLNotNullConstraint>> = None;
    let mut f_6: Option<Vec<SQLDefaultConstraint>> = None;
    let mut f_7: Option<Vec<SQLCheckConstraint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLPrimaryKey> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_135 = SQLPrimaryKey::read_from_in_protocol(i_prot)?;
            val.push(list_elem_135);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLForeignKey> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_136 = SQLForeignKey::read_from_in_protocol(i_prot)?;
            val.push(list_elem_136);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLUniqueConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_137 = SQLUniqueConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_137);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLNotNullConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_138 = SQLNotNullConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_138);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLDefaultConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_139 = SQLDefaultConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_139);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SQLCheckConstraint> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_140 = SQLCheckConstraint::read_from_in_protocol(i_prot)?;
            val.push(list_elem_140);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.tbl", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.primary_keys", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.foreign_keys", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.unique_constraints", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.not_null_constraints", &f_5)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.default_constraints", &f_6)?;
    verify_required_field_exists("ThriftHiveMetastoreCreateTableWithConstraintsArgs.check_constraints", &f_7)?;
    let ret = ThriftHiveMetastoreCreateTableWithConstraintsArgs {
      tbl: f_1.expect("auto-generated code should have checked for presence of required fields"),
      primary_keys: f_2.expect("auto-generated code should have checked for presence of required fields"),
      foreign_keys: f_3.expect("auto-generated code should have checked for presence of required fields"),
      unique_constraints: f_4.expect("auto-generated code should have checked for presence of required fields"),
      not_null_constraints: f_5.expect("auto-generated code should have checked for presence of required fields"),
      default_constraints: f_6.expect("auto-generated code should have checked for presence of required fields"),
      check_constraints: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_table_with_constraints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl", TType::Struct, 1))?;
    self.tbl.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primaryKeys", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.primary_keys.len() as i32))?;
    for e in &self.primary_keys {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("foreignKeys", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.foreign_keys.len() as i32))?;
    for e in &self.foreign_keys {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uniqueConstraints", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.unique_constraints.len() as i32))?;
    for e in &self.unique_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notNullConstraints", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.not_null_constraints.len() as i32))?;
    for e in &self.not_null_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("defaultConstraints", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.default_constraints.len() as i32))?;
    for e in &self.default_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("checkConstraints", TType::List, 7))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.check_constraints.len() as i32))?;
    for e in &self.check_constraints {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateTableWithConstraintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateTableWithConstraintsResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreCreateTableWithConstraintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateTableWithConstraintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateTableWithConstraintsResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateTableWithConstraintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreDropConstraintArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropConstraintArgs {
  req: DropConstraintRequest,
}

impl ThriftHiveMetastoreDropConstraintArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropConstraintArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DropConstraintRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DropConstraintRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropConstraintArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreDropConstraintArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_constraint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropConstraintResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropConstraintResult {
  o1: Option<NoSuchObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropConstraintResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropConstraintResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropConstraintResult {
      o1: f_1,
      o3: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropConstraintResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddPrimaryKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPrimaryKeyArgs {
  req: AddPrimaryKeyRequest,
}

impl ThriftHiveMetastoreAddPrimaryKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPrimaryKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddPrimaryKeyRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddPrimaryKeyRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddPrimaryKeyArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreAddPrimaryKeyArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_primary_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddPrimaryKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPrimaryKeyResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddPrimaryKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPrimaryKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddPrimaryKeyResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddPrimaryKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddForeignKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddForeignKeyArgs {
  req: AddForeignKeyRequest,
}

impl ThriftHiveMetastoreAddForeignKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddForeignKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddForeignKeyRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddForeignKeyRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddForeignKeyArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreAddForeignKeyArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_foreign_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddForeignKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddForeignKeyResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddForeignKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddForeignKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddForeignKeyResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddForeignKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddUniqueConstraintArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddUniqueConstraintArgs {
  req: AddUniqueConstraintRequest,
}

impl ThriftHiveMetastoreAddUniqueConstraintArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddUniqueConstraintArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddUniqueConstraintRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddUniqueConstraintRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddUniqueConstraintArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreAddUniqueConstraintArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_unique_constraint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddUniqueConstraintResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddUniqueConstraintResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddUniqueConstraintResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddUniqueConstraintResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddUniqueConstraintResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddUniqueConstraintResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddNotNullConstraintArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddNotNullConstraintArgs {
  req: AddNotNullConstraintRequest,
}

impl ThriftHiveMetastoreAddNotNullConstraintArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddNotNullConstraintArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddNotNullConstraintRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddNotNullConstraintRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddNotNullConstraintArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreAddNotNullConstraintArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_not_null_constraint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddNotNullConstraintResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddNotNullConstraintResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddNotNullConstraintResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddNotNullConstraintResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddNotNullConstraintResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddNotNullConstraintResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddDefaultConstraintArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddDefaultConstraintArgs {
  req: AddDefaultConstraintRequest,
}

impl ThriftHiveMetastoreAddDefaultConstraintArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddDefaultConstraintArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddDefaultConstraintRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddDefaultConstraintRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddDefaultConstraintArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreAddDefaultConstraintArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_default_constraint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddDefaultConstraintResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddDefaultConstraintResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddDefaultConstraintResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddDefaultConstraintResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddDefaultConstraintResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddDefaultConstraintResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddCheckConstraintArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddCheckConstraintArgs {
  req: AddCheckConstraintRequest,
}

impl ThriftHiveMetastoreAddCheckConstraintArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddCheckConstraintArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddCheckConstraintRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddCheckConstraintRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddCheckConstraintArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreAddCheckConstraintArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_check_constraint_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddCheckConstraintResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddCheckConstraintResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddCheckConstraintResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddCheckConstraintResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddCheckConstraintResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddCheckConstraintResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreDropTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropTableArgs {
  dbname: String,
  name: String,
  delete_data: bool,
}

impl ThriftHiveMetastoreDropTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableArgs.name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableArgs.delete_data", &f_3)?;
    let ret = ThriftHiveMetastoreDropTableArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 3))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropTableResult {
  o1: Option<NoSuchObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropTableResult {
      o1: f_1,
      o3: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreDropTableWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropTableWithEnvironmentContextArgs {
  dbname: String,
  name: String,
  delete_data: bool,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreDropTableWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropTableWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableWithEnvironmentContextArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableWithEnvironmentContextArgs.name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableWithEnvironmentContextArgs.delete_data", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreDropTableWithEnvironmentContextArgs.environment_context", &f_4)?;
    let ret = ThriftHiveMetastoreDropTableWithEnvironmentContextArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_table_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 3))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 4))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropTableWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropTableWithEnvironmentContextResult {
  o1: Option<NoSuchObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropTableWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropTableWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropTableWithEnvironmentContextResult {
      o1: f_1,
      o3: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropTableWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreTruncateTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreTruncateTableArgs {
  db_name: String,
  table_name: String,
  part_names: Vec<String>,
}

impl ThriftHiveMetastoreTruncateTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreTruncateTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_141 = i_prot.read_string()?;
            val.push(list_elem_141);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreTruncateTableArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreTruncateTableArgs.table_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreTruncateTableArgs.part_names", &f_3)?;
    let ret = ThriftHiveMetastoreTruncateTableArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_names: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("truncate_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partNames", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_names.len() as i32))?;
    for e in &self.part_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreTruncateTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreTruncateTableResult {
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreTruncateTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreTruncateTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreTruncateTableResult {
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreTruncateTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTablesArgs {
  db_name: String,
  pattern: String,
}

impl ThriftHiveMetastoreGetTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTablesArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTablesArgs.pattern", &f_2)?;
    let ret = ThriftHiveMetastoreGetTablesArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pattern: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pattern", TType::String, 2))?;
    o_prot.write_string(&self.pattern)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTablesResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_142 = i_prot.read_string()?;
            val.push(list_elem_142);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTablesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTables"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTablesByTypeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTablesByTypeArgs {
  db_name: String,
  pattern: String,
  table_type: String,
}

impl ThriftHiveMetastoreGetTablesByTypeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTablesByTypeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTablesByTypeArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTablesByTypeArgs.pattern", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTablesByTypeArgs.table_type", &f_3)?;
    let ret = ThriftHiveMetastoreGetTablesByTypeArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pattern: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_tables_by_type_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pattern", TType::String, 2))?;
    o_prot.write_string(&self.pattern)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableType", TType::String, 3))?;
    o_prot.write_string(&self.table_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTablesByTypeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTablesByTypeResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetTablesByTypeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTablesByTypeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_143 = i_prot.read_string()?;
            val.push(list_elem_143);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTablesByTypeResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTablesByTypeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTablesByType"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs {
  db_name: String,
}

impl ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs.db_name", &f_1)?;
    let ret = ThriftHiveMetastoreGetMaterializedViewsForRewritingArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_materialized_views_for_rewriting_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetMaterializedViewsForRewritingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMaterializedViewsForRewritingResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetMaterializedViewsForRewritingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMaterializedViewsForRewritingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_144 = i_prot.read_string()?;
            val.push(list_elem_144);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMaterializedViewsForRewritingResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetMaterializedViewsForRewritingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetMaterializedViewsForRewriting"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableMetaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableMetaArgs {
  db_patterns: String,
  tbl_patterns: String,
  tbl_types: Vec<String>,
}

impl ThriftHiveMetastoreGetTableMetaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableMetaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_145 = i_prot.read_string()?;
            val.push(list_elem_145);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableMetaArgs.db_patterns", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableMetaArgs.tbl_patterns", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableMetaArgs.tbl_types", &f_3)?;
    let ret = ThriftHiveMetastoreGetTableMetaArgs {
      db_patterns: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_patterns: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_types: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_meta_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_patterns", TType::String, 1))?;
    o_prot.write_string(&self.db_patterns)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_patterns", TType::String, 2))?;
    o_prot.write_string(&self.tbl_patterns)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_types", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tbl_types.len() as i32))?;
    for e in &self.tbl_types {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableMetaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableMetaResult {
  result_value: Option<Vec<TableMeta>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetTableMetaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableMetaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<TableMeta>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TableMeta> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_146 = TableMeta::read_from_in_protocol(i_prot)?;
            val.push(list_elem_146);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableMetaResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableMetaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<TableMeta>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableMeta"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetAllTablesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllTablesArgs {
  db_name: String,
}

impl ThriftHiveMetastoreGetAllTablesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllTablesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetAllTablesArgs.db_name", &f_1)?;
    let ret = ThriftHiveMetastoreGetAllTablesArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_tables_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetAllTablesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllTablesResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetAllTablesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllTablesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_147 = i_prot.read_string()?;
            val.push(list_elem_147);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllTablesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetAllTablesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetAllTables"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableArgs {
  dbname: String,
  tbl_name: String,
}

impl ThriftHiveMetastoreGetTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableArgs.tbl_name", &f_2)?;
    let ret = ThriftHiveMetastoreGetTableArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableResult {
  result_value: Option<Table>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Table> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Table> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTable"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableObjectsByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableObjectsByNameArgs {
  dbname: String,
  tbl_names: Vec<String>,
}

impl ThriftHiveMetastoreGetTableObjectsByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableObjectsByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_148 = i_prot.read_string()?;
            val.push(list_elem_148);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableObjectsByNameArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableObjectsByNameArgs.tbl_names", &f_2)?;
    let ret = ThriftHiveMetastoreGetTableObjectsByNameArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_names: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_objects_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_names", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tbl_names.len() as i32))?;
    for e in &self.tbl_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableObjectsByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableObjectsByNameResult {
  result_value: Option<Vec<Table>>,
}

impl ThriftHiveMetastoreGetTableObjectsByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableObjectsByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Table>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Table> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_149 = Table::read_from_in_protocol(i_prot)?;
            val.push(list_elem_149);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableObjectsByNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableObjectsByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Table>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableObjectsByName"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableReqArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableReqArgs {
  req: GetTableRequest,
}

impl ThriftHiveMetastoreGetTableReqArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableReqArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetTableRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetTableRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableReqArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreGetTableReqArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_req_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableReqResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableReqResult {
  result_value: Option<GetTableResult>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetTableReqResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableReqResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetTableResult> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetTableResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableReqResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableReqResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetTableResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableReq"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableObjectsByNameReqArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableObjectsByNameReqArgs {
  req: GetTablesRequest,
}

impl ThriftHiveMetastoreGetTableObjectsByNameReqArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableObjectsByNameReqArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetTablesRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetTablesRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableObjectsByNameReqArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreGetTableObjectsByNameReqArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_objects_by_name_req_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableObjectsByNameReqResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableObjectsByNameReqResult {
  result_value: Option<GetTablesResult>,
  o1: Option<MetaException>,
  o2: Option<InvalidOperationException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetTableObjectsByNameReqResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableObjectsByNameReqResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetTablesResult> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetTablesResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableObjectsByNameReqResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableObjectsByNameReqResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetTablesResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableObjectsByNameReq"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs {
  creation_metadata: CreationMetadata,
  valid_txn_list: String,
}

impl ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CreationMetadata> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CreationMetadata::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs.creation_metadata", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs.valid_txn_list", &f_2)?;
    let ret = ThriftHiveMetastoreGetMaterializationInvalidationInfoArgs {
      creation_metadata: f_1.expect("auto-generated code should have checked for presence of required fields"),
      valid_txn_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_materialization_invalidation_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("creation_metadata", TType::Struct, 1))?;
    self.creation_metadata.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("validTxnList", TType::String, 2))?;
    o_prot.write_string(&self.valid_txn_list)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetMaterializationInvalidationInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMaterializationInvalidationInfoResult {
  result_value: Option<Materialization>,
  o1: Option<MetaException>,
  o2: Option<InvalidOperationException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetMaterializationInvalidationInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMaterializationInvalidationInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Materialization> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Materialization::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMaterializationInvalidationInfoResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetMaterializationInvalidationInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Materialization> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetMaterializationInvalidationInfo"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreUpdateCreationMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdateCreationMetadataArgs {
  cat_name: String,
  dbname: String,
  tbl_name: String,
  creation_metadata: CreationMetadata,
}

impl ThriftHiveMetastoreUpdateCreationMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdateCreationMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<CreationMetadata> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = CreationMetadata::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateCreationMetadataArgs.cat_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateCreationMetadataArgs.dbname", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateCreationMetadataArgs.tbl_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateCreationMetadataArgs.creation_metadata", &f_4)?;
    let ret = ThriftHiveMetastoreUpdateCreationMetadataArgs {
      cat_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dbname: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      creation_metadata: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_creation_metadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("catName", TType::String, 1))?;
    o_prot.write_string(&self.cat_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 2))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 3))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("creation_metadata", TType::Struct, 4))?;
    self.creation_metadata.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreUpdateCreationMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdateCreationMetadataResult {
  o1: Option<MetaException>,
  o2: Option<InvalidOperationException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreUpdateCreationMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdateCreationMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreUpdateCreationMetadataResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreUpdateCreationMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetTableNamesByFilterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableNamesByFilterArgs {
  dbname: String,
  filter: String,
  max_tables: i16,
}

impl ThriftHiveMetastoreGetTableNamesByFilterArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableNamesByFilterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableNamesByFilterArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableNamesByFilterArgs.filter", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableNamesByFilterArgs.max_tables", &f_3)?;
    let ret = ThriftHiveMetastoreGetTableNamesByFilterArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_tables: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_names_by_filter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::String, 2))?;
    o_prot.write_string(&self.filter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_tables", TType::I16, 3))?;
    o_prot.write_i16(self.max_tables)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableNamesByFilterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableNamesByFilterResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
  o2: Option<InvalidOperationException>,
  o3: Option<UnknownDBException>,
}

impl ThriftHiveMetastoreGetTableNamesByFilterResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableNamesByFilterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_150 = i_prot.read_string()?;
            val.push(list_elem_150);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableNamesByFilterResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableNamesByFilterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableNamesByFilter"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAlterTableArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterTableArgs {
  dbname: String,
  tbl_name: String,
  new_tbl: Table,
}

impl ThriftHiveMetastoreAlterTableArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterTableArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Table> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableArgs.new_tbl", &f_3)?;
    let ret = ThriftHiveMetastoreAlterTableArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_tbl: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_table_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_tbl", TType::Struct, 3))?;
    self.new_tbl.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterTableResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterTableResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterTableResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterTableResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterTableResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterTableResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs {
  dbname: String,
  tbl_name: String,
  new_tbl: Table,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Table> = None;
    let mut f_4: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs.new_tbl", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs.environment_context", &f_4)?;
    let ret = ThriftHiveMetastoreAlterTableWithEnvironmentContextArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_tbl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_table_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_tbl", TType::Struct, 3))?;
    self.new_tbl.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 4))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterTableWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterTableWithEnvironmentContextResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterTableWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterTableWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterTableWithEnvironmentContextResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterTableWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterTableWithCascadeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterTableWithCascadeArgs {
  dbname: String,
  tbl_name: String,
  new_tbl: Table,
  cascade: bool,
}

impl ThriftHiveMetastoreAlterTableWithCascadeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterTableWithCascadeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Table> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Table::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithCascadeArgs.dbname", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithCascadeArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithCascadeArgs.new_tbl", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterTableWithCascadeArgs.cascade", &f_4)?;
    let ret = ThriftHiveMetastoreAlterTableWithCascadeArgs {
      dbname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_tbl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      cascade: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_table_with_cascade_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbname", TType::String, 1))?;
    o_prot.write_string(&self.dbname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_tbl", TType::Struct, 3))?;
    self.new_tbl.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cascade", TType::Bool, 4))?;
    o_prot.write_bool(self.cascade)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterTableWithCascadeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterTableWithCascadeResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterTableWithCascadeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterTableWithCascadeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterTableWithCascadeResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterTableWithCascadeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddPartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionArgs {
  new_part: Partition,
}

impl ThriftHiveMetastoreAddPartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Partition> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddPartitionArgs.new_part", &f_1)?;
    let ret = ThriftHiveMetastoreAddPartitionArgs {
      new_part: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_part", TType::Struct, 1))?;
    self.new_part.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddPartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionResult {
  result_value: Option<Partition>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAddPartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddPartitionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddPartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddPartition"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs {
  new_part: Partition,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Partition> = None;
    let mut f_2: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs.new_part", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs.environment_context", &f_2)?;
    let ret = ThriftHiveMetastoreAddPartitionWithEnvironmentContextArgs {
      new_part: f_1.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_partition_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_part", TType::Struct, 1))?;
    self.new_part.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 2))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult {
  result_value: Option<Partition>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddPartitionWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddPartitionWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddPartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionsArgs {
  new_parts: Vec<Partition>,
}

impl ThriftHiveMetastoreAddPartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Partition>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_151 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_151);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddPartitionsArgs.new_parts", &f_1)?;
    let ret = ThriftHiveMetastoreAddPartitionsArgs {
      new_parts: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_partitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_parts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.new_parts.len() as i32))?;
    for e in &self.new_parts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionsResult {
  result_value: Option<i32>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAddPartitionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddPartitionsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddPartitions"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddPartitionsPspecArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionsPspecArgs {
  new_parts: Vec<PartitionSpec>,
}

impl ThriftHiveMetastoreAddPartitionsPspecArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionsPspecArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<PartitionSpec>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PartitionSpec> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_152 = PartitionSpec::read_from_in_protocol(i_prot)?;
            val.push(list_elem_152);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddPartitionsPspecArgs.new_parts", &f_1)?;
    let ret = ThriftHiveMetastoreAddPartitionsPspecArgs {
      new_parts: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_partitions_pspec_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_parts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.new_parts.len() as i32))?;
    for e in &self.new_parts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddPartitionsPspecResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionsPspecResult {
  result_value: Option<i32>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAddPartitionsPspecResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionsPspecResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddPartitionsPspecResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddPartitionsPspecResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddPartitionsPspec"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAppendPartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
}

impl ThriftHiveMetastoreAppendPartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_153 = i_prot.read_string()?;
            val.push(list_elem_153);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionArgs.part_vals", &f_3)?;
    let ret = ThriftHiveMetastoreAppendPartitionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("append_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAppendPartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionResult {
  result_value: Option<Partition>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAppendPartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAppendPartitionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAppendPartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAppendPartition"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddPartitionsReqArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionsReqArgs {
  request: AddPartitionsRequest,
}

impl ThriftHiveMetastoreAddPartitionsReqArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionsReqArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddPartitionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddPartitionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddPartitionsReqArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreAddPartitionsReqArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_partitions_req_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddPartitionsReqResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddPartitionsReqResult {
  result_value: Option<AddPartitionsResult>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAddPartitionsReqResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddPartitionsReqResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AddPartitionsResult> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AddPartitionsResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddPartitionsReqResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddPartitionsReqResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AddPartitionsResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddPartitionsReq"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_154 = i_prot.read_string()?;
            val.push(list_elem_154);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs.environment_context", &f_4)?;
    let ret = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("append_partition_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 4))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult {
  result_value: Option<Partition>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAppendPartitionWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAppendPartitionWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAppendPartitionByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionByNameArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
}

impl ThriftHiveMetastoreAppendPartitionByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameArgs.part_name", &f_3)?;
    let ret = ThriftHiveMetastoreAppendPartitionByNameArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("append_partition_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAppendPartitionByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionByNameResult {
  result_value: Option<Partition>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAppendPartitionByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAppendPartitionByNameResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAppendPartitionByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAppendPartitionByName"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs.part_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs.environment_context", &f_4)?;
    let ret = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("append_partition_by_name_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 4))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult {
  result_value: Option<Partition>,
  o1: Option<InvalidObjectException>,
  o2: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<InvalidObjectException> = None;
    let mut f_2: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAppendPartitionByNameWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropPartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  delete_data: bool,
}

impl ThriftHiveMetastoreDropPartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_155 = i_prot.read_string()?;
            val.push(list_elem_155);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionArgs.delete_data", &f_4)?;
    let ret = ThriftHiveMetastoreDropPartitionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 4))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropPartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreDropPartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropPartitionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropPartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropPartition"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  delete_data: bool,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_156 = i_prot.read_string()?;
            val.push(list_elem_156);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs.delete_data", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs.environment_context", &f_5)?;
    let ret = ThriftHiveMetastoreDropPartitionWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_partition_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 4))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 5))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropPartitionWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropPartitionWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropPartitionByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionByNameArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
  delete_data: bool,
}

impl ThriftHiveMetastoreDropPartitionByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameArgs.part_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameArgs.delete_data", &f_4)?;
    let ret = ThriftHiveMetastoreDropPartitionByNameArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_partition_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 4))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropPartitionByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionByNameResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreDropPartitionByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropPartitionByNameResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropPartitionByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropPartitionByName"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
  delete_data: bool,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs.part_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs.delete_data", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs.environment_context", &f_5)?;
    let ret = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      delete_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_partition_by_name_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteData", TType::Bool, 4))?;
    o_prot.write_bool(self.delete_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 5))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropPartitionByNameWithEnvironmentContext"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropPartitionsReqArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionsReqArgs {
  req: DropPartitionsRequest,
}

impl ThriftHiveMetastoreDropPartitionsReqArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionsReqArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DropPartitionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DropPartitionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropPartitionsReqArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreDropPartitionsReqArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_partitions_req_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropPartitionsReqResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropPartitionsReqResult {
  result_value: Option<DropPartitionsResult>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreDropPartitionsReqResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropPartitionsReqResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<DropPartitionsResult> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = DropPartitionsResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropPartitionsReqResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropPartitionsReqResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<DropPartitionsResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropPartitionsReq"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
}

impl ThriftHiveMetastoreGetPartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_157 = i_prot.read_string()?;
            val.push(list_elem_157);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionArgs.part_vals", &f_3)?;
    let ret = ThriftHiveMetastoreGetPartitionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionResult {
  result_value: Option<Partition>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartition"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreExchangePartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreExchangePartitionArgs {
  partition_specs: BTreeMap<String, String>,
  source_db: String,
  source_table_name: String,
  dest_db: String,
  dest_table_name: String,
}

impl ThriftHiveMetastoreExchangePartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreExchangePartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, String>> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_158 = i_prot.read_string()?;
            let map_val_159 = i_prot.read_string()?;
            val.insert(map_key_158, map_val_159);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionArgs.partition_specs", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionArgs.source_db", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionArgs.source_table_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionArgs.dest_db", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionArgs.dest_table_name", &f_5)?;
    let ret = ThriftHiveMetastoreExchangePartitionArgs {
      partition_specs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      source_db: f_2.expect("auto-generated code should have checked for presence of required fields"),
      source_table_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      dest_db: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dest_table_name: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("exchange_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitionSpecs", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.partition_specs.len() as i32))?;
    for (k, v) in &self.partition_specs {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("source_db", TType::String, 2))?;
    o_prot.write_string(&self.source_db)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("source_table_name", TType::String, 3))?;
    o_prot.write_string(&self.source_table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dest_db", TType::String, 4))?;
    o_prot.write_string(&self.dest_db)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dest_table_name", TType::String, 5))?;
    o_prot.write_string(&self.dest_table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreExchangePartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreExchangePartitionResult {
  result_value: Option<Partition>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreExchangePartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreExchangePartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreExchangePartitionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreExchangePartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreExchangePartition"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreExchangePartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreExchangePartitionsArgs {
  partition_specs: BTreeMap<String, String>,
  source_db: String,
  source_table_name: String,
  dest_db: String,
  dest_table_name: String,
}

impl ThriftHiveMetastoreExchangePartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreExchangePartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, String>> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_160 = i_prot.read_string()?;
            let map_val_161 = i_prot.read_string()?;
            val.insert(map_key_160, map_val_161);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionsArgs.partition_specs", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionsArgs.source_db", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionsArgs.source_table_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionsArgs.dest_db", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreExchangePartitionsArgs.dest_table_name", &f_5)?;
    let ret = ThriftHiveMetastoreExchangePartitionsArgs {
      partition_specs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      source_db: f_2.expect("auto-generated code should have checked for presence of required fields"),
      source_table_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      dest_db: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dest_table_name: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("exchange_partitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partitionSpecs", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.partition_specs.len() as i32))?;
    for (k, v) in &self.partition_specs {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("source_db", TType::String, 2))?;
    o_prot.write_string(&self.source_db)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("source_table_name", TType::String, 3))?;
    o_prot.write_string(&self.source_table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dest_db", TType::String, 4))?;
    o_prot.write_string(&self.dest_db)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dest_table_name", TType::String, 5))?;
    o_prot.write_string(&self.dest_table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreExchangePartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreExchangePartitionsResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreExchangePartitionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreExchangePartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_162 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_162);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreExchangePartitionsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreExchangePartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreExchangePartitions"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionWithAuthArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionWithAuthArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  user_name: String,
  group_names: Vec<String>,
}

impl ThriftHiveMetastoreGetPartitionWithAuthArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionWithAuthArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_163 = i_prot.read_string()?;
            val.push(list_elem_163);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_164 = i_prot.read_string()?;
            val.push(list_elem_164);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionWithAuthArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionWithAuthArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionWithAuthArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionWithAuthArgs.user_name", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionWithAuthArgs.group_names", &f_5)?;
    let ret = ThriftHiveMetastoreGetPartitionWithAuthArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      group_names: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_with_auth_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user_name", TType::String, 4))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group_names", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_names.len() as i32))?;
    for e in &self.group_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionWithAuthResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionWithAuthResult {
  result_value: Option<Partition>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionWithAuthResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionWithAuthResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionWithAuthResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionWithAuthResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionWithAuth"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionByNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionByNameArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
}

impl ThriftHiveMetastoreGetPartitionByNameArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionByNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionByNameArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionByNameArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionByNameArgs.part_name", &f_3)?;
    let ret = ThriftHiveMetastoreGetPartitionByNameArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_by_name_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionByNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionByNameResult {
  result_value: Option<Partition>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionByNameResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionByNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Partition> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionByNameResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionByNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Partition> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionByName"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsArgs {
  db_name: String,
  tbl_name: String,
  max_parts: i16,
}

impl ThriftHiveMetastoreGetPartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsArgs.max_parts", &f_3)?;
    let ret = ThriftHiveMetastoreGetPartitionsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 3))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPartitionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_165 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_165);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitions"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsWithAuthArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsWithAuthArgs {
  db_name: String,
  tbl_name: String,
  max_parts: i16,
  user_name: String,
  group_names: Vec<String>,
}

impl ThriftHiveMetastoreGetPartitionsWithAuthArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsWithAuthArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i16> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_166 = i_prot.read_string()?;
            val.push(list_elem_166);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsWithAuthArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsWithAuthArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsWithAuthArgs.max_parts", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsWithAuthArgs.user_name", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsWithAuthArgs.group_names", &f_5)?;
    let ret = ThriftHiveMetastoreGetPartitionsWithAuthArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      group_names: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_with_auth_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 3))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user_name", TType::String, 4))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group_names", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_names.len() as i32))?;
    for e in &self.group_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsWithAuthResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsWithAuthResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPartitionsWithAuthResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsWithAuthResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_167 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_167);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsWithAuthResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsWithAuthResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsWithAuth"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsPspecArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsPspecArgs {
  db_name: String,
  tbl_name: String,
  max_parts: i32,
}

impl ThriftHiveMetastoreGetPartitionsPspecArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsPspecArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPspecArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPspecArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPspecArgs.max_parts", &f_3)?;
    let ret = ThriftHiveMetastoreGetPartitionsPspecArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_pspec_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I32, 3))?;
    o_prot.write_i32(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsPspecResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsPspecResult {
  result_value: Option<Vec<PartitionSpec>>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPartitionsPspecResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsPspecResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<PartitionSpec>> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PartitionSpec> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_168 = PartitionSpec::read_from_in_protocol(i_prot)?;
            val.push(list_elem_168);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsPspecResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsPspecResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<PartitionSpec>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsPspec"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionNamesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionNamesArgs {
  db_name: String,
  tbl_name: String,
  max_parts: i16,
}

impl ThriftHiveMetastoreGetPartitionNamesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionNamesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i16()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesArgs.max_parts", &f_3)?;
    let ret = ThriftHiveMetastoreGetPartitionNamesArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_names_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 3))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionNamesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionNamesResult {
  result_value: Option<Vec<String>>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPartitionNamesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionNamesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_169 = i_prot.read_string()?;
            val.push(list_elem_169);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionNamesResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionNamesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionNames"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionValuesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionValuesArgs {
  request: PartitionValuesRequest,
}

impl ThriftHiveMetastoreGetPartitionValuesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionValuesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PartitionValuesRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PartitionValuesRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionValuesArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetPartitionValuesArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_values_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionValuesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionValuesResult {
  result_value: Option<PartitionValuesResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionValuesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionValuesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PartitionValuesResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PartitionValuesResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionValuesResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionValuesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PartitionValuesResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionValues"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsPsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsPsArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  max_parts: i16,
}

impl ThriftHiveMetastoreGetPartitionsPsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsPsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_170 = i_prot.read_string()?;
            val.push(list_elem_170);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsArgs.max_parts", &f_4)?;
    let ret = ThriftHiveMetastoreGetPartitionsPsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_ps_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 4))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsPsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsPsResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionsPsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsPsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_171 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_171);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsPsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsPsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsPs"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsPsWithAuthArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsPsWithAuthArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  max_parts: i16,
  user_name: String,
  group_names: Vec<String>,
}

impl ThriftHiveMetastoreGetPartitionsPsWithAuthArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsPsWithAuthArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<i16> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_172 = i_prot.read_string()?;
            val.push(list_elem_172);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_173 = i_prot.read_string()?;
            val.push(list_elem_173);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsWithAuthArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsWithAuthArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsWithAuthArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsWithAuthArgs.max_parts", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsWithAuthArgs.user_name", &f_5)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsPsWithAuthArgs.group_names", &f_6)?;
    let ret = ThriftHiveMetastoreGetPartitionsPsWithAuthArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_4.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_5.expect("auto-generated code should have checked for presence of required fields"),
      group_names: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_ps_with_auth_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 4))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user_name", TType::String, 5))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group_names", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_names.len() as i32))?;
    for e in &self.group_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsPsWithAuthResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsPsWithAuthResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPartitionsPsWithAuthResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsPsWithAuthResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_174 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_174);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsPsWithAuthResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsPsWithAuthResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsPsWithAuth"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionNamesPsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionNamesPsArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  max_parts: i16,
}

impl ThriftHiveMetastoreGetPartitionNamesPsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionNamesPsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_175 = i_prot.read_string()?;
            val.push(list_elem_175);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesPsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesPsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesPsArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionNamesPsArgs.max_parts", &f_4)?;
    let ret = ThriftHiveMetastoreGetPartitionNamesPsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_names_ps_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 4))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionNamesPsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionNamesPsResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionNamesPsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionNamesPsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_176 = i_prot.read_string()?;
            val.push(list_elem_176);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionNamesPsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionNamesPsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionNamesPs"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsByFilterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsByFilterArgs {
  db_name: String,
  tbl_name: String,
  filter: String,
  max_parts: i16,
}

impl ThriftHiveMetastoreGetPartitionsByFilterArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsByFilterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByFilterArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByFilterArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByFilterArgs.filter", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByFilterArgs.max_parts", &f_4)?;
    let ret = ThriftHiveMetastoreGetPartitionsByFilterArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_by_filter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::String, 3))?;
    o_prot.write_string(&self.filter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I16, 4))?;
    o_prot.write_i16(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsByFilterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsByFilterResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionsByFilterResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsByFilterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_177 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_177);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsByFilterResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsByFilterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsByFilter"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartSpecsByFilterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartSpecsByFilterArgs {
  db_name: String,
  tbl_name: String,
  filter: String,
  max_parts: i32,
}

impl ThriftHiveMetastoreGetPartSpecsByFilterArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartSpecsByFilterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartSpecsByFilterArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartSpecsByFilterArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartSpecsByFilterArgs.filter", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartSpecsByFilterArgs.max_parts", &f_4)?;
    let ret = ThriftHiveMetastoreGetPartSpecsByFilterArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_parts: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_part_specs_by_filter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::String, 3))?;
    o_prot.write_string(&self.filter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_parts", TType::I32, 4))?;
    o_prot.write_i32(self.max_parts)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartSpecsByFilterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartSpecsByFilterResult {
  result_value: Option<Vec<PartitionSpec>>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartSpecsByFilterResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartSpecsByFilterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<PartitionSpec>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PartitionSpec> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_178 = PartitionSpec::read_from_in_protocol(i_prot)?;
            val.push(list_elem_178);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartSpecsByFilterResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartSpecsByFilterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<PartitionSpec>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartSpecsByFilter"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsByExprArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsByExprArgs {
  req: PartitionsByExprRequest,
}

impl ThriftHiveMetastoreGetPartitionsByExprArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsByExprArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PartitionsByExprRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PartitionsByExprRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByExprArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreGetPartitionsByExprArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_by_expr_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsByExprResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsByExprResult {
  result_value: Option<PartitionsByExprResult>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionsByExprResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsByExprResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PartitionsByExprResult> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PartitionsByExprResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsByExprResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsByExprResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PartitionsByExprResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsByExpr"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetNumPartitionsByFilterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNumPartitionsByFilterArgs {
  db_name: String,
  tbl_name: String,
  filter: String,
}

impl ThriftHiveMetastoreGetNumPartitionsByFilterArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNumPartitionsByFilterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetNumPartitionsByFilterArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetNumPartitionsByFilterArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetNumPartitionsByFilterArgs.filter", &f_3)?;
    let ret = ThriftHiveMetastoreGetNumPartitionsByFilterArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      filter: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_num_partitions_by_filter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter", TType::String, 3))?;
    o_prot.write_string(&self.filter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetNumPartitionsByFilterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNumPartitionsByFilterResult {
  result_value: Option<i32>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetNumPartitionsByFilterResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNumPartitionsByFilterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetNumPartitionsByFilterResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetNumPartitionsByFilterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetNumPartitionsByFilter"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsByNamesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsByNamesArgs {
  db_name: String,
  tbl_name: String,
  names: Vec<String>,
}

impl ThriftHiveMetastoreGetPartitionsByNamesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsByNamesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_179 = i_prot.read_string()?;
            val.push(list_elem_179);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByNamesArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByNamesArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsByNamesArgs.names", &f_3)?;
    let ret = ThriftHiveMetastoreGetPartitionsByNamesArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      names: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_by_names_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("names", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.names.len() as i32))?;
    for e in &self.names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsByNamesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsByNamesResult {
  result_value: Option<Vec<Partition>>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPartitionsByNamesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsByNamesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Partition>> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_180 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_180);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsByNamesResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsByNamesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Partition>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsByNames"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAlterPartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionArgs {
  db_name: String,
  tbl_name: String,
  new_part: Partition,
}

impl ThriftHiveMetastoreAlterPartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Partition> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionArgs.new_part", &f_3)?;
    let ret = ThriftHiveMetastoreAlterPartitionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_part: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_part", TType::Struct, 3))?;
    self.new_part.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterPartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterPartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterPartitionResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterPartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterPartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionsArgs {
  db_name: String,
  tbl_name: String,
  new_parts: Vec<Partition>,
}

impl ThriftHiveMetastoreAlterPartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Partition>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_181 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_181);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsArgs.new_parts", &f_3)?;
    let ret = ThriftHiveMetastoreAlterPartitionsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_partitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_parts", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.new_parts.len() as i32))?;
    for e in &self.new_parts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionsResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterPartitionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterPartitionsResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs {
  db_name: String,
  tbl_name: String,
  new_parts: Vec<Partition>,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Partition>> = None;
    let mut f_4: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Partition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_182 = Partition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_182);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs.new_parts", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs.environment_context", &f_4)?;
    let ret = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_parts: f_3.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_partitions_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_parts", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.new_parts.len() as i32))?;
    for e in &self.new_parts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 4))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterPartitionsWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs {
  db_name: String,
  tbl_name: String,
  new_part: Partition,
  environment_context: EnvironmentContext,
}

impl ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Partition> = None;
    let mut f_4: Option<EnvironmentContext> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = EnvironmentContext::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs.new_part", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs.environment_context", &f_4)?;
    let ret = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_part: f_3.expect("auto-generated code should have checked for presence of required fields"),
      environment_context: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_partition_with_environment_context_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_part", TType::Struct, 3))?;
    self.new_part.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("environment_context", TType::Struct, 4))?;
    self.environment_context.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterPartitionWithEnvironmentContextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreRenamePartitionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRenamePartitionArgs {
  db_name: String,
  tbl_name: String,
  part_vals: Vec<String>,
  new_part: Partition,
}

impl ThriftHiveMetastoreRenamePartitionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRenamePartitionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Partition> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_183 = i_prot.read_string()?;
            val.push(list_elem_183);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Partition::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRenamePartitionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreRenamePartitionArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreRenamePartitionArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreRenamePartitionArgs.new_part", &f_4)?;
    let ret = ThriftHiveMetastoreRenamePartitionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      new_part: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("rename_partition_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("new_part", TType::Struct, 4))?;
    self.new_part.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRenamePartitionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRenamePartitionResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreRenamePartitionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRenamePartitionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRenamePartitionResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRenamePartitionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastorePartitionNameHasValidCharactersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePartitionNameHasValidCharactersArgs {
  part_vals: Vec<String>,
  throw_exception: bool,
}

impl ThriftHiveMetastorePartitionNameHasValidCharactersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePartitionNameHasValidCharactersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_184 = i_prot.read_string()?;
            val.push(list_elem_184);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastorePartitionNameHasValidCharactersArgs.part_vals", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastorePartitionNameHasValidCharactersArgs.throw_exception", &f_2)?;
    let ret = ThriftHiveMetastorePartitionNameHasValidCharactersArgs {
      part_vals: f_1.expect("auto-generated code should have checked for presence of required fields"),
      throw_exception: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("partition_name_has_valid_characters_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.part_vals.len() as i32))?;
    for e in &self.part_vals {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("throw_exception", TType::Bool, 2))?;
    o_prot.write_bool(self.throw_exception)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastorePartitionNameHasValidCharactersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePartitionNameHasValidCharactersResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastorePartitionNameHasValidCharactersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePartitionNameHasValidCharactersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastorePartitionNameHasValidCharactersResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastorePartitionNameHasValidCharactersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastorePartitionNameHasValidCharacters"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetConfigValueArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetConfigValueArgs {
  name: String,
  default_value: String,
}

impl ThriftHiveMetastoreGetConfigValueArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetConfigValueArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetConfigValueArgs.name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetConfigValueArgs.default_value", &f_2)?;
    let ret = ThriftHiveMetastoreGetConfigValueArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      default_value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_config_value_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("defaultValue", TType::String, 2))?;
    o_prot.write_string(&self.default_value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetConfigValueResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetConfigValueResult {
  result_value: Option<String>,
  o1: Option<ConfigValSecurityException>,
}

impl ThriftHiveMetastoreGetConfigValueResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetConfigValueResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<ConfigValSecurityException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = ConfigValSecurityException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetConfigValueResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetConfigValueResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetConfigValue"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastorePartitionNameToValsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePartitionNameToValsArgs {
  part_name: String,
}

impl ThriftHiveMetastorePartitionNameToValsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePartitionNameToValsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastorePartitionNameToValsArgs.part_name", &f_1)?;
    let ret = ThriftHiveMetastorePartitionNameToValsArgs {
      part_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("partition_name_to_vals_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 1))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastorePartitionNameToValsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePartitionNameToValsResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastorePartitionNameToValsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePartitionNameToValsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_185 = i_prot.read_string()?;
            val.push(list_elem_185);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastorePartitionNameToValsResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastorePartitionNameToValsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastorePartitionNameToVals"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastorePartitionNameToSpecArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePartitionNameToSpecArgs {
  part_name: String,
}

impl ThriftHiveMetastorePartitionNameToSpecArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePartitionNameToSpecArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastorePartitionNameToSpecArgs.part_name", &f_1)?;
    let ret = ThriftHiveMetastorePartitionNameToSpecArgs {
      part_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("partition_name_to_spec_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 1))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastorePartitionNameToSpecResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePartitionNameToSpecResult {
  result_value: Option<BTreeMap<String, String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastorePartitionNameToSpecResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePartitionNameToSpecResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_186 = i_prot.read_string()?;
            let map_val_187 = i_prot.read_string()?;
            val.insert(map_key_186, map_val_187);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastorePartitionNameToSpecResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastorePartitionNameToSpecResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastorePartitionNameToSpec"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreMarkPartitionForEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreMarkPartitionForEventArgs {
  db_name: String,
  tbl_name: String,
  part_vals: BTreeMap<String, String>,
  event_type: PartitionEventType,
}

impl ThriftHiveMetastoreMarkPartitionForEventArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreMarkPartitionForEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    let mut f_4: Option<PartitionEventType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_188 = i_prot.read_string()?;
            let map_val_189 = i_prot.read_string()?;
            val.insert(map_key_188, map_val_189);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = PartitionEventType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreMarkPartitionForEventArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreMarkPartitionForEventArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreMarkPartitionForEventArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreMarkPartitionForEventArgs.event_type", &f_4)?;
    let ret = ThriftHiveMetastoreMarkPartitionForEventArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("markPartitionForEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.part_vals.len() as i32))?;
    for (k, v) in &self.part_vals {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::I32, 4))?;
    self.event_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreMarkPartitionForEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreMarkPartitionForEventResult {
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<UnknownDBException>,
  o4: Option<UnknownTableException>,
  o5: Option<UnknownPartitionException>,
  o6: Option<InvalidPartitionException>,
}

impl ThriftHiveMetastoreMarkPartitionForEventResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreMarkPartitionForEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    let mut f_4: Option<UnknownTableException> = None;
    let mut f_5: Option<UnknownPartitionException> = None;
    let mut f_6: Option<InvalidPartitionException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = UnknownTableException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = UnknownPartitionException::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = InvalidPartitionException::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreMarkPartitionForEventResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
      o5: f_5,
      o6: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreMarkPartitionForEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o5 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o5", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o6 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o6", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.o5.is_some() {
      Err(thrift::Error::User(Box::new(self.o5.unwrap())))
    } else if self.o6.is_some() {
      Err(thrift::Error::User(Box::new(self.o6.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreIsPartitionMarkedForEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreIsPartitionMarkedForEventArgs {
  db_name: String,
  tbl_name: String,
  part_vals: BTreeMap<String, String>,
  event_type: PartitionEventType,
}

impl ThriftHiveMetastoreIsPartitionMarkedForEventArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreIsPartitionMarkedForEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    let mut f_4: Option<PartitionEventType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_190 = i_prot.read_string()?;
            let map_val_191 = i_prot.read_string()?;
            val.insert(map_key_190, map_val_191);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = PartitionEventType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreIsPartitionMarkedForEventArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreIsPartitionMarkedForEventArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreIsPartitionMarkedForEventArgs.part_vals", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreIsPartitionMarkedForEventArgs.event_type", &f_4)?;
    let ret = ThriftHiveMetastoreIsPartitionMarkedForEventArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_vals: f_3.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("isPartitionMarkedForEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_vals", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.part_vals.len() as i32))?;
    for (k, v) in &self.part_vals {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::I32, 4))?;
    self.event_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreIsPartitionMarkedForEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreIsPartitionMarkedForEventResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<UnknownDBException>,
  o4: Option<UnknownTableException>,
  o5: Option<UnknownPartitionException>,
  o6: Option<InvalidPartitionException>,
}

impl ThriftHiveMetastoreIsPartitionMarkedForEventResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreIsPartitionMarkedForEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<UnknownDBException> = None;
    let mut f_4: Option<UnknownTableException> = None;
    let mut f_5: Option<UnknownPartitionException> = None;
    let mut f_6: Option<InvalidPartitionException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = UnknownDBException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = UnknownTableException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = UnknownPartitionException::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = InvalidPartitionException::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreIsPartitionMarkedForEventResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
      o5: f_5,
      o6: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreIsPartitionMarkedForEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o5 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o5", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o6 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o6", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.o5.is_some() {
      Err(thrift::Error::User(Box::new(self.o5.unwrap())))
    } else if self.o6.is_some() {
      Err(thrift::Error::User(Box::new(self.o6.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreIsPartitionMarkedForEvent"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPrimaryKeysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPrimaryKeysArgs {
  request: PrimaryKeysRequest,
}

impl ThriftHiveMetastoreGetPrimaryKeysArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPrimaryKeysArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PrimaryKeysRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PrimaryKeysRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPrimaryKeysArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetPrimaryKeysArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_primary_keys_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPrimaryKeysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPrimaryKeysResult {
  result_value: Option<PrimaryKeysResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetPrimaryKeysResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPrimaryKeysResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PrimaryKeysResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PrimaryKeysResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPrimaryKeysResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPrimaryKeysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PrimaryKeysResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPrimaryKeys"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetForeignKeysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetForeignKeysArgs {
  request: ForeignKeysRequest,
}

impl ThriftHiveMetastoreGetForeignKeysArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetForeignKeysArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ForeignKeysRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ForeignKeysRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetForeignKeysArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetForeignKeysArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_foreign_keys_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetForeignKeysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetForeignKeysResult {
  result_value: Option<ForeignKeysResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetForeignKeysResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetForeignKeysResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ForeignKeysResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ForeignKeysResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetForeignKeysResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetForeignKeysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ForeignKeysResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetForeignKeys"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetUniqueConstraintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetUniqueConstraintsArgs {
  request: UniqueConstraintsRequest,
}

impl ThriftHiveMetastoreGetUniqueConstraintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetUniqueConstraintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UniqueConstraintsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = UniqueConstraintsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetUniqueConstraintsArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetUniqueConstraintsArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_unique_constraints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetUniqueConstraintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetUniqueConstraintsResult {
  result_value: Option<UniqueConstraintsResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetUniqueConstraintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetUniqueConstraintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<UniqueConstraintsResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = UniqueConstraintsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetUniqueConstraintsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetUniqueConstraintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<UniqueConstraintsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetUniqueConstraints"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetNotNullConstraintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNotNullConstraintsArgs {
  request: NotNullConstraintsRequest,
}

impl ThriftHiveMetastoreGetNotNullConstraintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNotNullConstraintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NotNullConstraintsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NotNullConstraintsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetNotNullConstraintsArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetNotNullConstraintsArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_not_null_constraints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetNotNullConstraintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNotNullConstraintsResult {
  result_value: Option<NotNullConstraintsResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetNotNullConstraintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNotNullConstraintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NotNullConstraintsResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NotNullConstraintsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetNotNullConstraintsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetNotNullConstraintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NotNullConstraintsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetNotNullConstraints"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetDefaultConstraintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDefaultConstraintsArgs {
  request: DefaultConstraintsRequest,
}

impl ThriftHiveMetastoreGetDefaultConstraintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDefaultConstraintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<DefaultConstraintsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = DefaultConstraintsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetDefaultConstraintsArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetDefaultConstraintsArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_default_constraints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetDefaultConstraintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDefaultConstraintsResult {
  result_value: Option<DefaultConstraintsResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetDefaultConstraintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDefaultConstraintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<DefaultConstraintsResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = DefaultConstraintsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetDefaultConstraintsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetDefaultConstraintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<DefaultConstraintsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetDefaultConstraints"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetCheckConstraintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCheckConstraintsArgs {
  request: CheckConstraintsRequest,
}

impl ThriftHiveMetastoreGetCheckConstraintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCheckConstraintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CheckConstraintsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CheckConstraintsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetCheckConstraintsArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetCheckConstraintsArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_check_constraints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetCheckConstraintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCheckConstraintsResult {
  result_value: Option<CheckConstraintsResponse>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetCheckConstraintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCheckConstraintsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CheckConstraintsResponse> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CheckConstraintsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetCheckConstraintsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetCheckConstraintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CheckConstraintsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetCheckConstraints"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreUpdateTableColumnStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdateTableColumnStatisticsArgs {
  stats_obj: ColumnStatistics,
}

impl ThriftHiveMetastoreUpdateTableColumnStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdateTableColumnStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ColumnStatistics> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ColumnStatistics::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateTableColumnStatisticsArgs.stats_obj", &f_1)?;
    let ret = ThriftHiveMetastoreUpdateTableColumnStatisticsArgs {
      stats_obj: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_table_column_statistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stats_obj", TType::Struct, 1))?;
    self.stats_obj.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreUpdateTableColumnStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdateTableColumnStatisticsResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreUpdateTableColumnStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdateTableColumnStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreUpdateTableColumnStatisticsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreUpdateTableColumnStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreUpdateTableColumnStatistics"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs {
  stats_obj: ColumnStatistics,
}

impl ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ColumnStatistics> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ColumnStatistics::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs.stats_obj", &f_1)?;
    let ret = ThriftHiveMetastoreUpdatePartitionColumnStatisticsArgs {
      stats_obj: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_partition_column_statistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stats_obj", TType::Struct, 1))?;
    self.stats_obj.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreUpdatePartitionColumnStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreUpdatePartitionColumnStatistics"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableColumnStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableColumnStatisticsArgs {
  db_name: String,
  tbl_name: String,
  col_name: String,
}

impl ThriftHiveMetastoreGetTableColumnStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableColumnStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableColumnStatisticsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableColumnStatisticsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableColumnStatisticsArgs.col_name", &f_3)?;
    let ret = ThriftHiveMetastoreGetTableColumnStatisticsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      col_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_column_statistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 3))?;
    o_prot.write_string(&self.col_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableColumnStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableColumnStatisticsResult {
  result_value: Option<ColumnStatistics>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
  o3: Option<InvalidInputException>,
  o4: Option<InvalidObjectException>,
}

impl ThriftHiveMetastoreGetTableColumnStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableColumnStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ColumnStatistics> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    let mut f_3: Option<InvalidInputException> = None;
    let mut f_4: Option<InvalidObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ColumnStatistics::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableColumnStatisticsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableColumnStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ColumnStatistics> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableColumnStatistics"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionColumnStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionColumnStatisticsArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
  col_name: String,
}

impl ThriftHiveMetastoreGetPartitionColumnStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionColumnStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionColumnStatisticsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionColumnStatisticsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionColumnStatisticsArgs.part_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionColumnStatisticsArgs.col_name", &f_4)?;
    let ret = ThriftHiveMetastoreGetPartitionColumnStatisticsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      col_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partition_column_statistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 4))?;
    o_prot.write_string(&self.col_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionColumnStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionColumnStatisticsResult {
  result_value: Option<ColumnStatistics>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
  o3: Option<InvalidInputException>,
  o4: Option<InvalidObjectException>,
}

impl ThriftHiveMetastoreGetPartitionColumnStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionColumnStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ColumnStatistics> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    let mut f_3: Option<InvalidInputException> = None;
    let mut f_4: Option<InvalidObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ColumnStatistics::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionColumnStatisticsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionColumnStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ColumnStatistics> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionColumnStatistics"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTableStatisticsReqArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableStatisticsReqArgs {
  request: TableStatsRequest,
}

impl ThriftHiveMetastoreGetTableStatisticsReqArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableStatisticsReqArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TableStatsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TableStatsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTableStatisticsReqArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetTableStatisticsReqArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_statistics_req_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTableStatisticsReqResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTableStatisticsReqResult {
  result_value: Option<TableStatsResult>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetTableStatisticsReqResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTableStatisticsReqResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TableStatsResult> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TableStatsResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTableStatisticsReqResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTableStatisticsReqResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TableStatsResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTableStatisticsReq"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPartitionsStatisticsReqArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsStatisticsReqArgs {
  request: PartitionsStatsRequest,
}

impl ThriftHiveMetastoreGetPartitionsStatisticsReqArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsStatisticsReqArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PartitionsStatsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PartitionsStatsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPartitionsStatisticsReqArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetPartitionsStatisticsReqArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_partitions_statistics_req_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPartitionsStatisticsReqResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPartitionsStatisticsReqResult {
  result_value: Option<PartitionsStatsResult>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPartitionsStatisticsReqResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPartitionsStatisticsReqResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PartitionsStatsResult> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PartitionsStatsResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPartitionsStatisticsReqResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPartitionsStatisticsReqResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PartitionsStatsResult> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPartitionsStatisticsReq"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetAggrStatsForArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAggrStatsForArgs {
  request: PartitionsStatsRequest,
}

impl ThriftHiveMetastoreGetAggrStatsForArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAggrStatsForArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PartitionsStatsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PartitionsStatsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetAggrStatsForArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetAggrStatsForArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_aggr_stats_for_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetAggrStatsForResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAggrStatsForResult {
  result_value: Option<AggrStats>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetAggrStatsForResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAggrStatsForResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AggrStats> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AggrStats::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAggrStatsForResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetAggrStatsForResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AggrStats> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetAggrStatsFor"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreSetAggrStatsForArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetAggrStatsForArgs {
  request: SetPartitionsStatsRequest,
}

impl ThriftHiveMetastoreSetAggrStatsForArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetAggrStatsForArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SetPartitionsStatsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SetPartitionsStatsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreSetAggrStatsForArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreSetAggrStatsForArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_aggr_stats_for_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreSetAggrStatsForResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetAggrStatsForResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreSetAggrStatsForResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetAggrStatsForResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreSetAggrStatsForResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreSetAggrStatsForResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreSetAggrStatsFor"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs {
  db_name: String,
  tbl_name: String,
  part_name: String,
  col_name: String,
}

impl ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs.part_name", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs.col_name", &f_4)?;
    let ret = ThriftHiveMetastoreDeletePartitionColumnStatisticsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      part_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      col_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_partition_column_statistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("part_name", TType::String, 3))?;
    o_prot.write_string(&self.part_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 4))?;
    o_prot.write_string(&self.col_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDeletePartitionColumnStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDeletePartitionColumnStatisticsResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
  o3: Option<InvalidObjectException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreDeletePartitionColumnStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDeletePartitionColumnStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDeletePartitionColumnStatisticsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDeletePartitionColumnStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDeletePartitionColumnStatistics"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDeleteTableColumnStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDeleteTableColumnStatisticsArgs {
  db_name: String,
  tbl_name: String,
  col_name: String,
}

impl ThriftHiveMetastoreDeleteTableColumnStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDeleteTableColumnStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDeleteTableColumnStatisticsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDeleteTableColumnStatisticsArgs.tbl_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreDeleteTableColumnStatisticsArgs.col_name", &f_3)?;
    let ret = ThriftHiveMetastoreDeleteTableColumnStatisticsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tbl_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      col_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("delete_table_column_statistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
    o_prot.write_string(&self.tbl_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 3))?;
    o_prot.write_string(&self.col_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDeleteTableColumnStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDeleteTableColumnStatisticsResult {
  result_value: Option<bool>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
  o3: Option<InvalidObjectException>,
  o4: Option<InvalidInputException>,
}

impl ThriftHiveMetastoreDeleteTableColumnStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDeleteTableColumnStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<InvalidInputException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = InvalidInputException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDeleteTableColumnStatisticsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDeleteTableColumnStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDeleteTableColumnStatistics"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateFunctionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateFunctionArgs {
  func: Function,
}

impl ThriftHiveMetastoreCreateFunctionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateFunctionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Function> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Function::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateFunctionArgs.func", &f_1)?;
    let ret = ThriftHiveMetastoreCreateFunctionArgs {
      func: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_function_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("func", TType::Struct, 1))?;
    self.func.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateFunctionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateFunctionResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
  o4: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreCreateFunctionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateFunctionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    let mut f_4: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateFunctionResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateFunctionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreDropFunctionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropFunctionArgs {
  db_name: String,
  func_name: String,
}

impl ThriftHiveMetastoreDropFunctionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropFunctionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropFunctionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreDropFunctionArgs.func_name", &f_2)?;
    let ret = ThriftHiveMetastoreDropFunctionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      func_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_function_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("funcName", TType::String, 2))?;
    o_prot.write_string(&self.func_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropFunctionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropFunctionResult {
  o1: Option<NoSuchObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropFunctionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropFunctionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropFunctionResult {
      o1: f_1,
      o3: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropFunctionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterFunctionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterFunctionArgs {
  db_name: String,
  func_name: String,
  new_func: Function,
}

impl ThriftHiveMetastoreAlterFunctionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterFunctionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Function> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Function::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterFunctionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterFunctionArgs.func_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreAlterFunctionArgs.new_func", &f_3)?;
    let ret = ThriftHiveMetastoreAlterFunctionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      func_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_func: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_function_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("funcName", TType::String, 2))?;
    o_prot.write_string(&self.func_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("newFunc", TType::Struct, 3))?;
    self.new_func.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterFunctionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterFunctionResult {
  o1: Option<InvalidOperationException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterFunctionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterFunctionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<InvalidOperationException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterFunctionResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterFunctionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetFunctionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFunctionsArgs {
  db_name: String,
  pattern: String,
}

impl ThriftHiveMetastoreGetFunctionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFunctionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetFunctionsArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetFunctionsArgs.pattern", &f_2)?;
    let ret = ThriftHiveMetastoreGetFunctionsArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pattern: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_functions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pattern", TType::String, 2))?;
    o_prot.write_string(&self.pattern)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetFunctionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFunctionsResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetFunctionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFunctionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_192 = i_prot.read_string()?;
            val.push(list_elem_192);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetFunctionsResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetFunctionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetFunctions"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetFunctionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFunctionArgs {
  db_name: String,
  func_name: String,
}

impl ThriftHiveMetastoreGetFunctionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFunctionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetFunctionArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetFunctionArgs.func_name", &f_2)?;
    let ret = ThriftHiveMetastoreGetFunctionArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      func_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_function_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("funcName", TType::String, 2))?;
    o_prot.write_string(&self.func_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetFunctionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFunctionResult {
  result_value: Option<Function>,
  o1: Option<MetaException>,
  o2: Option<NoSuchObjectException>,
}

impl ThriftHiveMetastoreGetFunctionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFunctionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Function> = None;
    let mut f_1: Option<MetaException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Function::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetFunctionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetFunctionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Function> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetFunction"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetAllFunctionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllFunctionsArgs {
}

impl ThriftHiveMetastoreGetAllFunctionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllFunctionsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllFunctionsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_functions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetAllFunctionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllFunctionsResult {
  result_value: Option<GetAllFunctionsResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetAllFunctionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllFunctionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetAllFunctionsResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetAllFunctionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllFunctionsResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetAllFunctionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetAllFunctionsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetAllFunctions"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateRoleArgs {
  role: Role,
}

impl ThriftHiveMetastoreCreateRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Role> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Role::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateRoleArgs.role", &f_1)?;
    let ret = ThriftHiveMetastoreCreateRoleArgs {
      role: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::Struct, 1))?;
    self.role.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateRoleResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateRoleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateRole"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropRoleArgs {
  role_name: String,
}

impl ThriftHiveMetastoreDropRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropRoleArgs.role_name", &f_1)?;
    let ret = ThriftHiveMetastoreDropRoleArgs {
      role_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role_name", TType::String, 1))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropRoleResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreDropRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropRoleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropRole"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetRoleNamesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetRoleNamesArgs {
}

impl ThriftHiveMetastoreGetRoleNamesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetRoleNamesArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetRoleNamesArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_role_names_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetRoleNamesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetRoleNamesResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetRoleNamesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetRoleNamesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_193 = i_prot.read_string()?;
            val.push(list_elem_193);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetRoleNamesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetRoleNamesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetRoleNames"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGrantRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantRoleArgs {
  role_name: String,
  principal_name: String,
  principal_type: PrincipalType,
  grantor: String,
  grantor_type: PrincipalType,
  grant_option: bool,
}

impl ThriftHiveMetastoreGrantRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<PrincipalType> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<PrincipalType> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRoleArgs.role_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRoleArgs.principal_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRoleArgs.principal_type", &f_3)?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRoleArgs.grantor", &f_4)?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRoleArgs.grantor_type", &f_5)?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRoleArgs.grant_option", &f_6)?;
    let ret = ThriftHiveMetastoreGrantRoleArgs {
      role_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      principal_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      principal_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      grantor: f_4.expect("auto-generated code should have checked for presence of required fields"),
      grantor_type: f_5.expect("auto-generated code should have checked for presence of required fields"),
      grant_option: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("grant_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role_name", TType::String, 1))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_name", TType::String, 2))?;
    o_prot.write_string(&self.principal_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_type", TType::I32, 3))?;
    self.principal_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grantor", TType::String, 4))?;
    o_prot.write_string(&self.grantor)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grantorType", TType::I32, 5))?;
    self.grantor_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grant_option", TType::Bool, 6))?;
    o_prot.write_bool(self.grant_option)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGrantRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantRoleResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGrantRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGrantRoleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGrantRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGrantRole"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreRevokeRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRevokeRoleArgs {
  role_name: String,
  principal_name: String,
  principal_type: PrincipalType,
}

impl ThriftHiveMetastoreRevokeRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRevokeRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<PrincipalType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRevokeRoleArgs.role_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreRevokeRoleArgs.principal_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreRevokeRoleArgs.principal_type", &f_3)?;
    let ret = ThriftHiveMetastoreRevokeRoleArgs {
      role_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      principal_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      principal_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("revoke_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role_name", TType::String, 1))?;
    o_prot.write_string(&self.role_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_name", TType::String, 2))?;
    o_prot.write_string(&self.principal_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_type", TType::I32, 3))?;
    self.principal_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRevokeRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRevokeRoleResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreRevokeRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRevokeRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRevokeRoleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRevokeRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreRevokeRole"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreListRolesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreListRolesArgs {
  principal_name: String,
  principal_type: PrincipalType,
}

impl ThriftHiveMetastoreListRolesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreListRolesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<PrincipalType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreListRolesArgs.principal_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreListRolesArgs.principal_type", &f_2)?;
    let ret = ThriftHiveMetastoreListRolesArgs {
      principal_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      principal_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("list_roles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_name", TType::String, 1))?;
    o_prot.write_string(&self.principal_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_type", TType::I32, 2))?;
    self.principal_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreListRolesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreListRolesResult {
  result_value: Option<Vec<Role>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreListRolesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreListRolesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<Role>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Role> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_194 = Role::read_from_in_protocol(i_prot)?;
            val.push(list_elem_194);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreListRolesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreListRolesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<Role>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreListRoles"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGrantRevokeRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantRevokeRoleArgs {
  request: GrantRevokeRoleRequest,
}

impl ThriftHiveMetastoreGrantRevokeRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantRevokeRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GrantRevokeRoleRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GrantRevokeRoleRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRevokeRoleArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGrantRevokeRoleArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("grant_revoke_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGrantRevokeRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantRevokeRoleResult {
  result_value: Option<GrantRevokeRoleResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGrantRevokeRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantRevokeRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GrantRevokeRoleResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GrantRevokeRoleResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGrantRevokeRoleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGrantRevokeRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GrantRevokeRoleResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGrantRevokeRole"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPrincipalsInRoleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPrincipalsInRoleArgs {
  request: GetPrincipalsInRoleRequest,
}

impl ThriftHiveMetastoreGetPrincipalsInRoleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPrincipalsInRoleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetPrincipalsInRoleRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetPrincipalsInRoleRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPrincipalsInRoleArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetPrincipalsInRoleArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_principals_in_role_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPrincipalsInRoleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPrincipalsInRoleResult {
  result_value: Option<GetPrincipalsInRoleResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPrincipalsInRoleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPrincipalsInRoleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetPrincipalsInRoleResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetPrincipalsInRoleResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPrincipalsInRoleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPrincipalsInRoleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetPrincipalsInRoleResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPrincipalsInRole"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs {
  request: GetRoleGrantsForPrincipalRequest,
}

impl ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetRoleGrantsForPrincipalRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetRoleGrantsForPrincipalRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetRoleGrantsForPrincipalArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_role_grants_for_principal_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetRoleGrantsForPrincipalResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetRoleGrantsForPrincipalResult {
  result_value: Option<GetRoleGrantsForPrincipalResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetRoleGrantsForPrincipalResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetRoleGrantsForPrincipalResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetRoleGrantsForPrincipalResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetRoleGrantsForPrincipalResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetRoleGrantsForPrincipalResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetRoleGrantsForPrincipalResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetRoleGrantsForPrincipalResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetRoleGrantsForPrincipal"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetPrivilegeSetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPrivilegeSetArgs {
  hive_object: HiveObjectRef,
  user_name: String,
  group_names: Vec<String>,
}

impl ThriftHiveMetastoreGetPrivilegeSetArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPrivilegeSetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<HiveObjectRef> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = HiveObjectRef::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_195 = i_prot.read_string()?;
            val.push(list_elem_195);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetPrivilegeSetArgs.hive_object", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPrivilegeSetArgs.user_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetPrivilegeSetArgs.group_names", &f_3)?;
    let ret = ThriftHiveMetastoreGetPrivilegeSetArgs {
      hive_object: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      group_names: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_privilege_set_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hiveObject", TType::Struct, 1))?;
    self.hive_object.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user_name", TType::String, 2))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group_names", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_names.len() as i32))?;
    for e in &self.group_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetPrivilegeSetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetPrivilegeSetResult {
  result_value: Option<PrincipalPrivilegeSet>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetPrivilegeSetResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetPrivilegeSetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PrincipalPrivilegeSet> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PrincipalPrivilegeSet::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetPrivilegeSetResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetPrivilegeSetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PrincipalPrivilegeSet> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetPrivilegeSet"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreListPrivilegesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreListPrivilegesArgs {
  principal_name: String,
  principal_type: PrincipalType,
  hive_object: HiveObjectRef,
}

impl ThriftHiveMetastoreListPrivilegesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreListPrivilegesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<PrincipalType> = None;
    let mut f_3: Option<HiveObjectRef> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = PrincipalType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = HiveObjectRef::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreListPrivilegesArgs.principal_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreListPrivilegesArgs.principal_type", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreListPrivilegesArgs.hive_object", &f_3)?;
    let ret = ThriftHiveMetastoreListPrivilegesArgs {
      principal_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      principal_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      hive_object: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("list_privileges_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_name", TType::String, 1))?;
    o_prot.write_string(&self.principal_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("principal_type", TType::I32, 2))?;
    self.principal_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hiveObject", TType::Struct, 3))?;
    self.hive_object.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreListPrivilegesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreListPrivilegesResult {
  result_value: Option<Vec<HiveObjectPrivilege>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreListPrivilegesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreListPrivilegesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<HiveObjectPrivilege>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<HiveObjectPrivilege> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_196 = HiveObjectPrivilege::read_from_in_protocol(i_prot)?;
            val.push(list_elem_196);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreListPrivilegesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreListPrivilegesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<HiveObjectPrivilege>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreListPrivileges"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGrantPrivilegesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantPrivilegesArgs {
  privileges: PrivilegeBag,
}

impl ThriftHiveMetastoreGrantPrivilegesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantPrivilegesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PrivilegeBag> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PrivilegeBag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGrantPrivilegesArgs.privileges", &f_1)?;
    let ret = ThriftHiveMetastoreGrantPrivilegesArgs {
      privileges: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("grant_privileges_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 1))?;
    self.privileges.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGrantPrivilegesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantPrivilegesResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGrantPrivilegesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantPrivilegesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGrantPrivilegesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGrantPrivilegesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGrantPrivileges"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreRevokePrivilegesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRevokePrivilegesArgs {
  privileges: PrivilegeBag,
}

impl ThriftHiveMetastoreRevokePrivilegesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRevokePrivilegesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PrivilegeBag> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PrivilegeBag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRevokePrivilegesArgs.privileges", &f_1)?;
    let ret = ThriftHiveMetastoreRevokePrivilegesArgs {
      privileges: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("revoke_privileges_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("privileges", TType::Struct, 1))?;
    self.privileges.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRevokePrivilegesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRevokePrivilegesResult {
  result_value: Option<bool>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreRevokePrivilegesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRevokePrivilegesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRevokePrivilegesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRevokePrivilegesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreRevokePrivileges"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGrantRevokePrivilegesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantRevokePrivilegesArgs {
  request: GrantRevokePrivilegeRequest,
}

impl ThriftHiveMetastoreGrantRevokePrivilegesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantRevokePrivilegesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GrantRevokePrivilegeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GrantRevokePrivilegeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGrantRevokePrivilegesArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGrantRevokePrivilegesArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("grant_revoke_privileges_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGrantRevokePrivilegesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGrantRevokePrivilegesResult {
  result_value: Option<GrantRevokePrivilegeResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGrantRevokePrivilegesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGrantRevokePrivilegesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GrantRevokePrivilegeResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GrantRevokePrivilegeResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGrantRevokePrivilegesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGrantRevokePrivilegesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GrantRevokePrivilegeResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGrantRevokePrivileges"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreRefreshPrivilegesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRefreshPrivilegesArgs {
  obj_to_refresh: HiveObjectRef,
  authorizer: String,
  grant_request: GrantRevokePrivilegeRequest,
}

impl ThriftHiveMetastoreRefreshPrivilegesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRefreshPrivilegesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<HiveObjectRef> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<GrantRevokePrivilegeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = HiveObjectRef::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = GrantRevokePrivilegeRequest::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRefreshPrivilegesArgs.obj_to_refresh", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreRefreshPrivilegesArgs.authorizer", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreRefreshPrivilegesArgs.grant_request", &f_3)?;
    let ret = ThriftHiveMetastoreRefreshPrivilegesArgs {
      obj_to_refresh: f_1.expect("auto-generated code should have checked for presence of required fields"),
      authorizer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      grant_request: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("refresh_privileges_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("objToRefresh", TType::Struct, 1))?;
    self.obj_to_refresh.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authorizer", TType::String, 2))?;
    o_prot.write_string(&self.authorizer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grantRequest", TType::Struct, 3))?;
    self.grant_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRefreshPrivilegesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRefreshPrivilegesResult {
  result_value: Option<GrantRevokePrivilegeResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreRefreshPrivilegesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRefreshPrivilegesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GrantRevokePrivilegeResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GrantRevokePrivilegeResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRefreshPrivilegesResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRefreshPrivilegesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GrantRevokePrivilegeResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreRefreshPrivileges"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreSetUgiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetUgiArgs {
  user_name: String,
  group_names: Vec<String>,
}

impl ThriftHiveMetastoreSetUgiArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetUgiArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_197 = i_prot.read_string()?;
            val.push(list_elem_197);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreSetUgiArgs.user_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreSetUgiArgs.group_names", &f_2)?;
    let ret = ThriftHiveMetastoreSetUgiArgs {
      user_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_names: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_ugi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user_name", TType::String, 1))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group_names", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.group_names.len() as i32))?;
    for e in &self.group_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreSetUgiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetUgiResult {
  result_value: Option<Vec<String>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreSetUgiResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetUgiResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_198 = i_prot.read_string()?;
            val.push(list_elem_198);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreSetUgiResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreSetUgiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreSetUgi"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetDelegationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDelegationTokenArgs {
  token_owner: String,
  renewer_kerberos_principal_name: String,
}

impl ThriftHiveMetastoreGetDelegationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDelegationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetDelegationTokenArgs.token_owner", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetDelegationTokenArgs.renewer_kerberos_principal_name", &f_2)?;
    let ret = ThriftHiveMetastoreGetDelegationTokenArgs {
      token_owner: f_1.expect("auto-generated code should have checked for presence of required fields"),
      renewer_kerberos_principal_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_delegation_token_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token_owner", TType::String, 1))?;
    o_prot.write_string(&self.token_owner)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("renewer_kerberos_principal_name", TType::String, 2))?;
    o_prot.write_string(&self.renewer_kerberos_principal_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetDelegationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetDelegationTokenResult {
  result_value: Option<String>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetDelegationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetDelegationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetDelegationTokenResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetDelegationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetDelegationToken"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreRenewDelegationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRenewDelegationTokenArgs {
  token_str_form: String,
}

impl ThriftHiveMetastoreRenewDelegationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRenewDelegationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRenewDelegationTokenArgs.token_str_form", &f_1)?;
    let ret = ThriftHiveMetastoreRenewDelegationTokenArgs {
      token_str_form: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("renew_delegation_token_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token_str_form", TType::String, 1))?;
    o_prot.write_string(&self.token_str_form)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRenewDelegationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRenewDelegationTokenResult {
  result_value: Option<i64>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreRenewDelegationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRenewDelegationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRenewDelegationTokenResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRenewDelegationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreRenewDelegationToken"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCancelDelegationTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCancelDelegationTokenArgs {
  token_str_form: String,
}

impl ThriftHiveMetastoreCancelDelegationTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCancelDelegationTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCancelDelegationTokenArgs.token_str_form", &f_1)?;
    let ret = ThriftHiveMetastoreCancelDelegationTokenArgs {
      token_str_form: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cancel_delegation_token_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token_str_form", TType::String, 1))?;
    o_prot.write_string(&self.token_str_form)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCancelDelegationTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCancelDelegationTokenResult {
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreCancelDelegationTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCancelDelegationTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCancelDelegationTokenResult {
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCancelDelegationTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddTokenArgs {
  token_identifier: String,
  delegation_token: String,
}

impl ThriftHiveMetastoreAddTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddTokenArgs.token_identifier", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreAddTokenArgs.delegation_token", &f_2)?;
    let ret = ThriftHiveMetastoreAddTokenArgs {
      token_identifier: f_1.expect("auto-generated code should have checked for presence of required fields"),
      delegation_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_token_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token_identifier", TType::String, 1))?;
    o_prot.write_string(&self.token_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("delegation_token", TType::String, 2))?;
    o_prot.write_string(&self.delegation_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddTokenResult {
  result_value: Option<bool>,
}

impl ThriftHiveMetastoreAddTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddToken"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreRemoveTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRemoveTokenArgs {
  token_identifier: String,
}

impl ThriftHiveMetastoreRemoveTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRemoveTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRemoveTokenArgs.token_identifier", &f_1)?;
    let ret = ThriftHiveMetastoreRemoveTokenArgs {
      token_identifier: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("remove_token_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token_identifier", TType::String, 1))?;
    o_prot.write_string(&self.token_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRemoveTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRemoveTokenResult {
  result_value: Option<bool>,
}

impl ThriftHiveMetastoreRemoveTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRemoveTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRemoveTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRemoveTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreRemoveToken"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTokenArgs {
  token_identifier: String,
}

impl ThriftHiveMetastoreGetTokenArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTokenArgs.token_identifier", &f_1)?;
    let ret = ThriftHiveMetastoreGetTokenArgs {
      token_identifier: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_token_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token_identifier", TType::String, 1))?;
    o_prot.write_string(&self.token_identifier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTokenResult {
  result_value: Option<String>,
}

impl ThriftHiveMetastoreGetTokenResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetToken"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetAllTokenIdentifiersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllTokenIdentifiersArgs {
}

impl ThriftHiveMetastoreGetAllTokenIdentifiersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllTokenIdentifiersArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllTokenIdentifiersArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_token_identifiers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetAllTokenIdentifiersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllTokenIdentifiersResult {
  result_value: Option<Vec<String>>,
}

impl ThriftHiveMetastoreGetAllTokenIdentifiersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllTokenIdentifiersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_199 = i_prot.read_string()?;
            val.push(list_elem_199);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllTokenIdentifiersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetAllTokenIdentifiersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetAllTokenIdentifiers"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddMasterKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddMasterKeyArgs {
  key: String,
}

impl ThriftHiveMetastoreAddMasterKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddMasterKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddMasterKeyArgs.key", &f_1)?;
    let ret = ThriftHiveMetastoreAddMasterKeyArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_master_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddMasterKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddMasterKeyResult {
  result_value: Option<i32>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreAddMasterKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddMasterKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddMasterKeyResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddMasterKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAddMasterKey"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreUpdateMasterKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdateMasterKeyArgs {
  seq_number: i32,
  key: String,
}

impl ThriftHiveMetastoreUpdateMasterKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdateMasterKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateMasterKeyArgs.seq_number", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreUpdateMasterKeyArgs.key", &f_2)?;
    let ret = ThriftHiveMetastoreUpdateMasterKeyArgs {
      seq_number: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_master_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("seq_number", TType::I32, 1))?;
    o_prot.write_i32(self.seq_number)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreUpdateMasterKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUpdateMasterKeyResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreUpdateMasterKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUpdateMasterKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreUpdateMasterKeyResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreUpdateMasterKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreRemoveMasterKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRemoveMasterKeyArgs {
  key_seq: i32,
}

impl ThriftHiveMetastoreRemoveMasterKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRemoveMasterKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreRemoveMasterKeyArgs.key_seq", &f_1)?;
    let ret = ThriftHiveMetastoreRemoveMasterKeyArgs {
      key_seq: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("remove_master_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_seq", TType::I32, 1))?;
    o_prot.write_i32(self.key_seq)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreRemoveMasterKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreRemoveMasterKeyResult {
  result_value: Option<bool>,
}

impl ThriftHiveMetastoreRemoveMasterKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreRemoveMasterKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreRemoveMasterKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreRemoveMasterKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreRemoveMasterKey"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetMasterKeysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMasterKeysArgs {
}

impl ThriftHiveMetastoreGetMasterKeysArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMasterKeysArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMasterKeysArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_master_keys_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetMasterKeysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMasterKeysResult {
  result_value: Option<Vec<String>>,
}

impl ThriftHiveMetastoreGetMasterKeysResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMasterKeysResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_200 = i_prot.read_string()?;
            val.push(list_elem_200);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMasterKeysResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetMasterKeysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<String>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetMasterKeys"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetOpenTxnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetOpenTxnsArgs {
}

impl ThriftHiveMetastoreGetOpenTxnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetOpenTxnsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetOpenTxnsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_open_txns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetOpenTxnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetOpenTxnsResult {
  result_value: Option<GetOpenTxnsResponse>,
}

impl ThriftHiveMetastoreGetOpenTxnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetOpenTxnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetOpenTxnsResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetOpenTxnsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetOpenTxnsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetOpenTxnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetOpenTxnsResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetOpenTxns"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetOpenTxnsInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetOpenTxnsInfoArgs {
}

impl ThriftHiveMetastoreGetOpenTxnsInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetOpenTxnsInfoArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetOpenTxnsInfoArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_open_txns_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetOpenTxnsInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetOpenTxnsInfoResult {
  result_value: Option<GetOpenTxnsInfoResponse>,
}

impl ThriftHiveMetastoreGetOpenTxnsInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetOpenTxnsInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetOpenTxnsInfoResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetOpenTxnsInfoResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetOpenTxnsInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetOpenTxnsInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetOpenTxnsInfoResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetOpenTxnsInfo"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreOpenTxnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreOpenTxnsArgs {
  rqst: OpenTxnRequest,
}

impl ThriftHiveMetastoreOpenTxnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreOpenTxnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OpenTxnRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OpenTxnRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreOpenTxnsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreOpenTxnsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("open_txns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreOpenTxnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreOpenTxnsResult {
  result_value: Option<OpenTxnsResponse>,
}

impl ThriftHiveMetastoreOpenTxnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreOpenTxnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<OpenTxnsResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = OpenTxnsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreOpenTxnsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreOpenTxnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<OpenTxnsResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreOpenTxns"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAbortTxnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAbortTxnArgs {
  rqst: AbortTxnRequest,
}

impl ThriftHiveMetastoreAbortTxnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAbortTxnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AbortTxnRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AbortTxnRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAbortTxnArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreAbortTxnArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("abort_txn_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAbortTxnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAbortTxnResult {
  o1: Option<NoSuchTxnException>,
}

impl ThriftHiveMetastoreAbortTxnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAbortTxnResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchTxnException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAbortTxnResult {
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAbortTxnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAbortTxnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAbortTxnsArgs {
  rqst: AbortTxnsRequest,
}

impl ThriftHiveMetastoreAbortTxnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAbortTxnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AbortTxnsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AbortTxnsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAbortTxnsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreAbortTxnsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("abort_txns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAbortTxnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAbortTxnsResult {
  o1: Option<NoSuchTxnException>,
}

impl ThriftHiveMetastoreAbortTxnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAbortTxnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchTxnException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAbortTxnsResult {
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAbortTxnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreCommitTxnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCommitTxnArgs {
  rqst: CommitTxnRequest,
}

impl ThriftHiveMetastoreCommitTxnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCommitTxnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CommitTxnRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CommitTxnRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCommitTxnArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreCommitTxnArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("commit_txn_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCommitTxnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCommitTxnResult {
  o1: Option<NoSuchTxnException>,
  o2: Option<TxnAbortedException>,
}

impl ThriftHiveMetastoreCommitTxnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCommitTxnResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchTxnException> = None;
    let mut f_2: Option<TxnAbortedException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnAbortedException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCommitTxnResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCommitTxnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreReplTblWriteidStateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreReplTblWriteidStateArgs {
  rqst: ReplTblWriteIdStateRequest,
}

impl ThriftHiveMetastoreReplTblWriteidStateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreReplTblWriteidStateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ReplTblWriteIdStateRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ReplTblWriteIdStateRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreReplTblWriteidStateArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreReplTblWriteidStateArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("repl_tbl_writeid_state_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreReplTblWriteidStateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreReplTblWriteidStateResult {
}

impl ThriftHiveMetastoreReplTblWriteidStateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreReplTblWriteidStateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreReplTblWriteidStateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreReplTblWriteidStateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ThriftHiveMetastoreGetValidWriteIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetValidWriteIdsArgs {
  rqst: GetValidWriteIdsRequest,
}

impl ThriftHiveMetastoreGetValidWriteIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetValidWriteIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetValidWriteIdsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetValidWriteIdsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetValidWriteIdsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreGetValidWriteIdsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_valid_write_ids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetValidWriteIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetValidWriteIdsResult {
  result_value: Option<GetValidWriteIdsResponse>,
  o1: Option<NoSuchTxnException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetValidWriteIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetValidWriteIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetValidWriteIdsResponse> = None;
    let mut f_1: Option<NoSuchTxnException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetValidWriteIdsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetValidWriteIdsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetValidWriteIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetValidWriteIdsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetValidWriteIds"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAllocateTableWriteIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAllocateTableWriteIdsArgs {
  rqst: AllocateTableWriteIdsRequest,
}

impl ThriftHiveMetastoreAllocateTableWriteIdsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAllocateTableWriteIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AllocateTableWriteIdsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AllocateTableWriteIdsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAllocateTableWriteIdsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreAllocateTableWriteIdsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("allocate_table_write_ids_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAllocateTableWriteIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAllocateTableWriteIdsResult {
  result_value: Option<AllocateTableWriteIdsResponse>,
  o1: Option<NoSuchTxnException>,
  o2: Option<TxnAbortedException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAllocateTableWriteIdsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAllocateTableWriteIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<AllocateTableWriteIdsResponse> = None;
    let mut f_1: Option<NoSuchTxnException> = None;
    let mut f_2: Option<TxnAbortedException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = AllocateTableWriteIdsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnAbortedException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAllocateTableWriteIdsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAllocateTableWriteIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<AllocateTableWriteIdsResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAllocateTableWriteIds"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreLockArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreLockArgs {
  rqst: LockRequest,
}

impl ThriftHiveMetastoreLockArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreLockArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<LockRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = LockRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreLockArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreLockArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("lock_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreLockResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreLockResult {
  result_value: Option<LockResponse>,
  o1: Option<NoSuchTxnException>,
  o2: Option<TxnAbortedException>,
}

impl ThriftHiveMetastoreLockResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreLockResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LockResponse> = None;
    let mut f_1: Option<NoSuchTxnException> = None;
    let mut f_2: Option<TxnAbortedException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LockResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnAbortedException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreLockResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreLockResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LockResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreLock"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCheckLockArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCheckLockArgs {
  rqst: CheckLockRequest,
}

impl ThriftHiveMetastoreCheckLockArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCheckLockArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CheckLockRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CheckLockRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCheckLockArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreCheckLockArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("check_lock_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCheckLockResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCheckLockResult {
  result_value: Option<LockResponse>,
  o1: Option<NoSuchTxnException>,
  o2: Option<TxnAbortedException>,
  o3: Option<NoSuchLockException>,
}

impl ThriftHiveMetastoreCheckLockResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCheckLockResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LockResponse> = None;
    let mut f_1: Option<NoSuchTxnException> = None;
    let mut f_2: Option<TxnAbortedException> = None;
    let mut f_3: Option<NoSuchLockException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LockResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnAbortedException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = NoSuchLockException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCheckLockResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCheckLockResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LockResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCheckLock"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreUnlockArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUnlockArgs {
  rqst: UnlockRequest,
}

impl ThriftHiveMetastoreUnlockArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUnlockArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UnlockRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = UnlockRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreUnlockArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreUnlockArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unlock_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreUnlockResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreUnlockResult {
  o1: Option<NoSuchLockException>,
  o2: Option<TxnOpenException>,
}

impl ThriftHiveMetastoreUnlockResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreUnlockResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchLockException> = None;
    let mut f_2: Option<TxnOpenException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchLockException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnOpenException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreUnlockResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreUnlockResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreShowLocksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreShowLocksArgs {
  rqst: ShowLocksRequest,
}

impl ThriftHiveMetastoreShowLocksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreShowLocksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ShowLocksRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ShowLocksRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreShowLocksArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreShowLocksArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("show_locks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreShowLocksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreShowLocksResult {
  result_value: Option<ShowLocksResponse>,
}

impl ThriftHiveMetastoreShowLocksResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreShowLocksResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ShowLocksResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ShowLocksResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreShowLocksResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreShowLocksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ShowLocksResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreShowLocks"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreHeartbeatArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreHeartbeatArgs {
  ids: HeartbeatRequest,
}

impl ThriftHiveMetastoreHeartbeatArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreHeartbeatArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<HeartbeatRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = HeartbeatRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreHeartbeatArgs.ids", &f_1)?;
    let ret = ThriftHiveMetastoreHeartbeatArgs {
      ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("heartbeat_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ids", TType::Struct, 1))?;
    self.ids.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreHeartbeatResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreHeartbeatResult {
  o1: Option<NoSuchLockException>,
  o2: Option<NoSuchTxnException>,
  o3: Option<TxnAbortedException>,
}

impl ThriftHiveMetastoreHeartbeatResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreHeartbeatResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchLockException> = None;
    let mut f_2: Option<NoSuchTxnException> = None;
    let mut f_3: Option<TxnAbortedException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchLockException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TxnAbortedException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreHeartbeatResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreHeartbeatResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreHeartbeatTxnRangeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreHeartbeatTxnRangeArgs {
  txns: HeartbeatTxnRangeRequest,
}

impl ThriftHiveMetastoreHeartbeatTxnRangeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreHeartbeatTxnRangeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<HeartbeatTxnRangeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = HeartbeatTxnRangeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreHeartbeatTxnRangeArgs.txns", &f_1)?;
    let ret = ThriftHiveMetastoreHeartbeatTxnRangeArgs {
      txns: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("heartbeat_txn_range_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txns", TType::Struct, 1))?;
    self.txns.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreHeartbeatTxnRangeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreHeartbeatTxnRangeResult {
  result_value: Option<HeartbeatTxnRangeResponse>,
}

impl ThriftHiveMetastoreHeartbeatTxnRangeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreHeartbeatTxnRangeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<HeartbeatTxnRangeResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = HeartbeatTxnRangeResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreHeartbeatTxnRangeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreHeartbeatTxnRangeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<HeartbeatTxnRangeResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreHeartbeatTxnRange"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCompactArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCompactArgs {
  rqst: CompactionRequest,
}

impl ThriftHiveMetastoreCompactArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCompactArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CompactionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CompactionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCompactArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreCompactArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("compact_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCompactResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCompactResult {
}

impl ThriftHiveMetastoreCompactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCompactResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCompactResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCompactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ThriftHiveMetastoreCompact2Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCompact2Args {
  rqst: CompactionRequest,
}

impl ThriftHiveMetastoreCompact2Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCompact2Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CompactionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CompactionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCompact2Args.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreCompact2Args {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("compact2_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCompact2Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCompact2Result {
  result_value: Option<CompactionResponse>,
}

impl ThriftHiveMetastoreCompact2Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCompact2Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CompactionResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CompactionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCompact2Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCompact2Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CompactionResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCompact2"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreShowCompactArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreShowCompactArgs {
  rqst: ShowCompactRequest,
}

impl ThriftHiveMetastoreShowCompactArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreShowCompactArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ShowCompactRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ShowCompactRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreShowCompactArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreShowCompactArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("show_compact_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreShowCompactResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreShowCompactResult {
  result_value: Option<ShowCompactResponse>,
}

impl ThriftHiveMetastoreShowCompactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreShowCompactResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ShowCompactResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ShowCompactResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreShowCompactResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreShowCompactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ShowCompactResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreShowCompact"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddDynamicPartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddDynamicPartitionsArgs {
  rqst: AddDynamicPartitions,
}

impl ThriftHiveMetastoreAddDynamicPartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddDynamicPartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AddDynamicPartitions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AddDynamicPartitions::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddDynamicPartitionsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreAddDynamicPartitionsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_dynamic_partitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddDynamicPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddDynamicPartitionsResult {
  o1: Option<NoSuchTxnException>,
  o2: Option<TxnAbortedException>,
}

impl ThriftHiveMetastoreAddDynamicPartitionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddDynamicPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchTxnException> = None;
    let mut f_2: Option<TxnAbortedException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchTxnException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TxnAbortedException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddDynamicPartitionsResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddDynamicPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetNextNotificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNextNotificationArgs {
  rqst: NotificationEventRequest,
}

impl ThriftHiveMetastoreGetNextNotificationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNextNotificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NotificationEventRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NotificationEventRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetNextNotificationArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreGetNextNotificationArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_next_notification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetNextNotificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNextNotificationResult {
  result_value: Option<NotificationEventResponse>,
}

impl ThriftHiveMetastoreGetNextNotificationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNextNotificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NotificationEventResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NotificationEventResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetNextNotificationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetNextNotificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NotificationEventResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetNextNotification"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetCurrentNotificationEventIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCurrentNotificationEventIdArgs {
}

impl ThriftHiveMetastoreGetCurrentNotificationEventIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCurrentNotificationEventIdArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetCurrentNotificationEventIdArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_current_notificationEventId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetCurrentNotificationEventIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetCurrentNotificationEventIdResult {
  result_value: Option<CurrentNotificationEventId>,
}

impl ThriftHiveMetastoreGetCurrentNotificationEventIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetCurrentNotificationEventIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CurrentNotificationEventId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CurrentNotificationEventId::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetCurrentNotificationEventIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetCurrentNotificationEventIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CurrentNotificationEventId> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetCurrentNotificationEventId"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetNotificationEventsCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNotificationEventsCountArgs {
  rqst: NotificationEventsCountRequest,
}

impl ThriftHiveMetastoreGetNotificationEventsCountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNotificationEventsCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NotificationEventsCountRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NotificationEventsCountRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetNotificationEventsCountArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreGetNotificationEventsCountArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_notification_events_count_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetNotificationEventsCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetNotificationEventsCountResult {
  result_value: Option<NotificationEventsCountResponse>,
}

impl ThriftHiveMetastoreGetNotificationEventsCountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetNotificationEventsCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NotificationEventsCountResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NotificationEventsCountResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetNotificationEventsCountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetNotificationEventsCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NotificationEventsCountResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetNotificationEventsCount"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreFireListenerEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreFireListenerEventArgs {
  rqst: FireEventRequest,
}

impl ThriftHiveMetastoreFireListenerEventArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreFireListenerEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<FireEventRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = FireEventRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreFireListenerEventArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreFireListenerEventArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fire_listener_event_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreFireListenerEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreFireListenerEventResult {
  result_value: Option<FireEventResponse>,
}

impl ThriftHiveMetastoreFireListenerEventResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreFireListenerEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FireEventResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FireEventResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreFireListenerEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreFireListenerEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FireEventResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreFireListenerEvent"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreFlushCacheArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreFlushCacheArgs {
}

impl ThriftHiveMetastoreFlushCacheArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreFlushCacheArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreFlushCacheArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("flushCache_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreFlushCacheResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreFlushCacheResult {
}

impl ThriftHiveMetastoreFlushCacheResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreFlushCacheResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreFlushCacheResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreFlushCacheResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ThriftHiveMetastoreCmRecycleArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCmRecycleArgs {
  request: CmRecycleRequest,
}

impl ThriftHiveMetastoreCmRecycleArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCmRecycleArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CmRecycleRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CmRecycleRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCmRecycleArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreCmRecycleArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cm_recycle_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCmRecycleResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCmRecycleResult {
  result_value: Option<CmRecycleResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreCmRecycleResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCmRecycleResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CmRecycleResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CmRecycleResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCmRecycleResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCmRecycleResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CmRecycleResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCmRecycle"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetFileMetadataByExprArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFileMetadataByExprArgs {
  req: GetFileMetadataByExprRequest,
}

impl ThriftHiveMetastoreGetFileMetadataByExprArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFileMetadataByExprArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetFileMetadataByExprRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetFileMetadataByExprRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetFileMetadataByExprArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreGetFileMetadataByExprArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_file_metadata_by_expr_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetFileMetadataByExprResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFileMetadataByExprResult {
  result_value: Option<GetFileMetadataByExprResult>,
}

impl ThriftHiveMetastoreGetFileMetadataByExprResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFileMetadataByExprResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetFileMetadataByExprResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetFileMetadataByExprResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetFileMetadataByExprResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetFileMetadataByExprResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetFileMetadataByExprResult> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetFileMetadataByExpr"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetFileMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFileMetadataArgs {
  req: GetFileMetadataRequest,
}

impl ThriftHiveMetastoreGetFileMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFileMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetFileMetadataRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetFileMetadataRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetFileMetadataArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreGetFileMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_file_metadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetFileMetadataResult {
  result_value: Option<GetFileMetadataResult>,
}

impl ThriftHiveMetastoreGetFileMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetFileMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetFileMetadataResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetFileMetadataResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetFileMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetFileMetadataResult> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetFileMetadata"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastorePutFileMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePutFileMetadataArgs {
  req: PutFileMetadataRequest,
}

impl ThriftHiveMetastorePutFileMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePutFileMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PutFileMetadataRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PutFileMetadataRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastorePutFileMetadataArgs.req", &f_1)?;
    let ret = ThriftHiveMetastorePutFileMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("put_file_metadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastorePutFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastorePutFileMetadataResult {
  result_value: Option<PutFileMetadataResult>,
}

impl ThriftHiveMetastorePutFileMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastorePutFileMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<PutFileMetadataResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = PutFileMetadataResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastorePutFileMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastorePutFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<PutFileMetadataResult> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastorePutFileMetadata"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreClearFileMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreClearFileMetadataArgs {
  req: ClearFileMetadataRequest,
}

impl ThriftHiveMetastoreClearFileMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreClearFileMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ClearFileMetadataRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ClearFileMetadataRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreClearFileMetadataArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreClearFileMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("clear_file_metadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreClearFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreClearFileMetadataResult {
  result_value: Option<ClearFileMetadataResult>,
}

impl ThriftHiveMetastoreClearFileMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreClearFileMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ClearFileMetadataResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ClearFileMetadataResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreClearFileMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreClearFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ClearFileMetadataResult> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreClearFileMetadata"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCacheFileMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCacheFileMetadataArgs {
  req: CacheFileMetadataRequest,
}

impl ThriftHiveMetastoreCacheFileMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCacheFileMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CacheFileMetadataRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CacheFileMetadataRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCacheFileMetadataArgs.req", &f_1)?;
    let ret = ThriftHiveMetastoreCacheFileMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cache_file_metadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCacheFileMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCacheFileMetadataResult {
  result_value: Option<CacheFileMetadataResult>,
}

impl ThriftHiveMetastoreCacheFileMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCacheFileMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CacheFileMetadataResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CacheFileMetadataResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCacheFileMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCacheFileMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CacheFileMetadataResult> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCacheFileMetadata"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetMetastoreDbUuidArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMetastoreDbUuidArgs {
}

impl ThriftHiveMetastoreGetMetastoreDbUuidArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMetastoreDbUuidArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMetastoreDbUuidArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_metastore_db_uuid_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetMetastoreDbUuidResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetMetastoreDbUuidResult {
  result_value: Option<String>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetMetastoreDbUuidResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetMetastoreDbUuidResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetMetastoreDbUuidResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetMetastoreDbUuidResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetMetastoreDbUuid"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateResourcePlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateResourcePlanArgs {
  request: WMCreateResourcePlanRequest,
}

impl ThriftHiveMetastoreCreateResourcePlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateResourcePlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMCreateResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMCreateResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateResourcePlanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreCreateResourcePlanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_resource_plan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateResourcePlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateResourcePlanResult {
  result_value: Option<WMCreateResourcePlanResponse>,
  o1: Option<AlreadyExistsException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateResourcePlanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateResourcePlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMCreateResourcePlanResponse> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMCreateResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateResourcePlanResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateResourcePlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMCreateResourcePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateResourcePlan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetResourcePlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetResourcePlanArgs {
  request: WMGetResourcePlanRequest,
}

impl ThriftHiveMetastoreGetResourcePlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetResourcePlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMGetResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMGetResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetResourcePlanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetResourcePlanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_resource_plan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetResourcePlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetResourcePlanResult {
  result_value: Option<WMGetResourcePlanResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetResourcePlanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetResourcePlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMGetResourcePlanResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMGetResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetResourcePlanResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetResourcePlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMGetResourcePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetResourcePlan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetActiveResourcePlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetActiveResourcePlanArgs {
  request: WMGetActiveResourcePlanRequest,
}

impl ThriftHiveMetastoreGetActiveResourcePlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetActiveResourcePlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMGetActiveResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMGetActiveResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetActiveResourcePlanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetActiveResourcePlanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_active_resource_plan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetActiveResourcePlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetActiveResourcePlanResult {
  result_value: Option<WMGetActiveResourcePlanResponse>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetActiveResourcePlanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetActiveResourcePlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMGetActiveResourcePlanResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMGetActiveResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetActiveResourcePlanResult {
      result_value: f_0,
      o2: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetActiveResourcePlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMGetActiveResourcePlanResponse> {
    if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetActiveResourcePlan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetAllResourcePlansArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllResourcePlansArgs {
  request: WMGetAllResourcePlanRequest,
}

impl ThriftHiveMetastoreGetAllResourcePlansArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllResourcePlansArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMGetAllResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMGetAllResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetAllResourcePlansArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetAllResourcePlansArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_all_resource_plans_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetAllResourcePlansResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetAllResourcePlansResult {
  result_value: Option<WMGetAllResourcePlanResponse>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetAllResourcePlansResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetAllResourcePlansResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMGetAllResourcePlanResponse> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMGetAllResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetAllResourcePlansResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetAllResourcePlansResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMGetAllResourcePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetAllResourcePlans"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAlterResourcePlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterResourcePlanArgs {
  request: WMAlterResourcePlanRequest,
}

impl ThriftHiveMetastoreAlterResourcePlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterResourcePlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMAlterResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMAlterResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterResourcePlanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreAlterResourcePlanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_resource_plan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterResourcePlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterResourcePlanResult {
  result_value: Option<WMAlterResourcePlanResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterResourcePlanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterResourcePlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMAlterResourcePlanResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMAlterResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterResourcePlanResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterResourcePlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMAlterResourcePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAlterResourcePlan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreValidateResourcePlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreValidateResourcePlanArgs {
  request: WMValidateResourcePlanRequest,
}

impl ThriftHiveMetastoreValidateResourcePlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreValidateResourcePlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMValidateResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMValidateResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreValidateResourcePlanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreValidateResourcePlanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("validate_resource_plan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreValidateResourcePlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreValidateResourcePlanResult {
  result_value: Option<WMValidateResourcePlanResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreValidateResourcePlanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreValidateResourcePlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMValidateResourcePlanResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMValidateResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreValidateResourcePlanResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreValidateResourcePlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMValidateResourcePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreValidateResourcePlan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropResourcePlanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropResourcePlanArgs {
  request: WMDropResourcePlanRequest,
}

impl ThriftHiveMetastoreDropResourcePlanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropResourcePlanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMDropResourcePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMDropResourcePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropResourcePlanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreDropResourcePlanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_resource_plan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropResourcePlanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropResourcePlanResult {
  result_value: Option<WMDropResourcePlanResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropResourcePlanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropResourcePlanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMDropResourcePlanResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMDropResourcePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropResourcePlanResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropResourcePlanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMDropResourcePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropResourcePlan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateWmTriggerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateWmTriggerArgs {
  request: WMCreateTriggerRequest,
}

impl ThriftHiveMetastoreCreateWmTriggerArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateWmTriggerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMCreateTriggerRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMCreateTriggerRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateWmTriggerArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreCreateWmTriggerArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_wm_trigger_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateWmTriggerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateWmTriggerResult {
  result_value: Option<WMCreateTriggerResponse>,
  o1: Option<AlreadyExistsException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateWmTriggerResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateWmTriggerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMCreateTriggerResponse> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMCreateTriggerResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateWmTriggerResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateWmTriggerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMCreateTriggerResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateWmTrigger"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAlterWmTriggerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterWmTriggerArgs {
  request: WMAlterTriggerRequest,
}

impl ThriftHiveMetastoreAlterWmTriggerArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterWmTriggerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMAlterTriggerRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMAlterTriggerRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterWmTriggerArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreAlterWmTriggerArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_wm_trigger_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterWmTriggerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterWmTriggerResult {
  result_value: Option<WMAlterTriggerResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterWmTriggerResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterWmTriggerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMAlterTriggerResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMAlterTriggerResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterWmTriggerResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterWmTriggerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMAlterTriggerResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAlterWmTrigger"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropWmTriggerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropWmTriggerArgs {
  request: WMDropTriggerRequest,
}

impl ThriftHiveMetastoreDropWmTriggerArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropWmTriggerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMDropTriggerRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMDropTriggerRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropWmTriggerArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreDropWmTriggerArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_wm_trigger_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropWmTriggerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropWmTriggerResult {
  result_value: Option<WMDropTriggerResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropWmTriggerResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropWmTriggerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMDropTriggerResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMDropTriggerResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropWmTriggerResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropWmTriggerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMDropTriggerResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropWmTrigger"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetTriggersForResourceplanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTriggersForResourceplanArgs {
  request: WMGetTriggersForResourePlanRequest,
}

impl ThriftHiveMetastoreGetTriggersForResourceplanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTriggersForResourceplanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMGetTriggersForResourePlanRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMGetTriggersForResourePlanRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetTriggersForResourceplanArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreGetTriggersForResourceplanArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_triggers_for_resourceplan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetTriggersForResourceplanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetTriggersForResourceplanResult {
  result_value: Option<WMGetTriggersForResourePlanResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetTriggersForResourceplanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetTriggersForResourceplanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMGetTriggersForResourePlanResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMGetTriggersForResourePlanResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetTriggersForResourceplanResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetTriggersForResourceplanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMGetTriggersForResourePlanResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetTriggersForResourceplan"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateWmPoolArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateWmPoolArgs {
  request: WMCreatePoolRequest,
}

impl ThriftHiveMetastoreCreateWmPoolArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateWmPoolArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMCreatePoolRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMCreatePoolRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateWmPoolArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreCreateWmPoolArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_wm_pool_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateWmPoolResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateWmPoolResult {
  result_value: Option<WMCreatePoolResponse>,
  o1: Option<AlreadyExistsException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateWmPoolResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateWmPoolResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMCreatePoolResponse> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMCreatePoolResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateWmPoolResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateWmPoolResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMCreatePoolResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateWmPool"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAlterWmPoolArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterWmPoolArgs {
  request: WMAlterPoolRequest,
}

impl ThriftHiveMetastoreAlterWmPoolArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterWmPoolArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMAlterPoolRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMAlterPoolRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterWmPoolArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreAlterWmPoolArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_wm_pool_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterWmPoolResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterWmPoolResult {
  result_value: Option<WMAlterPoolResponse>,
  o1: Option<AlreadyExistsException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterWmPoolResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterWmPoolResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMAlterPoolResponse> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMAlterPoolResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterWmPoolResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterWmPoolResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMAlterPoolResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreAlterWmPool"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropWmPoolArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropWmPoolArgs {
  request: WMDropPoolRequest,
}

impl ThriftHiveMetastoreDropWmPoolArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropWmPoolArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMDropPoolRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMDropPoolRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropWmPoolArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreDropWmPoolArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_wm_pool_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropWmPoolResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropWmPoolResult {
  result_value: Option<WMDropPoolResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropWmPoolResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropWmPoolResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMDropPoolResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMDropPoolResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropWmPoolResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropWmPoolResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMDropPoolResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropWmPool"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateOrUpdateWmMappingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateOrUpdateWmMappingArgs {
  request: WMCreateOrUpdateMappingRequest,
}

impl ThriftHiveMetastoreCreateOrUpdateWmMappingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateOrUpdateWmMappingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMCreateOrUpdateMappingRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMCreateOrUpdateMappingRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateOrUpdateWmMappingArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreCreateOrUpdateWmMappingArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_or_update_wm_mapping_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateOrUpdateWmMappingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateOrUpdateWmMappingResult {
  result_value: Option<WMCreateOrUpdateMappingResponse>,
  o1: Option<AlreadyExistsException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateOrUpdateWmMappingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateOrUpdateWmMappingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMCreateOrUpdateMappingResponse> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMCreateOrUpdateMappingResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateOrUpdateWmMappingResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateOrUpdateWmMappingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMCreateOrUpdateMappingResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateOrUpdateWmMapping"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropWmMappingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropWmMappingArgs {
  request: WMDropMappingRequest,
}

impl ThriftHiveMetastoreDropWmMappingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropWmMappingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMDropMappingRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMDropMappingRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropWmMappingArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreDropWmMappingArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_wm_mapping_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropWmMappingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropWmMappingResult {
  result_value: Option<WMDropMappingResponse>,
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropWmMappingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropWmMappingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMDropMappingResponse> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMDropMappingResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropWmMappingResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropWmMappingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMDropMappingResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreDropWmMapping"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs {
  request: WMCreateOrDropTriggerToPoolMappingRequest,
}

impl ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<WMCreateOrDropTriggerToPoolMappingRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = WMCreateOrDropTriggerToPoolMappingRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs.request", &f_1)?;
    let ret = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_or_drop_wm_trigger_to_pool_mapping_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult {
  result_value: Option<WMCreateOrDropTriggerToPoolMappingResponse>,
  o1: Option<AlreadyExistsException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<InvalidObjectException>,
  o4: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<WMCreateOrDropTriggerToPoolMappingResponse> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<InvalidObjectException> = None;
    let mut f_4: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = WMCreateOrDropTriggerToPoolMappingResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = InvalidObjectException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
      o3: f_3,
      o4: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMappingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o4 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o4", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<WMCreateOrDropTriggerToPoolMappingResponse> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else if self.o4.is_some() {
      Err(thrift::Error::User(Box::new(self.o4.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreCreateOrDropWmTriggerToPoolMapping"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreCreateIschemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateIschemaArgs {
  schema: ISchema,
}

impl ThriftHiveMetastoreCreateIschemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateIschemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchema> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchema::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreCreateIschemaArgs.schema", &f_1)?;
    let ret = ThriftHiveMetastoreCreateIschemaArgs {
      schema: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_ischema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 1))?;
    self.schema.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreCreateIschemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreCreateIschemaResult {
  o2: Option<NoSuchObjectException>,
  o1: Option<AlreadyExistsException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreCreateIschemaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreCreateIschemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_neg1: Option<NoSuchObjectException> = None;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        neg1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_neg1 = Some(val);
        },
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreCreateIschemaResult {
      o2: f_neg1,
      o1: f_1,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreCreateIschemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, -1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAlterIschemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterIschemaArgs {
  rqst: AlterISchemaRequest,
}

impl ThriftHiveMetastoreAlterIschemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterIschemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlterISchemaRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlterISchemaRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAlterIschemaArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreAlterIschemaArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alter_ischema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAlterIschemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAlterIschemaResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAlterIschemaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAlterIschemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAlterIschemaResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAlterIschemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetIschemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetIschemaArgs {
  name: ISchemaName,
}

impl ThriftHiveMetastoreGetIschemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetIschemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetIschemaArgs.name", &f_1)?;
    let ret = ThriftHiveMetastoreGetIschemaArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_ischema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetIschemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetIschemaResult {
  result_value: Option<ISchema>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetIschemaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetIschemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ISchema> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ISchema::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetIschemaResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetIschemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ISchema> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetIschema"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropIschemaArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropIschemaArgs {
  name: ISchemaName,
}

impl ThriftHiveMetastoreDropIschemaArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropIschemaArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropIschemaArgs.name", &f_1)?;
    let ret = ThriftHiveMetastoreDropIschemaArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_ischema_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropIschemaResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropIschemaResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreDropIschemaResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropIschemaResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropIschemaResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropIschemaResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddSchemaVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddSchemaVersionArgs {
  schema_version: SchemaVersion,
}

impl ThriftHiveMetastoreAddSchemaVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddSchemaVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaVersion> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaVersion::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddSchemaVersionArgs.schema_version", &f_1)?;
    let ret = ThriftHiveMetastoreAddSchemaVersionArgs {
      schema_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_schema_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaVersion", TType::Struct, 1))?;
    self.schema_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddSchemaVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddSchemaVersionResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<NoSuchObjectException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreAddSchemaVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddSchemaVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<NoSuchObjectException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddSchemaVersionResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddSchemaVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetSchemaVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaVersionArgs {
  schema_version: SchemaVersionDescriptor,
}

impl ThriftHiveMetastoreGetSchemaVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaVersionDescriptor> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaVersionDescriptor::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaVersionArgs.schema_version", &f_1)?;
    let ret = ThriftHiveMetastoreGetSchemaVersionArgs {
      schema_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_schema_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaVersion", TType::Struct, 1))?;
    self.schema_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSchemaVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaVersionResult {
  result_value: Option<SchemaVersion>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetSchemaVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SchemaVersion> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SchemaVersion::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSchemaVersionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSchemaVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SchemaVersion> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSchemaVersion"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetSchemaLatestVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaLatestVersionArgs {
  schema_name: ISchemaName,
}

impl ThriftHiveMetastoreGetSchemaLatestVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaLatestVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaLatestVersionArgs.schema_name", &f_1)?;
    let ret = ThriftHiveMetastoreGetSchemaLatestVersionArgs {
      schema_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_schema_latest_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::Struct, 1))?;
    self.schema_name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSchemaLatestVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaLatestVersionResult {
  result_value: Option<SchemaVersion>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetSchemaLatestVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaLatestVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SchemaVersion> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SchemaVersion::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSchemaLatestVersionResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSchemaLatestVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SchemaVersion> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSchemaLatestVersion"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetSchemaAllVersionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaAllVersionsArgs {
  schema_name: ISchemaName,
}

impl ThriftHiveMetastoreGetSchemaAllVersionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaAllVersionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ISchemaName> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ISchemaName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemaAllVersionsArgs.schema_name", &f_1)?;
    let ret = ThriftHiveMetastoreGetSchemaAllVersionsArgs {
      schema_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_schema_all_versions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaName", TType::Struct, 1))?;
    self.schema_name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSchemaAllVersionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemaAllVersionsResult {
  result_value: Option<Vec<SchemaVersion>>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetSchemaAllVersionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemaAllVersionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<SchemaVersion>> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SchemaVersion> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_201 = SchemaVersion::read_from_in_protocol(i_prot)?;
            val.push(list_elem_201);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSchemaAllVersionsResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSchemaAllVersionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<SchemaVersion>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSchemaAllVersions"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreDropSchemaVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropSchemaVersionArgs {
  schema_version: SchemaVersionDescriptor,
}

impl ThriftHiveMetastoreDropSchemaVersionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropSchemaVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaVersionDescriptor> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaVersionDescriptor::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreDropSchemaVersionArgs.schema_version", &f_1)?;
    let ret = ThriftHiveMetastoreDropSchemaVersionArgs {
      schema_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("drop_schema_version_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaVersion", TType::Struct, 1))?;
    self.schema_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreDropSchemaVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreDropSchemaVersionResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreDropSchemaVersionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreDropSchemaVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreDropSchemaVersionResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreDropSchemaVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetSchemasByColsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemasByColsArgs {
  rqst: FindSchemasByColsRqst,
}

impl ThriftHiveMetastoreGetSchemasByColsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemasByColsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<FindSchemasByColsRqst> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = FindSchemasByColsRqst::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSchemasByColsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreGetSchemasByColsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_schemas_by_cols_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSchemasByColsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSchemasByColsResult {
  result_value: Option<FindSchemasByColsResp>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetSchemasByColsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSchemasByColsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindSchemasByColsResp> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindSchemasByColsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSchemasByColsResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSchemasByColsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindSchemasByColsResp> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSchemasByCols"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreMapSchemaVersionToSerdeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreMapSchemaVersionToSerdeArgs {
  rqst: MapSchemaVersionToSerdeRequest,
}

impl ThriftHiveMetastoreMapSchemaVersionToSerdeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreMapSchemaVersionToSerdeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MapSchemaVersionToSerdeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MapSchemaVersionToSerdeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreMapSchemaVersionToSerdeArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreMapSchemaVersionToSerdeArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("map_schema_version_to_serde_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreMapSchemaVersionToSerdeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreMapSchemaVersionToSerdeResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreMapSchemaVersionToSerdeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreMapSchemaVersionToSerdeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreMapSchemaVersionToSerdeResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreMapSchemaVersionToSerdeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreSetSchemaVersionStateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetSchemaVersionStateArgs {
  rqst: SetSchemaVersionStateRequest,
}

impl ThriftHiveMetastoreSetSchemaVersionStateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetSchemaVersionStateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SetSchemaVersionStateRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SetSchemaVersionStateRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreSetSchemaVersionStateArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreSetSchemaVersionStateArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_schema_version_state_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreSetSchemaVersionStateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreSetSchemaVersionStateResult {
  o1: Option<NoSuchObjectException>,
  o2: Option<InvalidOperationException>,
  o3: Option<MetaException>,
}

impl ThriftHiveMetastoreSetSchemaVersionStateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreSetSchemaVersionStateResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<InvalidOperationException> = None;
    let mut f_3: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = InvalidOperationException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreSetSchemaVersionStateResult {
      o1: f_1,
      o2: f_2,
      o3: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreSetSchemaVersionStateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o3 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o3", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.o3.is_some() {
      Err(thrift::Error::User(Box::new(self.o3.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreAddSerdeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddSerdeArgs {
  serde: SerDeInfo,
}

impl ThriftHiveMetastoreAddSerdeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddSerdeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SerDeInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SerDeInfo::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddSerdeArgs.serde", &f_1)?;
    let ret = ThriftHiveMetastoreAddSerdeArgs {
      serde: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_serde_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serde", TType::Struct, 1))?;
    self.serde.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddSerdeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddSerdeResult {
  o1: Option<AlreadyExistsException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreAddSerdeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddSerdeResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<AlreadyExistsException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = AlreadyExistsException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddSerdeResult {
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddSerdeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetSerdeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSerdeArgs {
  rqst: GetSerdeRequest,
}

impl ThriftHiveMetastoreGetSerdeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSerdeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetSerdeRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetSerdeRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetSerdeArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreGetSerdeArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_serde_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetSerdeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetSerdeResult {
  result_value: Option<SerDeInfo>,
  o1: Option<NoSuchObjectException>,
  o2: Option<MetaException>,
}

impl ThriftHiveMetastoreGetSerdeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetSerdeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<SerDeInfo> = None;
    let mut f_1: Option<NoSuchObjectException> = None;
    let mut f_2: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = SerDeInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = NoSuchObjectException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetSerdeResult {
      result_value: f_0,
      o1: f_1,
      o2: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetSerdeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o2", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<SerDeInfo> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.o2.is_some() {
      Err(thrift::Error::User(Box::new(self.o2.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetSerde"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreGetLockMaterializationRebuildArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetLockMaterializationRebuildArgs {
  db_name: String,
  table_name: String,
  txn_id: i64,
}

impl ThriftHiveMetastoreGetLockMaterializationRebuildArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetLockMaterializationRebuildArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetLockMaterializationRebuildArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreGetLockMaterializationRebuildArgs.table_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreGetLockMaterializationRebuildArgs.txn_id", &f_3)?;
    let ret = ThriftHiveMetastoreGetLockMaterializationRebuildArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      txn_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_lock_materialization_rebuild_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnId", TType::I64, 3))?;
    o_prot.write_i64(self.txn_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetLockMaterializationRebuildResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetLockMaterializationRebuildResult {
  result_value: Option<LockResponse>,
}

impl ThriftHiveMetastoreGetLockMaterializationRebuildResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetLockMaterializationRebuildResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LockResponse> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LockResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetLockMaterializationRebuildResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetLockMaterializationRebuildResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LockResponse> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetLockMaterializationRebuild"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs {
  db_name: String,
  table_name: String,
  txn_id: i64,
}

impl ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs.db_name", &f_1)?;
    verify_required_field_exists("ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs.table_name", &f_2)?;
    verify_required_field_exists("ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs.txn_id", &f_3)?;
    let ret = ThriftHiveMetastoreHeartbeatLockMaterializationRebuildArgs {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      txn_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("heartbeat_lock_materialization_rebuild_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("txnId", TType::I64, 3))?;
    o_prot.write_i64(self.txn_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult {
  result_value: Option<bool>,
}

impl ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreHeartbeatLockMaterializationRebuildResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreHeartbeatLockMaterializationRebuild"
          )
        )
      )
    }
  }
}

//
// ThriftHiveMetastoreAddRuntimeStatsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddRuntimeStatsArgs {
  stat: RuntimeStat,
}

impl ThriftHiveMetastoreAddRuntimeStatsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddRuntimeStatsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<RuntimeStat> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = RuntimeStat::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreAddRuntimeStatsArgs.stat", &f_1)?;
    let ret = ThriftHiveMetastoreAddRuntimeStatsArgs {
      stat: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("add_runtime_stats_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stat", TType::Struct, 1))?;
    self.stat.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreAddRuntimeStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreAddRuntimeStatsResult {
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreAddRuntimeStatsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreAddRuntimeStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreAddRuntimeStatsResult {
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreAddRuntimeStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ThriftHiveMetastoreGetRuntimeStatsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetRuntimeStatsArgs {
  rqst: GetRuntimeStatsRequest,
}

impl ThriftHiveMetastoreGetRuntimeStatsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetRuntimeStatsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<GetRuntimeStatsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = GetRuntimeStatsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ThriftHiveMetastoreGetRuntimeStatsArgs.rqst", &f_1)?;
    let ret = ThriftHiveMetastoreGetRuntimeStatsArgs {
      rqst: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_runtime_stats_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rqst", TType::Struct, 1))?;
    self.rqst.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ThriftHiveMetastoreGetRuntimeStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ThriftHiveMetastoreGetRuntimeStatsResult {
  result_value: Option<Vec<RuntimeStat>>,
  o1: Option<MetaException>,
}

impl ThriftHiveMetastoreGetRuntimeStatsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThriftHiveMetastoreGetRuntimeStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<RuntimeStat>> = None;
    let mut f_1: Option<MetaException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<RuntimeStat> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_202 = RuntimeStat::read_from_in_protocol(i_prot)?;
            val.push(list_elem_202);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = MetaException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ThriftHiveMetastoreGetRuntimeStatsResult {
      result_value: f_0,
      o1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ThriftHiveMetastoreGetRuntimeStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.o1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("o1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<RuntimeStat>> {
    if self.o1.is_some() {
      Err(thrift::Error::User(Box::new(self.o1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ThriftHiveMetastoreGetRuntimeStats"
          )
        )
      )
    }
  }
}

