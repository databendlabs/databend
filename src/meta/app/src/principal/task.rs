// Copyright 2021 Datafuse Labs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::collections::BTreeMap;

use chrono::DateTime;
use chrono::Utc;

pub const EMPTY_TASK_ID: u64 = 0;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ScheduleType {
    IntervalType = 0,
    CronType = 1,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum Status {
    Suspended = 0,
    Started = 1,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum State {
    Scheduled = 0,
    Executing = 1,
    Succeeded = 2,
    Failed = 3,
    Cancelled = 4,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ScheduleOptions {
    pub interval: Option<i32>,
    pub cron: Option<String>,
    pub time_zone: Option<String>,
    pub schedule_type: ScheduleType,
    pub milliseconds_interval: Option<u64>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct WarehouseOptions {
    pub warehouse: Option<String>,
    pub using_warehouse_size: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Task {
    pub task_id: u64,
    pub task_name: String,
    pub query_text: String,
    pub when_condition: Option<String>,
    pub after: Vec<String>,
    pub comment: Option<String>,
    // expired useless
    pub owner: String,
    pub owner_user: String,
    pub schedule_options: Option<ScheduleOptions>,
    pub warehouse_options: Option<WarehouseOptions>,
    pub next_scheduled_at: Option<DateTime<Utc>>,
    pub suspend_task_after_num_failures: Option<u64>,
    // TODO
    pub error_integration: Option<String>,
    pub status: Status,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub last_suspended_at: Option<DateTime<Utc>>,
    // TODO
    pub session_params: BTreeMap<String, String>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct TaskRun {
    pub task: Task,
    pub run_id: u64,
    pub attempt_number: i32,
    pub state: State,
    pub scheduled_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub error_code: i64,
    pub error_message: Option<String>,
    // expired useless
    pub root_task_id: u64,
}

impl TaskRun {
    pub fn key(&self) -> String {
        format!("{}@{}", self.task.task_name, self.run_id)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum TaskMessage {
    ExecuteTask(Task),
    ScheduleTask(Task),
    DeleteTask(String),
    AfterTask(Task),
}

impl TaskMessage {
    pub fn task_name(&self) -> &str {
        match self {
            TaskMessage::ExecuteTask(task)
            | TaskMessage::ScheduleTask(task)
            | TaskMessage::AfterTask(task) => task.task_name.as_str(),
            TaskMessage::DeleteTask(task_name) => task_name.as_str(),
        }
    }

    pub fn key(&self) -> String {
        let ty = match self {
            TaskMessage::ExecuteTask(_) => 0,
            TaskMessage::ScheduleTask(_) => 1,
            TaskMessage::DeleteTask(_) => 2,
            TaskMessage::AfterTask(_) => 3,
        };
        format!("{}-{}-{}", TaskMessage::prefix(), ty, self.task_name())
    }

    pub fn schedule_key(task_name: &str) -> String {
        format!("{}-1-{task_name}", TaskMessage::prefix())
    }

    pub fn prefix() -> i64 {
        0
    }

    /// Returns the inclusive range of key prefixes used by `TaskMessage`.
    ///
    /// This range can be used to scan all keys generated by `TaskMessage::key()`
    /// and related methods (e.g., `schedule_key`). The prefix `0` is prepended
    /// to all task-related keys to group them under the same prefix range,
    /// enabling efficient key scanning or iteration.
    ///
    /// The returned range is (0, 1), which includes all keys starting with `0-`
    /// (as produced by `TaskMessage::prefix()`), and excludes any other unrelated prefixes.
    pub fn prefix_range() -> (i64, i64) {
        (0, 1)
    }
}
