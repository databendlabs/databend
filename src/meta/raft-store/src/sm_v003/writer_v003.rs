// Copyright 2021 Datafuse Labs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fmt;
use std::io;

use databend_common_meta_types::protobuf as pb;
use databend_common_meta_types::snapshot_db::DB;
use databend_common_meta_types::sys_data::SysData;
use futures::Stream;
use futures_util::TryStreamExt;
use log::info;
use rotbl::v001::SeqMarked;
use seq_marked::SeqData;
use state_machine_api::MetaValue;
use state_machine_api::SeqV;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;

use crate::leveled_store::db_builder::DBBuilder;
use crate::leveled_store::value_convert::ValueConvert;
use crate::sm_v003::write_entry::WriteEntry;
use crate::sm_v003::writer_stat::WriterStat;
use crate::snapshot_config::SnapshotConfig;
use crate::state_machine::MetaSnapshotId;

/// Write kv pair snapshot data to [`SnapshotStoreV002`].
pub struct WriterV003 {
    db_builder: DBBuilder,

    snapshot_config: SnapshotConfig,

    stat: WriterStat,
}

impl WriterV003 {
    /// Convert protobuf SeqV to SeqMarked format for WriterV003.
    /// Used by V004 snapshot receiver to process incoming KV data.
    pub fn convert_seq_v_to_seq_marked(seq_v: pb::SeqV) -> Result<SeqMarked, io::Error> {
        let native_seq_v = SeqV::from(seq_v);
        let seq_marked_meta_value = SeqMarked::from(native_seq_v);
        seq_marked_meta_value.conv_to()
    }

    /// Convert SeqMarked to protobuf SeqV for V004 snapshot streaming.
    /// Used by V004 snapshot sender to stream KV data from snapshot DB.
    /// Returns error for tombstones since they shouldn't be streamed.
    pub fn convert_seq_data_to_seq_v(seq_data: SeqData) -> Result<pb::SeqV, io::Error> {
        let seq_data = SeqData::<MetaValue>::conv_from(seq_data)?;
        let (seq, (meta, data)) = seq_data.into_parts();

        let seq_v = SeqV { seq, data, meta };
        Ok(pb::SeqV::from(seq_v))
    }

    /// Create a singleton writer for the snapshot.
    pub fn new(snapshot_config: &SnapshotConfig) -> Result<Self, io::Error> {
        let (storage_path, temp_rel_path) = snapshot_config.snapshot_temp_dir_fn();

        let db_builder = DBBuilder::new(
            storage_path.clone(),
            &temp_rel_path,
            snapshot_config.raft_config().to_rotbl_config(),
        )?;

        let writer = WriterV003 {
            db_builder,
            snapshot_config: snapshot_config.clone(),
            stat: WriterStat::new(),
        };

        Ok(writer)
    }

    /// Test only
    pub async fn write_kv_stream(
        self,
        mut stream: impl Stream<Item = Result<(String, SeqMarked), io::Error>> + Unpin,
        snapshot_id: MetaSnapshotId,
        sys_data: SysData,
    ) -> Result<DB, io::Error> {
        let (tx, jh) = self.spawn_writer_thread("write_kv_stream");

        while let Some((k, v)) = stream.try_next().await? {
            let ent = WriteEntry::Data((k, v));
            tx.send(ent)
                .await
                .map_err(|_e| io::Error::other("fail to send entry to writer thread"))?;
        }

        tx.send(WriteEntry::Finish((snapshot_id, sys_data)))
            .await
            .map_err(|_e| io::Error::other("fail to send entry to writer thread"))?;

        let db = jh.await.map_err(io::Error::other)??;

        Ok(db)
    }

    /// Write entries to the snapshot, without flushing.
    ///
    /// Returns the count of entries
    pub fn write_kv(
        mut self,
        mut kv_rx: mpsc::Receiver<WriteEntry<(String, SeqMarked), (MetaSnapshotId, SysData)>>,
    ) -> Result<DB, io::Error> {
        while let Some(ent) = kv_rx.blocking_recv() {
            // debug!(entry :? =(&ent); "write kv");

            let (k, v) = match ent {
                WriteEntry::Data(ent) => ent,
                WriteEntry::Finish((snapshot_id, sys_data)) => {
                    info!(
                        "received WriteEntry::Finish event, written: {}, flush with: {:?}",
                        self.stat, sys_data
                    );
                    let db = self.commit(snapshot_id, sys_data)?;
                    return Ok(db);
                }
            };

            self.db_builder.append_kv(k, v)?;

            self.stat.inc();
        }

        Err(io::Error::new(
            io::ErrorKind::UnexpectedEof,
            "input channel is closed",
        ))
    }

    /// Flush all data to disk, and move to the final path, generated by snapshot id.
    ///
    /// Returns a [`DB`].
    ///
    /// This method consumes the writer, thus the writer will not be used after commit.
    pub fn commit(self, snapshot_id: MetaSnapshotId, sys_data: SysData) -> Result<DB, io::Error> {
        self.db_builder
            .commit_to_snapshot_store(&self.snapshot_config, snapshot_id, sys_data)
    }

    /// Spawn a thread to receive snapshot data `(String, SeqMarked)`
    /// and write them to a temp snapshot file.
    ///
    /// It returns a sender to send entries and a handle to wait for the thread to finish.
    /// Internally it calls tokio::spawn_blocking.
    ///
    /// When a [`WritenEntry::Finish`] is received, the thread will flush the data to disk and return
    /// a [`TempSnapshotDataV003`] and a [`SnapshotStat`].
    ///
    /// [`TempSnapshotDataV003`] is a temporary snapshot data that will be renamed to the final path by the caller.
    #[allow(clippy::type_complexity)]
    pub fn spawn_writer_thread(
        self,
        context: impl fmt::Display + Send + Sync + 'static,
    ) -> (
        mpsc::Sender<WriteEntry<(String, SeqMarked), (MetaSnapshotId, SysData)>>,
        JoinHandle<Result<DB, io::Error>>,
    ) {
        let (tx, rx) = mpsc::channel(64 * 1024);

        // Spawn another thread to write entries to disk.
        let join_handle = databend_common_base::runtime::spawn_blocking(move || {
            let with_context =
                |e: io::Error| io::Error::new(e.kind(), format!("{} while {}", e, context));

            info!("snapshot_writer_thread start writing: {}", context);
            let db = self.write_kv(rx).map_err(with_context)?;

            info!("snapshot writer flushed: final path: {}", db.path());

            Ok::<DB, io::Error>(db)
        });

        (tx, join_handle)
    }
}
